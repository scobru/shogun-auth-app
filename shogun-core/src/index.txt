// Import delle dipendenze
import Gun, { IGunInstance, IGunUserInstance } from "gun";
import { ethers, HDNodeWallet } from "ethers";
import { localStorage } from "./utils/storageMock";
import { GunDB } from "./gun/gun";
import { MetaMask } from "./connector/metamask";
import { Webauthn } from "./webauthn/webauthn";
import { Stealth } from "./stealth/stealth";
import Wallet from "ethereumjs-wallet";
import "./hedgehog/browser";
import { CONFIG } from "./config";
import { ShogunEventEmitter, ShogunEvents } from "./events";
import {
  ShogunSDKConfig,
  WalletInfo,
  AuthResult,
  SignUpResult,
  IShogunSDK,
} from "./types/shogun";

// Istanza Gun globale
export let gun: IGunInstance<any>;

// Gun
if (typeof window !== "undefined") {
  (window as any).Gun = Gun;
} else if (typeof global !== "undefined") {
  (global as any).Gun = Gun;
}

export function log(message: string, ...args: any[]) {
  console.log(CONFIG.PREFIX + message, ...args);
}

/**
 * SHOGUN SDK - Libreria semplificata per la gestione di wallet crypto con GunDB
 * @version 1.1.0
 */
export class ShogunSDK implements IShogunSDK {
  public gun: IGunInstance<any>;
  private storage: Storage;
  public gundb: GunDB;
  public hedgehog: any;
  public webauthn: Webauthn | undefined;
  public metamask: MetaMask | undefined;
  public stealth: Stealth | undefined;
  private eventEmitter: ShogunEventEmitter;

  /**
   * Inizializza l'SDK di SHOGUN
   * @param {Object} config - Configurazione
   * @param {string[]} config.peers - Array di peer GunDB
   */
  constructor(config: ShogunSDKConfig) {
    const isNode = typeof window === "undefined";
    this.storage = isNode ? localStorage : window.localStorage;

    // Inizializza GunDB
    this.gundb = new GunDB(config.peers);
    this.gun = this.gundb.gun as IGunInstance<any>;

    // Esporta l'istanza gun globalmente
    gun = this.gun;

    // Inizializza Hedgehog con le funzioni appropriate
    const setAuthFn = async (obj: { lookupKey: string }) =>
      this.gundb.createIfNotExists("Authentications", obj.lookupKey, obj);
    const setUserFn = async (obj: {
      walletAddress: string;
      username: string;
    }) =>
      this.gundb.createIfNotExists(
        "Users",
        obj.walletAddress || obj.username,
        obj
      );
    const getFn = async (obj: { lookupKey: string }) =>
      this.gundb.readRecordFromGun("Authentications", obj);

    //@ts-ignore
    this.hedgehog = new Hedgehog(getFn, setAuthFn, setUserFn) as any;
    this.webauthn = new Webauthn(this.gundb, this.hedgehog);
    this.metamask = new MetaMask(this.gundb, this.hedgehog);
    this.stealth = new Stealth(this.gundb);
    this.initGunSession();
    this.eventEmitter = new ShogunEventEmitter();

    // Aggiungiamo un handler di debug per gli eventi in development
    if (process.env.NODE_ENV === "development") {
      this.eventEmitter.on("error", (data) => {
        console.error("ShogunSDK Error:", data);
      });

      this.eventEmitter.on("auth:signup", (data) => {
        console.log("ShogunSDK Signup:", data);
      });
    }
  }

  checkGun() {
    if (!this.gun) {
      throw new Error("Gun non è inizializzato");
    }
  }

  /**
   * Inizializza la sessione GUN
   * @private
   */
  async initGunSession() {
    if (!Node) {
      const user = this.gun.user();
      user.recall({ sessionStorage: true });
    }
  }

  private createAuthResult(
    success: boolean,
    data?: {
      userPub?: string;
      password?: string;
      wallet?: any;
      error?: string;
      username?: string;
    }
  ): AuthResult {
    return {
      success,
      ...(data || {}),
    };
  }

  /**
   * Autentica un utente GUN con una coppia di chiavi
   * @param {Object} pair - Coppia di chiavi
   */
  async authenticateGunUserWithPair(pair: any) {
    return this.gundb.authenticateGunUserWithPair(pair);
  }

  /**
   * Crea un nuovo utente GUN con una nuova coppia di chiavi
   * @param {string} username - Nome utente
   */
  async createGunUserWithPair(username: string) {
    return this.gundb.createGunUserWithPair(username);
  }

  /**
   * Registra un nuovo utente
   * @param {string} username - Nome utente
   * @param {string} password - Password
   * @returns {Promise<{wallet: Wallet, pub: string}>}
   */
  async signUp(
    username: string,
    password: string
  ): Promise<
    | { success: boolean; wallet: any; pub: string }
    | { success: boolean; error: string }
  > {
    try {
      // Prima verifichiamo se l'utente esiste già su Hedgehog
      log("Verifica esistenza utente Hedgehog...");

      try {
        const result = await this.hedgehog.login(username, password);
        if (result) {
          // Se l'utente esiste già e il login ha successo, emmettiamo l'evento e restituiamo un successo
          const userPub = result.pub || "";

          log("Utente già esistente, login completato");

          this.eventEmitter.emit("auth:signup", {
            userPub,
            username,
            method: "password",
          });

          return { success: true, wallet: result, pub: userPub };
        }
      } catch (hedgehogError) {
        log("Utente non esistente su Hedgehog, procedo con la registrazione");
      }

      // Poi proviamo a creare l'utente GUN
      log("Creazione utente GUN...");
      let gunUser;
      let gunErrorCaught = false;
      try {
        const result = await this.gundb.createGunUser(username, password);
        log("Utente GUN creato con successo:", result);

        // Salva la chiave pubblica dell'utente
        await this.gundb.authenticateGunUser(username, password);

        const user = this.gun.user() as IGunUserInstance;
        let pub = user?.is?.epub;

        if (!pub) {
          throw new Error("Chiave pubblica non disponibile");
        }

        // Salva esplicitamente i dati dell'utente usando la chiave pubblica
        await new Promise((resolve, reject) => {
          this.gun
            .get("users")
            .get(pub) // Usa la chiave pubblica invece dello username
            .put(
              {
                username: username,
                epub: pub,
                created: Date.now(),
              },
              (ack) => {
                if ("err" in ack) reject(new Error(ack.err));
                else resolve(ack);
              }
            );
        });

        log("Dati utente salvati in GUN con chiave pubblica");
      } catch (gunError) {
        gunErrorCaught = true;
        if (
          gunError instanceof Error &&
          gunError.message.includes("User already created")
        ) {
          log("Utente GUN già esistente, tento autenticazione...");
          await this.gundb.authenticateGunUser(username, password);
          // Recupera la chiave pubblica
          const user = this.gun.user() as IGunUserInstance;
          const pub = user?.is?.epub;
          log("Autenticazione GUN con utente esistente completata");
        } else {
          throw gunError;
        }
      }

      log("Aggiornamento chiave pubblica...");
      await this.updateGunPublicKey();

      // Inizializza la struttura dei wallet paths
      log("Inizializzazione struttura wallet paths...");
      try {
        await Promise.race([
          new Promise((resolve, reject) => {
            const user = this.gun.user();
            if (!user.is) {
              reject(new Error("Utente Gun non autenticato"));
              return;
            }

            const userPub = user.is.epub;

            this.gun
              .get("WalletPaths")
              .get(userPub) // Usa la chiave pubblica invece dello username
              .set(
                {
                  paths: {},
                },
                (ack) => {
                  if ("err" in ack) {
                    console.error(
                      "Errore nell'inizializzazione wallet paths:",
                      ack.err
                    );
                    reject(new Error(ack.err));
                  } else {
                    log("Struttura wallet paths inizializzata con successo");
                    resolve(ack);
                  }
                }
              );
          }),

          new Promise((_, reject) =>
            setTimeout(
              () =>
                reject(new Error("Timeout nell'inizializzazione wallet paths")),
              5000
            )
          ),
        ]);
      } catch (e) {
        console.error("Errore durante l'inizializzazione dei wallet paths:", e);
        throw e;
      }

      // Registrazione o login con Hedgehog
      log("Registrazione utente Hedgehog...");
      let wallet;
      try {
        wallet = await this.hedgehog.signUp(username, password);
        log("Utente Hedgehog registrato con successo");
      } catch (hedgehogError) {
        if (
          hedgehogError instanceof Error &&
          hedgehogError.message.includes("User already created")
        ) {
          log("Utente Hedgehog già esistente, tentativo di login...");
          wallet = await this.hedgehog.login(username, password);
          log("Login Hedgehog con utente esistente completato");
        } else {
          throw hedgehogError;
        }
      }

      // Verifica finale e setup
      const user = this.gun.user();
      if (!user.is) {
        log("Riautenticazione GUN necessaria...");
        await this.gundb.authenticateGunUser(username, password);
      }

      // Aggiorna la chiave pubblica
      const userPub = user?.is?.epub || "";

      log("Aggiornamento chiave pubblica...");

      this.eventEmitter.emit("auth:signup", {
        userPub,
        username,
        method: "password",
      });

      return { success: true, wallet: wallet, pub: userPub };
    } catch (e: any) {
      console.error("Errore durante la registrazione:", e);
      // Cleanup in caso di errore
      try {
        this.gun.user()?.leave();
        sessionStorage.removeItem("gun-current-pair");
      } catch (cleanupError) {
        console.error("Errore durante il cleanup:", cleanupError);
      }
      this.eventEmitter.emit("error", {
        code: "AUTH_SIGNUP_ERROR",
        message: e.message || "Errore durante la registrazione",
        details: e,
      });
      return { success: false, error: e.message };
    }
  }

  /**
   * Effettua il login
   * @param {string} username - Nome utente
   * @param {string} password - Password
   * @returns {Promise<{wallet: Wallet, pub: string}>}
   */
  async login(
    username: string,
    password: string
  ): Promise<{ wallet: any; userpub: string }> {
    try {
      return new Promise((resolve, reject) => {
        try {
          this.authenticateWithHedgehog(username, password)
            .then((result) => {
              // Verifica se il risultato contiene un wallet
              if (!result || !result.wallet) {
                reject(
                  new Error("Autenticazione fallita: wallet non disponibile")
                );
                return;
              }

              const wallet = result.wallet;

              // Tenta di ottenere la chiave pubblica
              let userpub = this.gun.user().is?.pub;

              // Se la chiave pubblica non è disponibile, prova ad autenticare con GUN
              if (!userpub) {
                console.log(
                  "Chiave pubblica non disponibile, tentativo di autenticazione con GUN..."
                );

                // Tenta di autenticare con GUN
                this.authenticateWithGun(username, password)
                  .then((gunPub) => {
                    if (!gunPub) {
                      reject(
                        new Error(
                          "Impossibile ottenere la chiave pubblica dell'utente"
                        )
                      );
                      return;
                    }
                    resolve({ wallet, userpub: gunPub });
                  })
                  .catch((error) => {
                    console.error(
                      "Errore durante l'autenticazione con GUN:",
                      error
                    );
                    reject(error);
                  });
              } else {
                // Se la chiave pubblica è disponibile, risolvi la Promise
                resolve({ wallet, userpub });
              }
            })
            .catch((error) => {
              console.error(
                "Errore durante l'autenticazione con Hedgehog:",
                error
              );
              reject(error);
            });
        } catch (error) {
          console.error("Errore durante il login:", error);
          reject(error);
        }
      });
    } catch (error) {
      this.eventEmitter.emit("error", {
        code: "AUTH_LOGIN_ERROR",
        message:
          error instanceof Error ? error.message : "Errore durante il login",
        details: error,
      });
      throw error;
    }
  }

  /**
   * Effettua il logout
   */
  logout() {
    this.hedgehog.logout();
    this.gundb.logout();
    this.eventEmitter.emit("auth:logout");
  }

  /**
   * Verifica se l'utente è loggato
   * @returns {boolean}
   */
  isLoggedIn(): boolean {
    return this.hedgehog.isLoggedIn();
  }

  /**
   * Ottiene il wallet principale
   * @returns {Object} Wallet
   */
  getMainWallet(): Wallet {
    return this.hedgehog.getWallet();
  }

  /**
   * Deriva un wallet HD da un indice specifico
   * @param {string} userpub - Chiave pubblica dell'utente
   * @param {number} index - Indice di derivazione
   * @returns {Promise<Object>} Wallet derivato
   */
  async deriveWallet(
    userpub: any,
    index: any
  ): Promise<{
    wallet: HDNodeWallet;
    path: string;
    address: string;
    getAddressString: () => string;
    signMessage: (
      message: string | Uint8Array<ArrayBufferLike>
    ) => Promise<string>;
  }> {
    try {
      // Verifica che l'utente sia autenticato
      if (!this.hedgehog.isLoggedIn()) {
        throw new Error("Utente non autenticato");
      }

      // Ottieni il wallet principale
      const mainWallet = this.hedgehog.getWallet() as Wallet;
      if (!mainWallet) {
        throw new Error("Wallet principale non disponibile");
      }

      // Ottieni l'entropy dal localStorage
      const entropy = this.storage.getItem("hedgehog-entropy-key");
      if (!entropy) {
        // Se non troviamo l'entropy in localStorage, proviamo a ricavarla dal wallet
        if (!mainWallet.getPrivateKeyString()) {
          throw new Error(
            "Impossibile recuperare la chiave privata del wallet"
          );
        }

        // Usa la chiave privata come entropy
        const privateKey = mainWallet.getPrivateKeyString();
        // Se la chiave privata è un Uint8Array, convertila in hex

        this.storage.setItem("hedgehog-entropy-key", privateKey);
      }

      // Riprova a ottenere l'entropy
      const finalEntropy = this.storage.getItem(
        "hedgehog-entropy-key"
      ) as string;
      if (!finalEntropy) {
        throw new Error("Impossibile recuperare l'entropy");
      }

      // Crea HD wallet master
      const entropyBytes = new Uint8Array(
        finalEntropy.match(/.{1,2}/g)?.map((byte) => parseInt(byte, 16)) || []
      );
      const masterHDNode = ethers.HDNodeWallet.fromSeed(entropyBytes);

      // Deriva il wallet usando il path BIP44 standard per Ethereum
      const derivationPath = `m/44'/60'/0'/0/${index}`;
      const derivedWallet = masterHDNode.derivePath(derivationPath);

      // Gestione dei paths
      let currentPaths = [];
      try {
        currentPaths = (await this.getWalletPaths(userpub)) || [];
      } catch (e) {
        log("Nessun path esistente trovato, inizializzo nuovo array");
      }

      // Aggiungi il nuovo path solo se non esiste già
      if (!currentPaths.includes(derivationPath)) {
        currentPaths.push(derivationPath);

        // Salva i paths
        await this.saveWalletPaths(userpub, currentPaths);
      }

      // Restituisci il wallet con interfaccia consistente
      return {
        wallet: derivedWallet,
        path: derivationPath,
        address: derivedWallet.address,
        getAddressString: () => derivedWallet.address,
        signMessage: (message: string | Uint8Array<ArrayBufferLike>) =>
          derivedWallet.signMessage(message),
      };
    } catch (error) {
      console.error("Errore nella derivazione del wallet:", error);
      throw error;
    }
  }

  /**
   * Firma un messaggio
   * @param wallet - Wallet
   * @param message - Messaggio da firmare
   * @returns - Firma del messaggio
   */
  async signMessage(
    wallet: {
      signMessage: (arg0: any) => any;
      _privKey: string | ethers.SigningKey;
    },
    message: string | Uint8Array<ArrayBufferLike>
  ) {
    try {
      // Se il wallet è un'istanza di ethers.Wallet, usa direttamente il suo metodo
      if (wallet instanceof ethers.Wallet) {
        return wallet.signMessage(message);
      }

      // Altrimenti usa il metodo signMessage del wallet (mock o Hedgehog)
      if (typeof wallet.signMessage === "function") {
        return wallet.signMessage(message);
      }

      // Se il wallet ha una chiave privata, crea un wallet ethers e firma
      if (wallet._privKey) {
        const ethersWallet = new ethers.Wallet(wallet._privKey);
        return ethersWallet.signMessage(message);
      }

      throw new Error("Wallet non supporta la firma di messaggi");
    } catch (error) {
      console.error("Errore durante la firma del messaggio:", error);
      throw error;
    }
  }

  /**
   * Verifica una firma
   * @param message - Messaggio da verificare
   * @param signature - Firma da verificare
   * @returns - Risultato della verifica
   */
  verifySignature(
    message: string | Uint8Array<ArrayBufferLike>,
    signature: ethers.SignatureLike
  ) {
    return ethers.verifyMessage(message, signature);
  }

  /**
   * Salva i paths del wallet
   * @param userpub - Chiave pubblica dell'utente
   * @param paths - Paths da salvare
   */
  async saveWalletPaths(userpub: string, paths: any) {
    if (!userpub || !Array.isArray(paths)) {
      throw new Error("userpub e paths sono richiesti");
    }

    try {
      // Salva in localStorage per il mock
      this.storage.setItem(`walletPaths_${userpub}`, JSON.stringify(paths));

      // Se non siamo in modalità mock, salva in GunDB
      if (!Node) {
        await this.gundb.saveWalletPaths(userpub, paths);
      }
    } catch (error) {
      console.warn("Errore nel salvataggio dei paths:", error);
      throw error;
    }
  }

  /**
   * Recupera i paths del wallet
   * @param userpub - Chiave pubblica dell'utente
   * @returns - Paths del wallet
   */
  async getWalletPaths(userpub: string) {
    if (!userpub) throw new Error("userpub è richiesto");

    try {
      // Prima prova a recuperare da localStorage (per il mock)
      const storedPaths = this.storage.getItem(`walletPaths_${userpub}`);
      if (storedPaths) {
        try {
          return JSON.parse(storedPaths);
        } catch (e) {
          console.warn("Errore nel parsing dei paths da localStorage:", e);
        }
      }

      // Se non siamo in modalità mock e non ci sono paths in localStorage
      if (!Node) {
        try {
          return await this.gundb.getWalletPaths(userpub);
        } catch (e) {
          console.warn("Errore nel recupero paths da GunDB:", e);
          return [];
        }
      }

      return [];
    } catch (error) {
      console.warn("Errore nel recupero dei paths:", error);
      return [];
    }
  }

  /**
   * Carica i wallet esistenti
   * @returns {Promise<WalletInfo[]>} Array di wallet
   */
  async loadWallets(): Promise<WalletInfo[]> {
    try {
      const user = this.gun.user() as IGunUserInstance;
      const userpub = user?.is?.pub || "";

      // Recupera i wallet paths
      const data = await new Promise<any>((resolve) => {
        this.gun
          .get("WalletPaths")
          .get(userpub)
          .once((data: any) => {
            resolve(data);
          });
      });

      if (!data || !data.paths) {
        return [];
      }

      // Estrai i paths
      const paths = Object.entries(data.paths)
        .filter(([key]) => !key.startsWith("_") && key !== "#")
        .map(([_, value]) => value)
        .filter((path) => typeof path === "string");

      if (paths.length === 0) {
        return [];
      }

      // Recupera l'entropy
      const entropy = window.localStorage.getItem("hedgehog-entropy-key");
      if (!entropy) {
        throw new Error("Entropy non trovata");
      }

      // Converti l'entropy in bytes
      const entropyBytes = new Uint8Array(
        entropy.match(/.{1,2}/g)!.map((byte) => parseInt(byte, 16))
      );

      // Crea il master HD node
      const masterHDNode = ethers.HDNodeWallet.fromSeed(entropyBytes);

      // Deriva i wallet
      const wallets = paths
        .map((path: string) => {
          try {
            const derivedWallet = masterHDNode.derivePath(path);
            return {
              wallet: derivedWallet,
              path: path,
              getAddressString: () => derivedWallet.address,
              address: derivedWallet.address,
            };
          } catch (e) {
            console.error(`Errore nella derivazione del path ${path}:`, e);
            return null;
          }
        })
        .filter((w) => w !== null) as WalletInfo[];

      return wallets;
    } catch (e) {
      console.error("Errore nel caricamento dei wallet:", e);
      throw e;
    }
  }

  /**
   * Aggiorna la chiave pubblica GUN
   * @returns - Chiave pubblica GUN
   */
  async updateGunPublicKey(): Promise<string | null> {
    try {
      log("Tentativo di recupero chiave pubblica GUN...");

      // Verifica se l'utente è autenticato
      const user = this.gun.user() as IGunUserInstance;
      if (!user.is) {
        log("Utente GUN non autenticato, tentativo di recall sessione...");
        await new Promise<void>((resolve) => {
          user.recall({ sessionStorage: true }, () => {
            resolve();
          });
        });
      }

      if (user && user.is) {
        log("User GUN autenticato, recupero pair...");
        const pair = (user as any)._?.sea;

        if (pair && pair.epub) {
          log("Chiave pubblica GUN trovata:", pair.epub);

          // Salva le chiavi nella sessione
          if (!sessionStorage.getItem("gun-current-pair")) {
            sessionStorage.setItem("gun-current-pair", JSON.stringify(pair));
          }

          return pair.epub;
        } else {
          log("Pair o epub non trovati nel pair GUN");
          // Prova a recuperare le chiavi dalla sessione
          const savedPair = sessionStorage.getItem("gun-current-pair");
          if (savedPair) {
            const parsedPair = JSON.parse(savedPair);
            return parsedPair.epub;
          }
        }
      }

      return null;
    } catch (error) {
      console.error("Errore nel recupero della chiave pubblica Gun:", error);
      return null;
    }
  }

  /**
   * Verifica se WebAuthn è supportato
   * @returns - True se WebAuthn è supportato, altrimenti false
   */
  isWebAuthnSupported(): boolean {
    return window.PublicKeyCredential !== undefined;
  }

  // Metodo per la registrazione con WebAuthn
  async registerWithWebAuthn(username: string): Promise<{
    success: boolean;
    error?: string;
    userPub?: string;
    password?: string;
    credentialId?: string;
  }> {
    try {
      if (!this.isWebAuthnSupported()) {
        throw new Error("WebAuthn non è supportato in questo browser");
      }

      if (!this.webauthn) {
        throw new Error("WebAuthn non è inizializzato");
      }

      // Utilizziamo la funzione generateCredentials del modulo WebAuthn
      const result = await this.webauthn.generateCredentials(username);
      console.log("Risultato generazione credenziali WebAuthn:", result);

      if (!result.success || !result.password) {
        throw new Error(result.error || "Registrazione WebAuthn fallita");
      }

      this.gun.user().leave();

      const signUpResult = (await this.signUp(
        username,
        result.password
      )) as SignUpResult;

      return {
        success: true,
        userPub: signUpResult.pub,
        password: result.password,
        credentialId: result.credentialId,
      };
    } catch (error: any) {
      console.error("Errore nella registrazione con WebAuthn:", error);
      return {
        success: false,
        error: error.message || "Errore nella registrazione con WebAuthn",
      };
    }
  }

  async loginWithWebAuthn(username: string): Promise<{
    success: boolean;
    error?: string;
    userPub?: string;
    password?: string;
    credentialId?: string;
  }> {
    if (!this.isWebAuthnSupported()) {
      throw new Error("WebAuthn non è supportato in questo browser");
    }

    if (!this.webauthn) {
      throw new Error("WebAuthn non è inizializzato");
    }

    // Utilizziamo la funzione authenticateUser del modulo WebAuthn
    const result = await this.webauthn.authenticateUser(username);
    console.log("Risultato autenticazione WebAuthn:", result);

    if (!result.success || !result.password) {
      throw new Error(result.error || "Autenticazione WebAuthn fallita");
    }

    // Effettuiamo un logout prima di autenticare per evitare problemi
    this.gun.user().leave();

    const loginResult = await this.login(username, result.password);

    return {
      success: true,
      userPub: loginResult.userpub,
      password: result.password,
      credentialId: result.credentialId,
    };
  }

  /**
   * Ottiene i dispositivi WebAuthn registrati
   * @param username - Nome utente
   * @returns - Dispositivi registrati
   */
  async getWebAuthnDevices(username: string): Promise<any[]> {
    try {
      // Qui dovresti implementare la logica per recuperare i dispositivi registrati
      // Questo è solo un esempio e dovrebbe essere adattato alla tua implementazione
      return [];
    } catch (error) {
      console.error("Errore nel recupero dei dispositivi WebAuthn:", error);
      return [];
    }
  }

  // Metodo per il login con MetaMask
  async loginWithMetaMask(address: string): Promise<AuthResult> {
    try {
      if (!this.metamask) {
        return this.createAuthResult(false, {
          error: "MetaMask non è inizializzato",
        });
      }

      // Verifica se Gun DB è inizializzato
      if (!this.gundb || !this.gundb.gun) {
        console.error("Gun DB non è inizializzato");
        return this.createAuthResult(false, {
          error: "Gun DB non è inizializzato",
        });
      }

      log("Tentativo di login con MetaMask, indirizzo:", address);

      // Genera le credenziali (include già la verifica dell'utente e la firma)
      const credentials = await this.metamask.generateCredentials(address);

      try {
        const result = await this.login(
          credentials.username,
          credentials.password
        );

        log("Login con MetaMask completato con successo");
        return this.createAuthResult(true, {
          userPub: result.userpub,
          username: credentials.username,
          password: credentials.password,
          wallet: result.wallet,
        });
      } catch (authError) {
        log("Errore durante l'autenticazione:", authError);
        return this.createAuthResult(false, {
          error: "Errore nell'autenticazione: " + (authError as Error).message,
        });
      }
    } catch (error: any) {
      log("Errore nel login con MetaMask:", error);
      return this.createAuthResult(false, {
        error: error.message || "Errore nel login con MetaMask",
      });
    }
  }

  async signUpWithMetaMask(address: string): Promise<AuthResult> {
    try {
      if (!this.metamask) {
        console.error("MetaMask non è inizializzato");
        return this.createAuthResult(false, {
          error: "MetaMask non è inizializzato",
        });
      }

      // Verifica se Gun DB è inizializzato
      if (!this.gundb || !this.gundb.gun) {
        console.error("Gun DB non è inizializzato");
        return this.createAuthResult(false, {
          error: "Gun DB non è inizializzato",
        });
      }

      // Prima verifichiamo se l'utente esiste già
      const metamaskUsername = address.toLocaleLowerCase();
      console.log("Verifica esistenza utente:", metamaskUsername);

      // Check if gun is on
      this.checkGun();

      // Utilizziamo una promessa che si risolve sempre, anche in caso di errore o mancanza di dati
      const userExists = await new Promise<boolean>((resolve) => {
        let isResolved = false;

        // Utilizziamo sia 'once' che un controllo manuale per assicurarci che la promessa si risolva
        this.gun
          .get("Users")
          .get(metamaskUsername)
          .once((data: any) => {
            if (!isResolved) {
              console.log(
                "Risposta Gun per verifica utente:",
                data ? "Utente trovato" : "Utente non trovato"
              );
              isResolved = true;
              resolve(!!data);
            }
          });

        // Impostiamo un timeout per assicurarci che la promessa si risolva
        setTimeout(() => {
          if (!isResolved) {
            console.log("Timeout verifica utente, assumiamo che non esista");
            isResolved = true;
            resolve(false);
          }
        }, 5000); // 5 secondi di timeout
      });

      // Se l'utente esiste già, proviamo a fare login
      if (userExists) {
        console.log("Utente già esistente, tentativo di login...");
        return await this.loginWithMetaMask(address);
      }

      console.log(
        "Tentativo di registrazione con MetaMask, indirizzo:",
        address
      );

      // Generate credentials
      const { username, password, nonce, timestamp, messageToSign } =
        await this.metamask.generateCredentials(address);

      const result = (await this.signUp(username, password)) as SignUpResult;

      return this.createAuthResult(true, {
        userPub: address,
        password: password,
        username: username,
        wallet: result.wallet,
        error: undefined,
      });
    } catch (error: any) {
      console.error("Errore nella registrazione con MetaMask:", error);
      return this.createAuthResult(false, {
        error: error.message || "Errore nella registrazione con MetaMask",
      });
    }
  }

  /**
   * Crea un nuovo wallet
   * @returns {Promise<WalletInfo>} Informazioni sul nuovo wallet
   */
  async createWallet(): Promise<WalletInfo> {
    try {
      // Usa this.hedgehog invece di super
      const wallet = await this.hedgehog.createWallet();

      this.eventEmitter.emit("wallet:created", {
        address: wallet.address,
        path: wallet.path,
      });

      return wallet;
    } catch (error) {
      this.eventEmitter.emit("error", {
        code: "WALLET_CREATE_ERROR",
        message:
          error instanceof Error
            ? error.message
            : "Errore durante la creazione del wallet",
        details: error,
      });
      throw error;
    }
  }

  /**
   * Gestisce il login di un utente
   * @param {string} username - Nome utente
   * @param {string} password - Password
   * @param {Object} options - Opzioni
   * @returns {Promise<Object>} Risultato dell'operazione
   */
  async handleLogin(
    username: string,
    password: string,
    {
      setUserpub,
      setSignedIn,
    }: { setUserpub?: Function; setSignedIn?: Function }
  ): Promise<AuthResult> {
    try {
      const { wallet, userpub } = await this.login(username, password);

      if (setUserpub) setUserpub(userpub);
      if (setSignedIn) setSignedIn(true);

      return this.createAuthResult(true, {
        userPub: userpub,
        password,
        wallet,
      });
    } catch (error) {
      return this.createAuthResult(false, {
        error:
          error instanceof Error ? error.message : "Errore durante il login",
      });
    }
  }

  /**
   * Gestisce la registrazione di un nuovo utente
   * @param {string} username - Nome utente
   * @param {string} password - Password
   * @param {string} passwordConfirmation - Conferma password
   * @param {Object} options - Opzioni
   * @returns {Promise<Object>} Risultato dell'operazione
   */
  async handleSignUp(
    username: string,
    password: string,
    passwordConfirmation: string,
    {
      setErrorMessage,
      setUserpub,
      setSignedIn,
      messages = {},
    }: {
      setErrorMessage?: Function;
      setUserpub?: Function;
      setSignedIn?: Function;
      messages?: { [key: string]: string };
    }
  ): Promise<AuthResult> {
    try {
      // Validazione password
      if (password !== passwordConfirmation) {
        const error = messages.passwordMismatch || "Le password non coincidono";
        if (setErrorMessage) setErrorMessage(error);

        this.eventEmitter.emit("error", {
          code: "PASSWORD_MISMATCH",
          message: error,
        });

        return this.createAuthResult(false, { error });
      }

      const result = (await this.signUp(username, password)) as SignUpResult;

      if (!result.success || result.error) {
        if (setErrorMessage) setErrorMessage(result.error);
        return this.createAuthResult(false, { error: result.error });
      }

      if (setUserpub && result.pub) setUserpub(result.pub);
      if (setSignedIn) setSignedIn(true);

      // Emettiamo l'evento di successo
      this.eventEmitter.emit("auth:signup", {
        userPub: result.pub || "",
        username,
        method: "password",
      });

      return this.createAuthResult(true, {
        userPub: result.pub,
        password,
        wallet: result.wallet,
        username,
      });
    } catch (error) {
      const errorMessage =
        error instanceof Error
          ? error.message
          : "Errore durante la registrazione";
      if (setErrorMessage) setErrorMessage(errorMessage);

      this.eventEmitter.emit("error", {
        code: "SIGNUP_ERROR",
        message: errorMessage,
        details: error,
      });

      return this.createAuthResult(false, { error: errorMessage });
    }
  }

  /**
   * Inizializza la struttura dei wallet paths
   * @param {string} userPub - Chiave pubblica dell'utente
   * @private
   */
  private async initializeWalletPaths(userPub: string): Promise<void> {
    try {
      log("Inizializzazione wallet paths per l'utente:", userPub);

      // Verifichiamo che l'utente sia autenticato
      const user = this.gun.user();
      if (!user.is) {
        console.warn(
          "Utente non autenticato durante l'inizializzazione wallet paths"
        );
        // Tentiamo di riautenticare usando la sessione
        await new Promise<void>((resolve) => {
          user.recall({ sessionStorage: true }, () => resolve());
        });
      }

      // Approccio alternativo: utilizziamo set invece di put
      // che è più affidabile per strutture di dati semplici
      return await new Promise<void>((resolve, reject) => {
        log("Scrittura wallet paths in GunDB con metodo alternativo...");

        // Usiamo setTimeout invece di Promise.race per gestire meglio il timeout
        const timeoutId = setTimeout(() => {
          console.warn("Timeout scaduto, ma continuiamo l'esecuzione");
          // Invece di fallire, consideriamo l'operazione come completata
          // anche se potrebbe non essere stata salvata completamente
          resolve();
        }, 10000);

        // Prima controlliamo se esiste già
        this.gun
          .get("WalletPaths")
          .get(userPub)
          .once((data) => {
            // Se i dati esistono già, non c'è bisogno di reinizializzare
            if (data && data.initialized) {
              log("Wallet paths già inizializzati", data);
              clearTimeout(timeoutId);
              resolve();
              return;
            }

            // Altrimenti creiamo una nuova entry
            const pathNode = this.gun.get("WalletPaths").get(userPub);

            // Utilizziamo un doppio set invece di put per avere maggiori probabilità di successo
            pathNode.get("paths").set({}, (ack1) => {
              pathNode.get("initialized").put(true, (ack2) => {
                log("Wallet paths inizializzati con metodo alternativo");
                clearTimeout(timeoutId);
                resolve();
              });
            });
          });
      });
    } catch (error) {
      console.error("Errore nell'inizializzazione wallet paths:", error);
      // Catturiamo l'errore ma non lo propaghiamo, permettendo all'applicazione di continuare
      return Promise.resolve();
    }
  }

  // Metodi privati di utilità
  private async authenticateWithHedgehog(
    username: string,
    password: string
  ): Promise<any> {
    log("Autenticazione con Hedgehog...");
    try {
      const wallet = await this.hedgehog.login(username, password);
      log("Login Hedgehog completato con successo");
      return { success: true, wallet };
    } catch (error) {
      log("Errore login Hedgehog:", error);
      throw error;
    }
  }

  private async authenticateWithGun(
    username: string,
    password: string
  ): Promise<string> {
    log("Autenticazione con GUN...");
    try {
      await this.gundb.authenticateGunUser(username, password);
      const user = this.gun.user();
      if (!user.is?.pub) {
        throw new Error("Chiave pubblica GUN non disponibile");
      }
      return user.is.pub;
    } catch (error) {
      log("Errore autenticazione GUN:", error);
      throw error;
    }
  }

  private async initializeUserData(
    username: string,
    password: string,
    userPub: string
  ): Promise<void> {
    log("Inizializzazione dati utente...");
    try {
      await new Promise((resolve, reject) => {
        this.gun
          .get("users")
          .get(userPub)
          .put(
            {
              username: username,
              epub: userPub,
              created: Date.now(),
            },
            (ack) => {
              if ("err" in ack) reject(new Error(ack.err));
              else resolve(ack);
            }
          );
      });

      await this.initializeWalletPaths(userPub);
    } catch (error) {
      log("Errore inizializzazione dati utente:", error);
      throw error;
    }
  }

  // Metodi per la gestione degli eventi
  public on<K extends keyof ShogunEvents>(
    event: K,
    listener: ShogunEvents[K]
  ): void {
    this.eventEmitter.on(event, listener);
  }

  public off<K extends keyof ShogunEvents>(
    event: K,
    listener: ShogunEvents[K]
  ): void {
    this.eventEmitter.off(event, listener);
  }
}

// Esporta per entrambi Node.js e browser
if (typeof window !== "undefined") {
  (window as any).ShogunSDK = ShogunSDK;
  (window as any).Webauthn = Webauthn;
  (window as any).MetaMask = MetaMask;
  (window as any).Stealth = Stealth;
} else if (typeof global !== "undefined") {
  (global as any).ShogunSDK = ShogunSDK;
  (global as any).Webauthn = Webauthn;
  (global as any).MetaMask = MetaMask;
  (global as any).Stealth = Stealth;
}

export { IShogunSDK, ShogunSDKConfig, WalletInfo, AuthResult, SignUpResult };

// export sdk
export default ShogunSDK;
