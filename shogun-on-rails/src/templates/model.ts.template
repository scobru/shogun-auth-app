import { setSignal } from '../../shogun-nodom/nodom.js';

export class ${ModelName} {
  static gunInstance = null;
  static tableName = '${modelNameLower}s';

  constructor(data = {}) {
    Object.assign(this, data);
  }

  static setGunInstance(gun) {
    this.gunInstance = gun;
  }

  static async findAll() {
    if (!this.gunInstance) throw new Error('Gun instance not set.');
    return new Promise(resolve => {
      const items = [];
      this.gunInstance.get(this.tableName).map().once((data, id) => {
        if (data) items.push(new ${ModelName}({ ...data, id }));
      });
      setTimeout(() => resolve(items), 100);
    });
  }

  static async findById(id) {
    if (!this.gunInstance) throw new Error('Gun instance not set.');
    return new Promise(resolve => {
      this.gunInstance.get(this.tableName).get(id).once(data => {
        resolve(data ? new ${ModelName}({ ...data, id }) : null);
      });
    });
  }

  async save() {
    if (!${ModelName}.gunInstance) throw new Error('Gun instance not set.');
    const node = ${ModelName}.gunInstance.get(${ModelName}.tableName);
    const data = { ...this };
    
    // Non salvare l'ID nel dato poiché è già la chiave
    delete data.id;
    
    return new Promise((resolve, reject) => {
      if (this.id) {
        // Update esistente
        node.get(this.id).put(data, (ack) => {
          if (ack.err) reject(ack.err);
          else resolve(this);
        });
      } else {
        // Crea nuovo
        node.set(data, (ack) => {
          if (ack.err) reject(ack.err);
          else {
            if (ack.ref) {
              this.id = ack.ref.toString().split('/').pop();
            }
            resolve(this);
          }
        });
      }
    });
  }

  async delete() {
    if (!${ModelName}.gunInstance) throw new Error('Gun instance not set.');
    if (!this.id) throw new Error('Cannot delete without id.');
    return new Promise((resolve, reject) => {
      ${ModelName}.gunInstance.get(${ModelName}.tableName).get(this.id).put(null, ack => {
        if (ack.err) reject(ack.err);
        else resolve(true);
      });
    });
  }

  // Relationship methods
  async addRelation(relationName, relatedModel) {
    if (!${ModelName}.gunInstance) {
      throw new Error('Gun instance not set.');
    }

    if (!this.id) {
      throw new Error('Cannot add relation to an unsaved item. Save the item first.');
    }

    if (!relatedModel.id) {
      throw new Error('Cannot add relation to an unsaved item. Save the related model first.');
    }

    return new Promise((resolve, reject) => {
      // Create a relation node if it doesn't exist
      if (!this[relationName]) {
        this[relationName] = {};
      }

      // Add the relation by ID
      const relationData = { ...this[relationName] };
      relationData[relatedModel.id] = true;
      this[relationName] = relationData;

      // Save the updated relations
      ${ModelName}.gunInstance.get(${ModelName}.tableName).get(this.id).put(this, (ack) => {
        if (ack.err) {
          reject(ack.err);
        } else {
          resolve();
        }
      });
    });
  }

  async getRelated(relationName, RelatedModel) {
    if (!${ModelName}.gunInstance) {
      throw new Error('Gun instance not set.');
    }

    if (!this.id) {
      throw new Error('Cannot get relations from an unsaved item.');
    }

    if (!this[relationName]) {
      return [];
    }

    return new Promise((resolve, reject) => {
      const items = [];
      const relationIds = Object.keys(this[relationName]);
      
      if (relationIds.length === 0) {
        resolve(items);
        return;
      }

      let loaded = 0;
      relationIds.forEach(id => {
        // Only process valid relation entries
        if (this[relationName][id] === true) {
          RelatedModel.findById(id).then(item => {
            if (item) {
              items.push(item);
            }
            loaded++;
            if (loaded === relationIds.length) {
              resolve(items);
            }
          });
        } else {
          loaded++;
          if (loaded === relationIds.length) {
            resolve(items);
          }
        }
      });
    });
  }

  async removeRelation(relationName, relatedModel) {
    if (!${ModelName}.gunInstance) {
      throw new Error('Gun instance not set.');
    }

    if (!this.id || !relatedModel.id) {
      throw new Error('Cannot remove relation from an unsaved item.');
    }

    if (!this[relationName]) {
      return;
    }

    return new Promise((resolve, reject) => {
      // Remove the relation by ID
      const relationData = { ...this[relationName] };
      delete relationData[relatedModel.id];
      this[relationName] = relationData;

      // Save the updated relations
      ${ModelName}.gunInstance.get(${ModelName}.tableName).get(this.id).put(this, (ack) => {
        if (ack.err) {
          reject(ack.err);
        } else {
          resolve();
        }
      });
    });
  }

  static register() {
    // Registra i metodi di relazione sul prototipo della classe
    console.log(`${ModelName} model registered`);
  }
}

// Inizializza il modello
${ModelName}.register();

// Esempio di definizione di relazioni:
/*
// Relazione uno-a-molti (hasMany)
${ModelName}.hasMany = function(modelName, options = {}) {
  console.log(`${ModelName} has many ${modelName}`);
};

// Relazione uno-a-uno (hasOne)
${ModelName}.hasOne = function(modelName, options = {}) {
  console.log(`${ModelName} has one ${modelName}`);
};

// Relazione di appartenenza (belongsTo)
${ModelName}.belongsTo = function(modelName, options = {}) {
  console.log(`${ModelName} belongs to ${modelName}`);
};
*/ 