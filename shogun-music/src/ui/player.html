<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Shogun Music Player</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">

    <!-- Caricamento scripts esterni -->
    <script src="../js/shogun-core.js"></script>
    <script src="../js/api.js"></script>
    <script src="../js/playlist-manager.js"></script>
    <script src="../js/app.js"></script>
    <script src="../js/player.js"></script>
    <script src="../js/playlist-display.js"></script>

    <!-- Caricamento dinamico degli script (solo se necessario come fallback) -->
    <script type="text/javascript">
      // Global flags to prevent duplicate loading
      window.SHOGUN_SCRIPTS = {
        shogunCoreLoaded: false,
        wavesurferLoaded: false,
        playerLoaded: false,
        loadingInProgress: false
      };
      
      // INIZIO inizializzazione base percorso e script
      //document.addEventListener("DOMContentLoaded", function() {
      function initializeScriptLoaders() {
        console.log("Avvio caricamento degli script con rilevamento automatico del percorso");
        
        // Funzione per rilevare il percorso base dell'applicazione
        function detectBasePath() {
          // Se window.shogun è già disponibile, non facciamo nulla
          if (window.shogun) {
            console.log("Shogun Core già caricato");
            return '';
          }
          
          // Tenta di rilevare automaticamente il percorso base
          const currentPath = window.location.pathname;
          
          // Rileva ambiente basato sul percorso o sull'URL
          if (currentPath.includes('/shogun-music/') || 
              window.location.hostname === 'localhost' && 
              window.location.port === '3000') {
            console.log("Percorso base rilevato: /shogun-music");
            return '/shogun-music';
          } 
          else if (currentPath.includes('/shogun-core/')) {
            console.log("Percorso base rilevato: /shogun-core");
            return '/shogun-core';
          }
          else {
            console.log("Nessun percorso speciale rilevato, usando percorso relativo ..");
            return '..';
          }
        }
        
        // Rileva il percorso base
        const basePath = detectBasePath();
        
        // Funzione per creare e appender script dinamicamente
        function loadScript(src, callback) {
          // Controlla se lo script è già stato caricato
          const existingScripts = document.querySelectorAll(`script[src="${src}"]`);
          if (existingScripts.length > 0) {
            console.log(`Script ${src} già caricato, non lo carico di nuovo`);
            if (callback) callback(true);
            return;
          }

          // Controlla se siamo già nel processo di caricamento
          const scriptName = src.split('/').pop();
          if (scriptName === 'shogun-core.js' && (window.SHOGUN_SCRIPTS.shogunCoreLoaded || window.SHOGUN_SCRIPTS.loadingInProgress)) {
            console.log(`Shogun Core già caricato o in caricamento`);
            if (callback) callback(true);
            return;
          }
          
          if (scriptName.includes('wavesurfer') && window.SHOGUN_SCRIPTS.wavesurferLoaded) {
            console.log(`WaveSurfer già caricato`);
            if (callback) callback(true);
            return;
          }
          
          if (scriptName === 'player.js' && window.SHOGUN_SCRIPTS.playerLoaded) {
            console.log(`Player già caricato`);
            if (callback) callback(true);
            return;
          }
          
          // Imposta flag di caricamento in corso
          if (scriptName === 'shogun-core.js') {
            window.SHOGUN_SCRIPTS.loadingInProgress = true;
          }

          console.log(`Tentativo di caricamento da: ${src}`);
          const script = document.createElement('script');
          script.type = 'text/javascript';
          script.src = src;
          
          // Gestisci sia successo che errore
          script.onload = function() {
            console.log(`${src.split('/').pop()} caricato con successo da ${src}`);
            
            // Aggiorna i flag di caricamento
            if (scriptName === 'shogun-core.js') {
              window.SHOGUN_SCRIPTS.shogunCoreLoaded = true;
              window.SHOGUN_SCRIPTS.loadingInProgress = false;
            } else if (scriptName.includes('wavesurfer')) {
              window.SHOGUN_SCRIPTS.wavesurferLoaded = true;
            } else if (scriptName === 'player.js') {
              window.SHOGUN_SCRIPTS.playerLoaded = true;
            }
            
            if (callback) callback(true);
          };
          
          script.onerror = function() {
            console.error(`Errore nel caricamento di ${src}`);
            
            // Resetta flag di caricamento in caso di errore
            if (scriptName === 'shogun-core.js') {
              window.SHOGUN_SCRIPTS.loadingInProgress = false;
            }
            
            if (callback) callback(false);
          };
          
          document.head.appendChild(script);
        }
        
        // Funzione per tentare percorsi alternativi quando il caricamento dello script principale fallisce
        function tryLoadAlternatives(paths, index) {
          if (index >= paths.length) {
            console.error("Impossibile caricare lo script da nessun percorso alternativo");
            showErrorBanner("Errore di caricamento script. Ricarica la pagina o contatta il supporto.");
            return;
          }
          
          const altPath = paths[index];
          console.log(`Tentativo percorso alternativo (${index + 1}/${paths.length}): ${altPath}`);
          
          loadScript(altPath, function(success) {
            if (success) {
              console.log(`Script caricato con successo dal percorso alternativo: ${altPath}`);
            } else {
              console.warn(`Fallito caricamento da percorso ${altPath}, provo il prossimo...`);
              tryLoadAlternatives(paths, index + 1);
            }
          });
        }
      
        // Strategia di caricamento degli script necessari
        
        // 1. Carica shogun-core.js
        function loadShogunCore() {
          // Se Shogun è già caricato, non fare nulla
          if (window.shogun) {
            console.log("Shogun Core già caricato");
            checkShogunLoaded(1);
            return;
          }

          // Definisci tutti i percorsi possibili per shogun-core.js
          const possiblePaths = [
            `${basePath}/js/shogun-core.js`,       // Percorso basato sul rilevamento automatico
            "/shogun-music/js/shogun-core.js",     // Percorso assoluto 1
            "/js/shogun-core.js",                  // Percorso assoluto 2
            "js/shogun-core.js",                   // Percorso relativo alla root
            "../js/shogun-core.js",                // Percorso relativo alla cartella ui
            "./js/shogun-core.js",                 // Percorso alternativo
            "https://cdn.example.com/shogun-core.js" // CDN di fallback (sostituire con CDN reale se disponibile)
          ];
          
          // Usa il percorso principale rilevato
          console.log(`Tentativo di caricamento Shogun Core da: ${possiblePaths[0]}`);
          
          loadScript(possiblePaths[0], function(success) {
            if (success) {
              checkShogunLoaded(1);
            } else {
              console.error("Caricamento principale di shogun-core.js fallito, tento percorsi alternativi...");
              // Passa all'indice 1 (secondo elemento dell'array) per tentare il primo percorso alternativo
              tryLoadAlternatives(possiblePaths, 1);
            }
          });
        }
        
        // 2. Carica WaveSurfer per la visualizzazione audio
        function loadWaveSurfer() {
          // Se WaveSurfer è già disponibile, non fare nulla
          if (typeof WaveSurfer !== 'undefined') {
            console.log("WaveSurfer già caricato");
            return;
          }

          console.log("Caricamento WaveSurfer...");
          
          // Carica direttamente dal CDN principale, più affidabile
          const cdnPath = 'https://cdnjs.cloudflare.com/ajax/libs/wavesurfer.js/2.0.4/wavesurfer.min.js';
          loadScript(cdnPath, function(success) {
            if (success) {
              console.log("WaveSurfer caricato dal CDN principale");
            } else {
              // Fallback con CDN alternativo
              console.warn("Fallimento CDN principale, provo CDN alternativo");
              const alternativeCdnPath = 'https://unpkg.com/wavesurfer.js@2.0.4/dist/wavesurfer.min.js';
              loadScript(alternativeCdnPath, function(success) {
                if (success) {
                  console.log("WaveSurfer caricato dal CDN alternativo");
                } else {
                  console.error("Tutti i tentativi di caricamento di WaveSurfer falliti");
                  showErrorBanner("Impossibile caricare WaveSurfer per la visualizzazione audio");
                }
              });
            }
          });
        }
        
        // 3. Carica player.js per la gestione dei preferiti
        function loadPlayerJS() {
          console.log("Caricamento moduli API e Player con base path: " + basePath);
          
          // Verifica se WaveSurfer è già stato caricato
          if (typeof WaveSurfer !== 'undefined') {
            console.log("WaveSurfer già caricato");
          } else {
            // Se non è già caricato, caricalo
            loadWaveSurfer();
          }
          
          // Carica app.js che contiene la funzione loadTracks
          const appScript = document.createElement('script');
          appScript.type = 'text/javascript';
          appScript.src = `${basePath}/js/app.js`;
          
          appScript.onerror = function() {
            console.error("Errore nel caricamento del modulo App");
            showErrorBanner("Impossibile caricare il sistema App");
          };
          
          appScript.onload = function() {
            console.log("App.js caricato con successo");
          };
          
          document.head.appendChild(appScript);
          
          // Carica prima API.js come modulo
          const apiScript = document.createElement('script');
          apiScript.type = 'module';
          apiScript.src = `${basePath}/js/api.js`;
          
          // Gestisci errori di caricamento API
          apiScript.onerror = function() {
            console.error("Errore nel caricamento del modulo API");
            showErrorBanner("Impossibile caricare il sistema API");
          };
          
          // Dopo che API è caricato, carica player.js
          apiScript.onload = function() {
            console.log("API.js caricato come modulo");
            
            // Ora carica player.js come modulo
            const playerScript = document.createElement('script');
            playerScript.type = 'module';
            playerScript.src = `${basePath}/js/player.js`;
            
            playerScript.onerror = function() {
              console.error("Errore nel caricamento del modulo Player");
              showErrorBanner("Impossibile caricare il sistema Player");
            };
            
            playerScript.onload = function() {
              console.log("Player.js caricato come modulo");
              
              // Verifica dopo un breve ritardo che FavoritesManager sia disponibile
              setTimeout(function() {
                if (!window.FavoritesManager) {
                  console.error("FavoritesManager non disponibile dopo il caricamento");
                  showErrorBanner("Si è verificato un errore nell'inizializzazione del sistema dei preferiti. Ricarica la pagina o contatta il supporto se il problema persiste.");
                }
              }, 1000);
            };
            
            document.head.appendChild(playerScript);
          };
          
          document.head.appendChild(apiScript);
        }
        
        // Funzione per verificare se Shogun è stato caricato correttamente
        function checkShogunLoaded(attempt) {
          if (attempt > 5) {
            console.error("Numero massimo di tentativi per Shogun Core raggiunto");
            
            // Se arriviamo qui, potrebbero esserci problemi con lo script caricato
            // Possiamo tentare un ultimo approccio disperato: ricaricare lo script
            if (!window.shogun) {
              console.warn("Tentativo di ricaricamento completo dopo 5 tentativi falliti...");
              
              // Rimuovi qualsiasi script esistente per evitare conflitti
              document.querySelectorAll('script[src*="shogun-core.js"]').forEach(oldScript => {
                oldScript.parentNode.removeChild(oldScript);
              });
              
              // Resetta i flag di caricamento
              window.SHOGUN_SCRIPTS.shogunCoreLoaded = false;
              window.SHOGUN_SCRIPTS.loadingInProgress = false;
              
              // Riprova con un percorso diverso
              const emergencyPath = "/js/shogun-core.js"; // Percorso di emergenza
              console.log("Tentativo di emergenza con percorso:", emergencyPath);
              
              const script = document.createElement('script');
              script.type = 'text/javascript';
              script.src = emergencyPath;
              script.onload = function() {
                console.log("Caricamento di emergenza completato, verifico disponibilità...");
                setTimeout(function() {
                  if (window.shogun) {
                    console.log("Shogun Core caricato con successo tramite approccio di emergenza");
                    loadPlayerJS();
                  } else {
                    console.error("Fallito anche l'approccio di emergenza");
                    showErrorBanner("Impossibile caricare Shogun Core. Ricarica la pagina o controlla la connessione.");
                  }
                }, 1000);
              };
              script.onerror = function() {
                console.error("Fallito anche il caricamento di emergenza");
                showErrorBanner("Impossibile caricare Shogun Core. Ricarica la pagina o controlla la connessione.");
              };
              document.head.appendChild(script);
            }
            return;
          }
          
          console.log(`Verifica caricamento Shogun Core (tentativo ${attempt}/5)...`);
          
          if (window.shogun) {
            console.log("Shogun Core caricato correttamente:", window.shogun);
            // Inizializza funzionalità che dipendono da Shogun
            loadPlayerJS();
          } else {
            // Riprova dopo 1 secondo
            setTimeout(function() {
              checkShogunLoaded(attempt + 1);
            }, 1000);
          }
        }
        
        // Funzione per mostrare un banner di errore
        function showErrorBanner(message) {
          const errorBanner = document.createElement('div');
          errorBanner.style.position = 'fixed';
          errorBanner.style.top = '0';
          errorBanner.style.left = '0';
          errorBanner.style.right = '0';
          errorBanner.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
          errorBanner.style.color = 'white';
          errorBanner.style.padding = '10px';
          errorBanner.style.textAlign = 'center';
          errorBanner.style.zIndex = '9999';
          errorBanner.innerHTML = `
            <strong>Errore:</strong> ${message}
            <button onclick="location.reload()" style="margin-left: 10px; padding: 2px 8px;">Ricarica</button>
          `;
          document.body.appendChild(errorBanner);
        }
        
        // Avvia il caricamento degli script
        loadShogunCore();
        loadWaveSurfer();
      }
      
      // Avvia il caricamento degli script 
      initializeScriptLoaders();
      //});

      // INIZIO codice principale
      
      // Inizializzazione dell'interfaccia
    </script>
    
    <!-- Verifica caricamento di Shogun Core -->
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        // Verifica che Shogun Core sia caricato
        let attempts = 0;
        const maxAttempts = 5;
        
        function checkShogunStatus() {
          attempts++;
          console.log(`Verifica caricamento Shogun Core (tentativo ${attempts}/${maxAttempts})...`);
          
          if (typeof window.shogun === "undefined" || !window.shogun.gun) {
            if (attempts < maxAttempts) {
              console.warn(`Shogun Core non ancora disponibile, nuovo tentativo tra ${attempts * 500}ms...`);
              setTimeout(checkShogunStatus, attempts * 500);
            } else {
              console.error("Shogun Core non è stato caricato correttamente dopo multipli tentativi.");
              
              // Controlla se lo script è stato caricato
              const scriptElement = document.querySelector('script[src*="shogun-core.js"]');
              let errorReason = "Motivo sconosciuto";
              
              if (!scriptElement) {
                errorReason = "Script non trovato nel DOM";
              } else if (scriptElement.onerror) {
                errorReason = "Errore di caricamento dello script";
              } else {
                errorReason = "Script caricato ma oggetto shogun non inizializzato";
              }
              
              // Messaggio di errore
              const errorMsg = document.createElement("div");
              errorMsg.id = "shogun-error-banner";
              errorMsg.style.position = "fixed";
              errorMsg.style.top = "10px";
              errorMsg.style.left = "50%";
              errorMsg.style.transform = "translateX(-50%)";
              errorMsg.style.padding = "10px 20px";
              errorMsg.style.backgroundColor = "#e22134";
              errorMsg.style.color = "#ffffff";
              errorMsg.style.borderRadius = "4px";
              errorMsg.style.zIndex = "9999";
              errorMsg.textContent = `Impossibile caricare Shogun Core: ${errorReason}. Ricarica la pagina.`;
              
              // Aggiungi pulsante per ricaricare
              const reloadBtn = document.createElement("button");
              reloadBtn.textContent = "Ricarica";
              reloadBtn.style.marginLeft = "10px";
              reloadBtn.style.backgroundColor = "#ffffff";
              reloadBtn.style.color = "#e22134";
              reloadBtn.onclick = function() { location.reload(); };
              errorMsg.appendChild(reloadBtn);
              
              // Aggiungi pulsante per caricare manualmente
              const reloadScriptBtn = document.createElement("button");
              reloadScriptBtn.textContent = "Carica manualmente";
              reloadScriptBtn.style.marginLeft = "10px";
              reloadScriptBtn.style.backgroundColor = "#ffffff";
              reloadScriptBtn.style.color = "#333";
              reloadScriptBtn.onclick = function() { 
                const newScript = document.createElement("script");
                newScript.src = "../js/shogun-core.js";
                newScript.type = "text/javascript";
                document.head.appendChild(newScript);
                setTimeout(checkShogunStatus, 1000);
              };
              errorMsg.appendChild(reloadScriptBtn);
              
              document.body.appendChild(errorMsg);
            }
          } else {
            console.log("Shogun Core caricato correttamente:", window.shogun);
            // Rimuovi il banner di errore se esiste
            const errorBanner = document.getElementById("shogun-error-banner");
            if (errorBanner) {
              errorBanner.remove();
            }
          }
        }
        
        // Primo controllo dopo 1 secondo
        setTimeout(checkShogunStatus, 1000);
      });
    </script>

    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        margin: 0;
        padding: 0;
        color: #eaeaea;
        background-color: #121212;
        display: flex;
        height: 100vh;
        overflow: hidden;
      }
      h1,
      h2,
      h3 {
        color: #ffffff;
      }
      /* Layout principale con sidebar */
      .main-container {
        display: flex;
        width: 100%;
        height: 100%;
      }
      .sidebar {
        width: 240px;
        background-color: #000000;
        padding: 20px;
        border-right: 1px solid #282828;
        overflow-y: auto;
        flex-shrink: 0;
      }
      .main-content {
        flex: 1;
        overflow-y: auto;
        padding: 0;
        display: flex;
        flex-direction: column;
      }
      .content-area {
        padding: 20px;
        flex: 1;
        overflow-y: auto;
      }
      .status-container {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .server-status {
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 14px;
        font-weight: bold;
      }
      .status-online {
        background-color: #1db954;
        color: #121212;
      }
      .status-offline {
        background-color: #e22134;
        color: #ffffff;
      }
      .status-warning {
        background-color: #f59b23;
        color: #121212;
      }
      .player-container,
      .playlist-container,
      .relay-container {
        background: #181818;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        margin-bottom: 20px;
      }
      button {
        background-color: #1db954;
        color: #121212;
        border: none;
        padding: 8px 16px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 14px;
        border-radius: 20px;
        cursor: pointer;
        margin-right: 5px;
        transition: background-color 0.3s;
      }
      button:hover {
        background-color: #1ed760;
      }
      #songsList {
        list-style-type: none;
        padding: 0;
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        grid-gap: 16px;
      }
      .song-item {
        background-color: #282828;
        border-radius: 8px;
        padding: 16px;
        display: flex;
        flex-direction: column;
        transition: background-color 0.3s;
        position: relative;
      }
      .song-item:hover {
        background-color: #333333;
      }
      .song-info {
        flex-grow: 1;
        margin-top: 12px;
      }
      .song-title {
        font-weight: bold;
        margin-bottom: 6px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .song-artist {
        font-size: 14px;
        color: #a7a7a7;
        margin: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .song-actions {
        margin-top: 12px;
        display: flex;
        gap: 5px;
      }
      .artwork {
        width: 100%;
        height: 170px;
        object-fit: cover;
        border-radius: 4px;
      }
      .artwork-placeholder {
        width: 100%;
        height: 170px;
        background-color: #333333;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 40px;
        color: #888;
      }
      .player-controls {
        background-color: #181818;
        border-top: 1px solid #282828;
        padding: 16px 24px;
        display: flex;
        align-items: center;
        gap: 16px;
        flex-shrink: 0;
      }
      .play-btn,
      .pause-btn {
        background-color: #1db954;
        font-size: 16px;
        padding: 12px 16px;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .play-btn:hover,
      .pause-btn:hover {
        background-color: #1ed760;
        transform: scale(1.05);
      }
      .now-playing {
        margin-bottom: 20px;
        padding: 16px;
        background-color: #282828;
        border-radius: 8px;
        display: flex;
        align-items: center;
      }
      .now-playing-info {
        margin-left: 16px;
      }
      #waveform {
        width: 100%;
        height: 60px;
        background-color: #282828;
        border-radius: 4px;
      }
      .relay-input {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
      }
      .relay-input input {
        flex-grow: 1;
        padding: 8px 16px;
        background-color: #333333;
        color: #eaeaea;
        border: 1px solid #444444;
        border-radius: 20px;
        box-sizing: border-box;
      }
      #relayList {
        list-style-type: none;
        padding: 0;
      }
      .relay-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px;
        border-bottom: 1px solid #333333;
        font-size: 14px;
      }
      .relay-item button {
        margin-left: 10px;
        padding: 4px 8px;
        font-size: 12px;
      }
      .status-badge {
        padding: 3px 6px;
        border-radius: 4px;
        font-size: 12px;
        margin-left: 10px;
      }
      .status-badge.online {
        background-color: #1db954;
        color: #121212;
      }
      .status-badge.offline {
        background-color: #e22134;
        color: #ffffff;
      }
      .status-badge.warning {
        background-color: #f59b23;
        color: #121212;
      }
      /* Stili per messaggi di caricamento e errore */
      .loading,
      .error,
      .empty-library {
        padding: 20px;
        text-align: center;
        background-color: #282828;
        border-radius: 8px;
        margin: 20px 0;
        width: 100%;
      }
      .loading {
        color: #1db954;
        animation: pulse 1.5s infinite ease-in-out;
      }
      .error {
        color: #e22134;
        border-left: 4px solid #e22134;
      }
      .empty-library {
        color: #a7a7a7;
        font-style: italic;
      }
      @keyframes pulse {
        0% {
          opacity: 0.6;
        }
        50% {
          opacity: 1;
        }
        100% {
          opacity: 0.6;
        }
      }
      .admin-link {
        margin-top: 20px;
        text-align: center;
      }
      .admin-link a {
        color: #a7a7a7;
        text-decoration: none;
        font-size: 14px;
      }
      .admin-link a:hover {
        color: #ffffff;
        text-decoration: underline;
      }
      /* Token input styling */
      #customToken {
        background-color: #333333;
        color: #eaeaea;
        border: 1px solid #444444;
        border-radius: 20px;
        padding: 8px 16px;
        width: 100%;
      }
      /* Filter styling */
      .filter-container {
        margin-bottom: 20px;
        padding: 16px;
        background-color: #282828;
        border-radius: 8px;
      }
      #filterType {
        padding: 8px 16px;
        background-color: #333333;
        color: #eaeaea;
        border: 1px solid #444444;
        border-radius: 20px;
      }
      #filterInput {
        flex-grow: 1;
        padding: 8px 16px;
        background-color: #333333;
        color: #eaeaea;
        border: 1px solid #444444;
        border-radius: 20px;
      }
      #clearFilterBtn {
        padding: 8px 16px;
        background-color: #333333;
        color: #eaeaea;
      }
      #clearFilterBtn:hover {
        background-color: #444444;
      }
      /* Stile per il controllo volume */
      #volumeSlider {
        -webkit-appearance: none;
        width: 100px;
        height: 4px;
        background: #555555;
        border-radius: 2px;
        margin-left: auto;
      }
      #volumeSlider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 12px;
        height: 12px;
        background: #ffffff;
        border-radius: 50%;
        cursor: pointer;
      }
      .time-display {
        font-size: 14px;
        color: #a7a7a7;
        min-width: 80px;
        text-align: center;
      }
      .menu-item div {
        padding: 10px 0;
        color: #a7a7a7;
        transition: color 0.3s;
        cursor: pointer;
      }
      .menu-item div:hover {
        color: #ffffff;
      }
      /* Stili per l'autenticazione */
      .auth-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }
      .auth-form {
        background-color: #282828;
        padding: 30px;
        border-radius: 8px;
        width: 400px;
        max-width: 90%;
      }
      .auth-logo {
        text-align: center;
        margin-bottom: 20px;
      }
      .auth-logo h1 {
        color: #1db954;
        margin: 0;
      }
      .auth-tabs {
        display: flex;
        margin-bottom: 20px;
      }
      .auth-tab {
        flex: 1;
        text-align: center;
        padding: 10px;
        cursor: pointer;
        border-bottom: 2px solid transparent;
      }
      .auth-tab.active {
        border-bottom: 2px solid #1db954;
        color: #1db954;
      }
      .auth-input {
        width: 100%;
        padding: 12px;
        margin-bottom: 15px;
        background-color: #333;
        border: none;
        border-radius: 4px;
        color: #fff;
        box-sizing: border-box;
      }
      .auth-button {
        width: 100%;
        padding: 12px;
        background-color: #1db954;
        color: #000;
        border: none;
        border-radius: 50px;
        cursor: pointer;
        font-weight: bold;
      }
      .auth-button:hover {
        background-color: #1ed760;
      }
      .auth-separator {
        display: flex;
        align-items: center;
        text-align: center;
        margin: 20px 0;
      }
      .auth-separator::before,
      .auth-separator::after {
        content: "";
        flex: 1;
        border-bottom: 1px solid #444;
      }
      .auth-separator span {
        padding: 0 10px;
        color: #888;
      }
      .auth-options {
        display: flex;
        gap: 10px;
      }
      .auth-option-button {
        flex: 1;
        padding: 10px;
        background-color: #333;
        border: 1px solid #444;
        border-radius: 4px;
        color: #fff;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .auth-option-button:hover {
        background-color: #444;
      }
      .auth-form-group {
        margin-bottom: 15px;
      }
      .auth-error {
        color: #e74c3c;
        margin-top: -10px;
        margin-bottom: 15px;
        font-size: 14px;
      }
      .auth-success {
        color: #1db954;
        margin-top: -10px;
        margin-bottom: 15px;
        font-size: 14px;
      }
      .auth-hidden {
        display: none;
      }
      /* Stili per le playlist personali */
      .playlists-menu {
        margin-top: 10px;
      }
      .playlist-item {
        padding: 8px 0;
        color: #a7a7a7;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: color 0.2s;
      }
      .playlist-item:hover {
        color: #ffffff;
      }
      .playlist-item.active {
        color: #1db954;
      }
      .playlist-actions {
        margin-top: 10px;
      }
      .playlist-small-button {
        background-color: transparent;
        color: #a7a7a7;
        border: 1px solid #444;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        cursor: pointer;
        margin-left: 5px;
        padding: 0;
      }
      .playlist-small-button:hover {
        background-color: #333;
        color: #ffffff;
      }
      .playlist-create {
        display: flex;
        margin-top: 15px;
      }
      .playlist-create input {
        flex-grow: 1;
        background-color: #333;
        border: 1px solid #444;
        border-radius: 4px;
        padding: 8px;
        color: #eaeaea;
        margin-right: 5px;
      }
      .favorites-section {
        margin-top: 20px;
      }
      .favorite-item {
        padding: 8px 0;
        color: #a7a7a7;
        cursor: pointer;
      }
      .favorite-item:hover {
        color: #ffffff;
      }
      /* Badge per conteggio elementi */
      .count-badge {
        background-color: #333;
        color: #a7a7a7;
        border-radius: 10px;
        padding: 2px 6px;
        font-size: 11px;
        margin-left: 5px;
      }
      /* Dropdown per le opzioni traccia */
      .track-dropdown {
        position: relative;
        display: inline-block;
      }
      .track-dropdown-content {
        display: none;
        position: absolute;
        background-color: #333;
        min-width: 160px;
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        border-radius: 4px;
        z-index: 1;
        right: 0;
      }
      .track-dropdown:hover .track-dropdown-content {
        display: block;
      }
      .dropdown-item {
        color: #eaeaea;
        padding: 8px 16px;
        display: block;
        cursor: pointer;
        font-size: 14px;
      }
      .dropdown-item:hover {
        background-color: #444;
      }
      /* Tab di visualizzazione */
      .content-tabs {
        display: flex;
        border-bottom: 1px solid #333;
        margin-bottom: 20px;
      }
      .content-tab {
        padding: 12px 20px;
        cursor: pointer;
        color: #a7a7a7;
        border-bottom: 2px solid transparent;
      }
      .content-tab.active {
        color: #1db954;
        border-bottom: 2px solid #1db954;
      }
      .content-tab:hover {
        color: #ffffff;
      }
      .tab-content {
        display: none;
      }
      .tab-content.active {
        display: block;
      }
      /* Stili per la sezione dei preferiti */
      .favorite-section {
        margin-top: 20px;
      }
      
      .tab-controls {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
      }
      
      .tab-button {
        padding: 8px 16px;
        background-color: #282828;
        border: none;
        border-radius: 20px;
        color: #eaeaea;
        cursor: pointer;
        transition: background-color 0.3s;
      }
      
      .tab-button.active {
        background-color: #1db954;
        color: #121212;
      }
      
      .tab-button:hover {
        background-color: #333333;
      }
      
      .tab-button.active:hover {
        background-color: #1ed760;
      }
      
      .empty-message {
        padding: 30px;
        text-align: center;
        color: #888;
        font-style: italic;
        background-color: #282828;
        border-radius: 8px;
      }
      
      .loading-message {
        padding: 30px;
        text-align: center;
        color: #eaeaea;
        background-color: #282828;
        border-radius: 8px;
      }
      
      .tab-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }
      /* Stili per il player audio */
      .player-controls {
        background-color: #181818;
        border-top: 1px solid #282828;
        padding: 16px 24px;
        display: flex;
        align-items: center;
        gap: 16px;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 100;
      }
      
      .player-artwork-container {
        width: 56px;
        height: 56px;
        flex-shrink: 0;
        overflow: hidden;
        border-radius: 4px;
      }
      
      .player-artwork-container img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      
      .player-info {
        flex-grow: 0;
        flex-shrink: 1;
        min-width: 180px;
        max-width: 300px;
        overflow: hidden;
      }
      
      .player-track-title {
        font-weight: bold;
        font-size: 14px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      
      .player-track-artist {
        font-size: 12px;
        color: #b3b3b3;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      
      .player-buttons {
        display: flex;
        align-items: center;
        gap: 16px;
        flex-shrink: 0;
      }
      
      .player-control-btn {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        background-color: #1db954;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        border: none;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      
      .player-control-btn:hover {
        transform: scale(1.1);
        background-color: #1ed760;
      }
      
      .player-progress {
        flex-grow: 1;
        display: flex;
        align-items: center;
        gap: 8px;
        color: #b3b3b3;
        font-size: 12px;
      }
      
      #progressBar {
        flex-grow: 1;
        height: 4px;
        border-radius: 2px;
        background-color: #535353;
        color: #1db954;
        border: none;
      }
      
      #progressBar::-webkit-progress-bar {
        background-color: #535353;
        border-radius: 2px;
      }
      
      #progressBar::-webkit-progress-value {
        background-color: #1db954;
        border-radius: 2px;
      }
      
      .player-volume {
        display: flex;
        align-items: center;
        gap: 8px;
        color: #b3b3b3;
        flex-shrink: 0;
      }
      
      #volumeControl {
        width: 80px;
        height: 4px;
        background-color: #535353;
        appearance: none;
        border-radius: 2px;
        outline: none;
      }
      
      #volumeControl::-webkit-slider-thumb {
        appearance: none;
        width: 12px;
        height: 12px;
        background-color: white;
        border-radius: 50%;
        cursor: pointer;
      }
      
      #volumeControl::-moz-range-thumb {
        width: 12px;
        height: 12px;
        background-color: white;
        border-radius: 50%;
        cursor: pointer;
        border: none;
      }
      /* Stili per gli artwork e i loro contenitori */
      .artwork-container {
        width: 100%;
        position: relative;
        aspect-ratio: 1 / 1;
        overflow: hidden;
        border-radius: 6px;
        margin-bottom: 10px;
      }
      
      .artwork {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 6px;
        background-color: #282828;
      }
      
      .artwork-small {
        width: 48px;
        height: 48px;
        object-fit: cover;
        border-radius: 4px;
        background-color: #282828;
      }
      
      .artwork-placeholder {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #333333;
        color: #888;
        font-size: 32px;
        border-radius: 6px;
      }
    </style>
  </head>
  <body>
    <!-- Auth Container -->
    <div id="authContainer" class="auth-container">
      <div class="auth-form">
        <div class="auth-logo">
          <h1>Shogun Music</h1>
          <p>Accedi per ascoltare la tua musica</p>
        </div>
        <div class="auth-tabs">
          <div class="auth-tab active" data-tab="login">Accedi</div>
          <div class="auth-tab" data-tab="signup">Registrati</div>
        </div>

        <!-- Login Form -->
        <div id="loginForm" class="auth-form-content">
          <div class="auth-form-group">
            <input
              type="text"
              id="loginUsername"
              class="auth-input"
              placeholder="Username"
            />
          </div>
          <div class="auth-form-group">
            <input
              type="password"
              id="loginPassword"
              class="auth-input"
              placeholder="Password"
            />
          </div>
          <div id="loginError" class="auth-error auth-hidden"></div>
          <div id="loginSuccess" class="auth-success auth-hidden"></div>
          <button id="loginButton" class="auth-button">Accedi</button>

          <div class="auth-separator">
            <span>OPPURE</span>
          </div>

          <div class="auth-options">
            <button id="webauthnLoginBtn" class="auth-option-button">
              <span>WebAuthn</span>
            </button>
            <button id="metamaskLoginBtn" class="auth-option-button">
              <span>MetaMask</span>
            </button>
          </div>
        </div>

        <!-- Signup Form -->
        <div id="signupForm" class="auth-form-content auth-hidden">
          <div class="auth-form-group">
            <input
              type="text"
              id="signupUsername"
              class="auth-input"
              placeholder="Username"
            />
          </div>
          <div class="auth-form-group">
            <input
              type="password"
              id="signupPassword"
              class="auth-input"
              placeholder="Password"
            />
          </div>
          <div class="auth-form-group">
            <input
              type="password"
              id="signupPasswordConfirm"
              class="auth-input"
              placeholder="Conferma password"
            />
          </div>
          <div id="signupError" class="auth-error auth-hidden"></div>
          <div id="signupSuccess" class="auth-success auth-hidden"></div>
          <button id="signupButton" class="auth-button">Registrati</button>

          <div class="auth-separator">
            <span>OPPURE</span>
          </div>

          <div class="auth-options">
            <button id="webauthnSignupBtn" class="auth-option-button">
              <span>WebAuthn</span>
            </button>
            <button id="metamaskSignupBtn" class="auth-option-button">
              <span>MetaMask</span>
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Main App Content -->
    <div class="main-container" id="appContainer" style="display: none">
      <div class="sidebar">
        <h2>Shogun Music</h2>

        <div style="margin: 30px 0">
          <h3>Il tuo Profilo</h3>
          <div class="menu-item">
            <div>
              <span id="userProfileUsername">Utente</span>
            </div>
            <div>
              <span>La tua libreria</span>
            </div>
            <div>
              <button id="logoutBtn" style="width: 100%; margin-top: 10px">
                Logout
              </button>
            </div>
          </div>
        </div>

        <div style="margin: 30px 0">
          <h3>Server Status</h3>
          <div class="status-container">
            <div id="gunStatus" class="server-status status-offline">
              GUN offline
            </div>
          </div>
        </div>

        

        <div class="favorites-section">
          <h3>Preferiti</h3>
          <div class="menu-item">
            <div class="favorite-item" data-section="favorite-songs">
              <span>Brani</span>
              <span class="count-badge" id="favoriteSongsCount">0</span>
            </div>
            <div class="favorite-item" data-section="favorite-artists">
              <span>Artisti</span>
              <span class="count-badge" id="favoriteArtistsCount">0</span>
            </div>
            <div class="favorite-item" data-section="favorite-albums">
              <span>Album</span>
              <span class="count-badge" id="favoriteAlbumsCount">0</span>
            </div>
          </div>
        </div>

        <div class="playlists-section" style="margin: 30px 0">
          <h3>Le tue Playlist</h3>
          <div class="playlists-menu" id="playlistsMenu">
            <!-- Le playlist verranno aggiunte qui dinamicamente -->
          </div>
          <div class="playlist-create">
            <input
              type="text"
              id="newPlaylistName"
              placeholder="Nuova playlist..."
            />
            <button class="playlist-small-button" id="createPlaylistBtn">
              +
            </button>
          </div>
        </div>

        <div style="margin: 30px 0">
          <h3>Relay</h3>
          <p>Aggiungi relay per connetterti ad altri nodi Gun.js</p>
          <div class="relay-input">
            <input
              type="text"
              id="relayInput"
              placeholder="URL relay (es. https://gun-relay.example.com/gun)"
            />
            <button id="addRelayBtn">Aggiungi</button>
          </div>
          <ul id="relayList"></ul>
        </div>
      </div>

      <div class="main-content">
        <div class="content-area">
          <div class="player-container">
            <h2>Player</h2>
            <div id="nowPlaying" class="now-playing" style="display: none">
              <div id="nowPlayingArtwork" class="artwork-placeholder">♪</div>
              <div class="now-playing-info">
                <div id="nowPlayingTitle" class="song-title">
                  Nessuna traccia
                </div>
                <div id="nowPlayingArtist" class="song-artist">
                  Nessun artista
                </div>
              </div>
            </div>

            <div id="waveform"></div>
          </div>

          <div class="playlist-container">
            <div class="content-tabs">
              <div class="content-tab active" data-tab="all-tracks">
                Libreria
              </div>
              <div class="content-tab" data-tab="playlists">
                Le tue Playlist
              </div>
              <div class="content-tab" data-tab="favorites">Preferiti</div>
            </div>

            <!-- Tab Libreria -->
            <div class="tab-content active" id="all-tracks-tab">
              <h2>Libreria Completa</h2>

              <!-- Filtri -->
              <div class="filter-container">
                <div
                  style="
                    display: flex;
                    gap: 10px;
                    align-items: center;
                    margin-bottom: 8px;
                  "
                >
                  <select id="filterType">
                    <option value="all">Tutto</option>
                    <option value="title">Titolo</option>
                    <option value="artist">Artista</option>
                    <option value="album">Album</option>
                  </select>
                  <input type="text" id="filterInput" placeholder="Cerca..." />
                  <button id="clearFilterBtn">Pulisci</button>
                </div>
                <div
                  id="filterStatus"
                  style="font-size: 13px; color: #a7a7a7"
                ></div>
              </div>

              <div id="songsLoading" class="loading">
                Caricamento tracce in corso...
              </div>
              <div id="songsError" class="error" style="display: none">
                Errore nel caricamento delle tracce
              </div>
              <div id="songsEmpty" class="empty-library" style="display: none">
                Nessuna traccia disponibile. Vai alla pagina di Admin per
                caricare musica.
              </div>
              <ul id="songsList"></ul>
            </div>

            <!-- Tab Playlist -->
            <div class="tab-content" id="playlists-tab">
              <div id="playlistHeader">
                <h2 id="currentPlaylistName">Seleziona una playlist</h2>
                <div
                  id="playlistInfo"
                  style="color: #a7a7a7; margin-bottom: 20px; display: none"
                >
                  <span id="playlistTrackCount">0 brani</span> •
                  <span id="playlistDuration">0 min</span>
                </div>
              </div>

              <div id="playlistEmpty" class="empty-library">
                Seleziona una playlist dalla barra laterale o creane una nuova
              </div>

              <ul id="playlistSongsList"></ul>
            </div>

            <!-- Tab Preferiti -->
            <div class="tab-content" id="favorites-tab">
              <div class="tab-header">
                <h2 id="currentFavoriteSection">Brani preferiti</h2>
                <div class="tab-controls">
                  <button class="tab-button active" data-favorite-type="songs">Brani</button>
                  <button class="tab-button" data-favorite-type="artists">Artisti</button>
                  <button class="tab-button" data-favorite-type="albums">Album</button>
                </div>
              </div>
              
              <!-- Sezione brani preferiti -->
              <div id="favoriteSongsSection" class="favorite-section">
                <ul id="favoriteSongsList" class="songs-list"></ul>
                <div id="favoriteSongsEmpty" class="empty-message" style="display: none;">
                  Nessun brano preferito. Aggiungi brani ai preferiti per vederli qui.
                </div>
                <div id="favoriteSongsLoading" class="loading-message" style="display: none;">
                  Caricamento brani preferiti...
                </div>
              </div>
              
              <!-- Sezione artisti preferiti -->
              <div id="favoriteArtistsSection" class="favorite-section" style="display: none;">
                <ul id="favoriteArtistsList" class="artists-list"></ul>
                <div id="favoriteArtistsEmpty" class="empty-message" style="display: none;">
                  Nessun artista preferito. Aggiungi artisti ai preferiti per vederli qui.
                </div>
              </div>
              
              <!-- Sezione album preferiti -->
              <div id="favoriteAlbumsSection" class="favorite-section" style="display: none;">
                <ul id="favoriteAlbumsList" class="albums-list"></ul>
                <div id="favoriteAlbumsEmpty" class="empty-message" style="display: none;">
                  Nessun album preferito. Aggiungi album ai preferiti per vederli qui.
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Player controls -->
        <div class="player-controls" id="playerControls" style="display: none;">
          <div id="currentTrackArtwork" class="player-artwork-container">
            <div class="artwork-placeholder">♪</div>
          </div>
          <div class="player-info">
            <div id="currentTrackTitle" class="player-track-title">Nessuna traccia in riproduzione</div>
            <div id="currentTrackArtist" class="player-track-artist">Artista sconosciuto</div>
          </div>
          <div class="player-buttons">
            <button id="playPauseBtn" class="player-control-btn">
              <i class="fas fa-play"></i>
            </button>
          </div>
          <div class="player-progress">
            <span id="currentTime">0:00</span>
            <progress id="progressBar" value="0" max="100"></progress>
            <span id="totalTime">0:00</span>
          </div>
          <div class="player-volume">
            <i class="fas fa-volume-up"></i>
            <input type="range" id="volumeControl" min="0" max="1" step="0.1" value="0.7">
          </div>
          <audio id="audioPlayer"></audio>
        </div>
      </div>
    </div>

    <script>
      // Variabili globali
      let userPlaylists = [];
      let userFavorites = { songs: [], artists: [], albums: [] };
      let tracks = []; // Definito come variabile globale per accesso da altre funzioni
      let allTracks = []; // Per mantenere un riferimento a tutte le tracce caricate

      // Variabile per tracciare la playlist corrente
      let currentPlaylistId = null;

      // Variabile per tracciare lo stato di riproduzione
      let isPlaying = false;

      // Funzione per aggiornare i contatori dei preferiti
      function updateFavoriteCounts() {
        console.log("Aggiornamento contatori preferiti...");
        
        // Verifica se userFavorites esiste
        if (!window.userFavorites) {
          return;
        }
        
        // Aggiorna i contatori nel menu
        const songCountEl = document.querySelector('.favorite-count[data-type="songs"]');
        const artistCountEl = document.querySelector('.favorite-count[data-type="artists"]');
        const albumCountEl = document.querySelector('.favorite-count[data-type="albums"]');
        
        if (songCountEl) {
          songCountEl.textContent = window.userFavorites.songs?.length || 0;
        }
        
        if (artistCountEl) {
          artistCountEl.textContent = window.userFavorites.artists?.length || 0;
        }
        
        if (albumCountEl) {
          albumCountEl.textContent = window.userFavorites.albums?.length || 0;
        }
        
        console.log("Contatori preferiti aggiornati");
      }

      // Funzione per salvare le playlist dell'utente in GunDB
      function saveUserPlaylistsToGun() {
        console.log("Salvataggio playlist tramite PlaylistManager...");
        
        // Verifica che PlaylistManager sia disponibile
        if (!window.PlaylistManager) {
          console.error("saveUserPlaylistsToGun: PlaylistManager non disponibile");
          return Promise.reject(new Error("PlaylistManager non disponibile"));
        }
        
        // Verifica che userPlaylists esista
        if (!window.userPlaylists) {
          console.warn("Nessuna playlist da salvare");
          return Promise.resolve(false);
        }
        
        // Usa PlaylistManager per salvare le playlist
        return window.PlaylistManager.savePlaylists(window.userPlaylists)
          .then(result => {
            console.log("Playlist salvate con successo tramite PlaylistManager");
            return result;
          })
          .catch(error => {
            console.error("Errore durante il salvataggio delle playlist:", error);
            throw error;
          });
      }

      // Funzione per salvare i preferiti dell'utente in GunDB
      function saveUserFavoritesToGun(forceSync = false) {
        // Deleghiamo al modulo FavoritesManager
        return window.FavoritesManager.saveUserFavoritesToGun(forceSync);
      }
      
      // Funzione di utilità per convertire un array in un oggetto compatibile con GunDB
      function arrayToGunObject(arr) {
        if (!Array.isArray(arr)) return {};
        
        const obj = {};
        arr.forEach((item, index) => {
          obj[index] = item;
        });
        return obj;
      }
      
      // Funzione di utilità per convertire un oggetto GunDB in array
      function gunObjectToArray(obj) {
        if (!obj || typeof obj !== 'object') return [];
        
        // Filtra le proprietà che non sono indici numerici o metadati di Gun
        return Object.keys(obj)
          .filter(key => !isNaN(Number(key)) && key !== '_' && obj[key] !== null)
          .map(key => obj[key]);
      }

      // Funzione per caricare le playlist dell'utente da GunDB
      function loadUserPlaylistsFromGun() {
        return new Promise((resolve, reject) => {
          console.log("Caricamento playlist da PlaylistManager...");
          
          // Assicurati che PlaylistManager sia disponibile usando il fallback se necessario
          const manager = ensurePlaylistManager();
          
          // Usa PlaylistManager per caricare le playlist
          manager.loadPlaylists()
            .then(playlists => {
              console.log(`Caricate ${playlists.length} playlist tramite PlaylistManager`);
              
              // Aggiorna l'array globale
              window.userPlaylists = playlists;
              
              resolve(playlists);
            })
            .catch(error => {
              console.error("Errore nel caricamento delle playlist:", error);
              
              // Inizializza con un array vuoto in caso di errore
              window.userPlaylists = [];
              
              reject(error);
            });
        });
      }

      // Funzione per caricare i preferiti dell'utente da GunDB
      function loadUserFavoritesFromGun() {
        return new Promise((resolve, reject) => {
          console.log("Caricamento preferiti da Gun.js...");
          
          if (!window.shogun || !window.shogun.gun) {
            console.error("loadUserFavoritesFromGun: Gun.js non disponibile");
            reject(new Error("Gun.js non disponibile"));
            return;
          }
          
          // Verifica autenticazione o caricamento come utente generico
          const isAuthenticated = window.shogun.isLoggedIn && window.shogun.isLoggedIn();
          
          try {
            // Inizializza l'oggetto dei preferiti se non esiste
            if (!window.userFavorites) {
              window.userFavorites = { songs: [], artists: [], albums: [] };
            }
            
            // Tenta il caricamento diretto da Gun.js
            checkDirectFavoritesData()
              .then(success => {
                if (success) {
                  console.log("Preferiti caricati con successo da Gun.js");
                  resolve(window.userFavorites);
                } else {
                  console.log("Nessun dato preferiti trovato in Gun.js. Inizializzazione preferiti vuoti.");
                  // Non carica più da localStorage, risolve con l'oggetto vuoto o quello già esistente
                      resolve(window.userFavorites);
                }
              })
              .catch(err => {
                console.error("Errore nel caricamento preferiti da Gun.js:", err);
                // Non carica da localStorage in caso di errore, risolve con l'oggetto vuoto o esistente
                    resolve(window.userFavorites);
              });
          } catch (error) {
            console.error("Errore generale nel caricamento preferiti:", error);
            reject(error);
          }
        });
      }
      
      // // Funzione di supporto per salvare i preferiti in localStorage - NON PIÙ USATA
      // function saveUserFavoritesToLocalStorage() { ... }

      // Funzione helper per aggiornare le viste dei preferiti 
      function updateFavoritesDisplay() {
        console.log("Aggiornamento visualizzazione preferiti...");
        
        // Verifica se userFavorites esiste
        if (!window.userFavorites) {
          console.warn("updateFavoritesDisplay: userFavorites non inizializzato");
          return;
        }
        
        // Aggiorna la visualizzazione dei brani preferiti
        const favoritesSongsContainer = document.querySelector('#favorites-songs-container');
        if (favoritesSongsContainer) {
          // Ottieni i brani preferiti
          const favoriteSongs = window.userFavorites.songs || [];
          
          if (favoriteSongs.length === 0) {
            // Nessun brano preferito
            favoritesSongsContainer.innerHTML = '<div class="no-favorites-message">Non hai ancora brani preferiti</div>';
            return;
          }
          
          // Costruisci l'HTML per i brani preferiti
          let html = '';
          
          // Per ogni brano preferito, trova le informazioni complete nel catalogo
          favoriteSongs.forEach(favSong => {
            // Cerca la traccia completa nell'array delle tracce
            let fullTrackInfo = null;
            if (window.tracks) {
              fullTrackInfo = window.tracks.find(track => track.id === favSong.id);
            }
            
            // Se abbiamo trovato le info complete, usale, altrimenti usa solo l'ID e il nome
            const track = fullTrackInfo || {
              id: favSong.id,
              title: favSong.name,
              artist: 'Artista sconosciuto',
              album: 'Album sconosciuto',
              artwork: `/uploads/${favSong.id}-artwork.jpg` // Percorso predefinito
            };
            
            // Crea l'HTML per questo brano
            html += `
              <div class="song-item" data-id="${track.id}">
                <div class="song-artwork">
                  <img src="${track.artwork || '/images/default-artwork.jpg'}" alt="${track.title}" onerror="this.src='/images/default-artwork.jpg'">
                </div>
                <div class="song-info">
                  <div class="song-title">${track.title || 'Titolo sconosciuto'}</div>
                  <div class="song-artist">${track.artist || 'Artista sconosciuto'}</div>
                </div>
                <div class="song-actions">
                  <button class="play-btn" onclick="playSong('${track.id}')">
                    <i class="fas fa-play"></i>
                  </button>
                  <button class="favorite-btn" data-id="${track.id}" data-type="songs" data-favorite="true" onclick="toggleFavorite('${track.id}', 'songs', '${track.title?.replace(/'/g, "\\'")}')">
                    <i class="fas fa-heart"></i>
                  </button>
                </div>
              </div>
            `;
          });
          
          // Aggiorna il contenitore
          favoritesSongsContainer.innerHTML = html;
          
          console.log(`Visualizzati ${favoriteSongs.length} brani preferiti`);
        } else {
          console.warn("Container brani preferiti non trovato");
        }
        
        // Aggiorna anche gli artisti e gli album preferiti se necessario
        // ... codice per gli artisti ...
        // ... codice per gli album ...
      }

      // Carica i dati salvati all'inizio
      document.addEventListener("DOMContentLoaded", function () {
        // Configurazione iniziale
        userPlaylists = [];
        userFavorites = { songs: [], artists: [], albums: [] };
        
        // Imposta il flag per usare solo GunDB (niente localStorage)
        window.useOnlyGunDB = true;
      });

      // Logica di autenticazione
      document.addEventListener("DOMContentLoaded", function () {
        // Riferimenti agli elementi DOM di autenticazione
        const authContainer = document.getElementById("authContainer");
        const appContainer = document.getElementById("appContainer");
        const authTabs = document.querySelectorAll(".auth-tab");
        const loginForm = document.getElementById("loginForm");
        const signupForm = document.getElementById("signupForm");

        // Username/password login/signup
        const loginUsername = document.getElementById("loginUsername");
        const loginPassword = document.getElementById("loginPassword");
        const loginButton = document.getElementById("loginButton");
        const loginError = document.getElementById("loginError");
        const loginSuccess = document.getElementById("loginSuccess");

        const signupUsername = document.getElementById("signupUsername");
        const signupPassword = document.getElementById("signupPassword");
        const signupPasswordConfirm = document.getElementById(
          "signupPasswordConfirm"
        );
        const signupButton = document.getElementById("signupButton");
        const signupError = document.getElementById("signupError");
        const signupSuccess = document.getElementById("signupSuccess");

        // WebAuthn buttons
        const webauthnLoginBtn = document.getElementById("webauthnLoginBtn");
        const webauthnSignupBtn = document.getElementById("webauthnSignupBtn");

        // MetaMask buttons
        const metamaskLoginBtn = document.getElementById("metamaskLoginBtn");
        const metamaskSignupBtn = document.getElementById("metamaskSignupBtn");

        // Inizializzazione di Shogun Core
        function initShogun() {
          try {
            // Configurazione per Shogun Core
            const shogunConfig = {
              gundb: {
                peers: ["http://localhost:3000/gun"],
                localStorage: false,  // Disabilita esplicitamente localStorage
                radisk: false,        // Usa radisk per storage persistente
                authToken: "thisIsTheTokenForReals"
              },
              webauthn: {
                enabled: true,
              },
              metamask: {
                enabled: true,
              }
            };

            // Inizializza Shogun Core con la configurazione
            window.shogun = window.initShogunBrowser(shogunConfig);

            console.log(
              "Shogun Core inizializzato con successo",
              window.shogun
            );

            // Gestione eventi
            if (window.shogun.isLoggedIn()) {
              console.log("Utente già autenticato:", window.shogun.gun.user()._.alias || "Utente senza nome");
              authContainer.style.display = "none";
              appContainer.style.display = "flex";

              // Aggiorna il nome utente nel profilo
              updateUserProfile();

              // Inizializza il contenuto utente
              initUserContent();
            } else {
              console.log("Utente non autenticato. Mostra schermata di login.");
              authContainer.style.display = "flex";
              appContainer.style.display = "none";
            }

            // Verifica se WebAuthn è supportato
            if (webauthnLoginBtn && webauthnSignupBtn) {
              const isWebAuthnSupported = window.shogun.isWebAuthnSupported();

              if (!isWebAuthnSupported) {
                console.log("WebAuthn non supportato dal browser");
                webauthnLoginBtn.style.opacity = "0.5";
                webauthnSignupBtn.style.opacity = "0.5";
                webauthnLoginBtn.title =
                  "WebAuthn non supportato dal tuo browser";
                webauthnSignupBtn.title =
                  "WebAuthn non supportato dal tuo browser";
              }
            }

            // Verifica se MetaMask è disponibile
            if (metamaskLoginBtn && metamaskSignupBtn) {
              const isMetaMaskAvailable = window.ethereum !== undefined;

              if (!isMetaMaskAvailable) {
                console.log("MetaMask non disponibile");
                metamaskLoginBtn.style.opacity = "0.5";
                metamaskSignupBtn.style.opacity = "0.5";
                metamaskLoginBtn.title =
                  "MetaMask non disponibile. Installa l'estensione MetaMask";
                metamaskSignupBtn.title =
                  "MetaMask non disponibile. Installa l'estensione MetaMask";
              }
            }
          } catch (error) {
            console.error(
              "Errore durante l'inizializzazione di Shogun Core:",
              error
            );
          }
        }

        // Funzione per aggiornare il profilo utente
        function updateUserProfile() {
          // Ottieni elementi DOM
          const profileName = document.getElementById("profileName");
          const profileIcon = document.getElementById("profileIcon");
          
          if (!profileName || !profileIcon) {
            console.warn("Elementi del profilo utente non trovati");
            return;
          }
          
          // Recupera nome utente o usa un fallback se non disponibile
          let username = "Utente";
          if (window.shogun && window.shogun.gun && window.shogun.gun.user().is) {
            const gunUser = window.shogun.gun.user();
            
            if (gunUser._ && gunUser._.alias) {
              username = gunUser._.alias;
            } else if (gunUser.is && gunUser.is.alias) {
              username = gunUser.is.alias;
            } else if (gunUser.is && gunUser.is.pub) {
              // Usa le prime lettere della chiave pubblica come fallback
              username = `Utente ${gunUser.is.pub.substring(0, 5)}...`;
            }
          }
          
          // Imposta nome utente
          profileName.textContent = username;
          
          // Imposta avatar basato sulla prima lettera del nome utente
          profileIcon.textContent = username.charAt(0).toUpperCase();
        }

        // Verifica se Shogun Core è già caricato
        if (typeof window.initShogunBrowser !== "undefined") {
          initShogun();
        } else {
          // Se non è caricato, aggiungi un listener per quando sarà disponibile
          document.addEventListener("shogun:loaded", initShogun);
        }

        // Funzione per inizializzare il contenuto utente
        function initUserContent() {
          console.log("Inizializzazione contenuti utente...");
          
          // Inizializza le strutture dati
          userPlaylists = [];
          userFavorites = { songs: [], artists: [], albums: [] };
          
          // Diagnostica GunDB - verifica lo stato dell'utente prima del caricamento
          debugGunDBState();
          
          // Verifica se l'utente è autenticato
          if (window.shogun && window.shogun.gun && window.shogun.gun.user().is) {
            // Modo più sicuro per ottenere l'alias dell'utente
            let userAlias = "Sconosciuto";
            const gunUser = window.shogun.gun.user();
            
            if (gunUser._ && gunUser._.alias) {
              userAlias = gunUser._.alias;
            } else if (gunUser.is && gunUser.is.alias) {
              userAlias = gunUser.is.alias;
            } else if (gunUser.is && gunUser.is.pub) {
              userAlias = `Utente ${gunUser.is.pub.substring(0, 8)}...`;
            }
            
            console.log("Utente autenticato con successo:", userAlias);
            
            // Sottoscrizione in tempo reale ai cambiamenti dei preferiti
            window.FavoritesManager.setupRealtimeSubscriptions();
            
            // Un ulteriore tentativo di recall prima del caricamento
            try {
              window.shogun.gun.user().recall({sessionStorage: true});
              console.log("Richiamato user.recall() prima del caricamento dati");
              
              // Piccola pausa per assicurarsi che i dati siano disponibili
              setTimeout(() => {
                // Tenta di caricare i dati utente
                loadUserData();
              }, 500);
              
            } catch (e) {
              console.error("Errore nel richiamare user.recall():", e);
              // Comunque tenta di caricare i dati
              loadUserData();
            }
          } else {
            console.warn("Inizializzazione contenuti ma utente non autenticato correttamente!");
            // Tentativo di riautenticazione
            if (window.shogun) {
              console.log("Tentativo di riconnessione al database...");
              try {
                window.shogun.gun.user().recall({sessionStorage: true});
                
                // Attendi un po' e verifica se ha funzionato
                setTimeout(() => {
                  if (window.shogun.gun.user().is) {
                    console.log("Riautenticazione riuscita, carico i dati utente...");
                    loadUserData();
                  } else {
                    console.error("Fallita riautenticazione, impossibile caricare dati utente.");
                  }
                }, 500);
                
              } catch (e) {
                console.error("Errore durante il tentativo di riconnessione:", e);
              }
            }
          }
        }
        
        // Funzione separata per caricare i dati utente
        function loadUserData() {
          console.log("Caricamento dati utente in corso...");
          
          // Carica dati da GunDB con un controllo più robusto
          Promise.all([
            new Promise(resolve => {
              loadUserPlaylistsFromGun()
                .then(result => {
                  console.log("Risultato caricamento playlist:", result);
                  if (!result) {
                    // Se non ha trovato playlist, tenta un'ultima volta con un approccio diretto
                    console.log("Tentativo diretto di caricamento playlist...");
                    checkDirectPlaylistsData()
                      .then(directResult => {
                        console.log("Risultato caricamento diretto playlist:", directResult);
                        resolve(directResult);
                      })
                      .catch(() => resolve(false));
                  } else {
                    resolve(result);
                  }
                })
                .catch(err => {
                  console.error("Errore caricamento playlist:", err);
                  userPlaylists = []; // Assicurati che sia un array vuoto
                  resolve(false);
                });
            }),
            new Promise(resolve => {
              loadUserFavoritesFromGun()
                .then(result => {
                  console.log("Risultato caricamento preferiti:", result);
                  if (!result) {
                    // Se non ha trovato preferiti, tenta un'ultima volta con un approccio diretto
                    console.log("Tentativo diretto di caricamento preferiti...");
                    checkDirectFavoritesData()
                      .then(directResult => {
                        console.log("Risultato caricamento diretto preferiti:", directResult);
                        resolve(directResult);
                      })
                      .catch(() => resolve(false));
                  } else {
                    resolve(result);
                  }
                })
                .catch(err => {
                  console.error("Errore caricamento preferiti:", err);
                  resolve(false);
                });
            })
          ])
          .then(([playlistsLoaded, favoritesLoaded]) => {
            console.log("Risultato caricamento dati:", {playlistsLoaded, favoritesLoaded});
            
            // Dopo il caricamento, aggiorna l'interfaccia
            updateFavoriteCounts();
            displayPlaylists();
            setupContentTabs();

            // Gestione click sui preferiti nella sidebar
            document.querySelectorAll(".favorite-item").forEach((item) => {
              const section = item.getAttribute("data-section");
              const type = section.split("-")[1]; // 'favorite-songs' -> 'songs'

              item.addEventListener("click", () => {
                displayFavorites(type);
              });
            });

            // Gestione creazione playlist
            const createPlaylistBtn = document.getElementById("createPlaylistBtn");
            if (createPlaylistBtn) {
              createPlaylistBtn.addEventListener("click", () => {
                const newPlaylistName = document
                  .getElementById("newPlaylistName")
                  .value.trim();
                if (newPlaylistName) {
                  createPlaylist(newPlaylistName);
                  document.getElementById("newPlaylistName").value = "";
                } else {
                  alert("Inserisci un nome per la playlist");
                }
              });
            }

            // Permetti di premere Enter per creare playlist
            const newPlaylistInput = document.getElementById("newPlaylistName");
            if (newPlaylistInput) {
              newPlaylistInput.addEventListener("keypress", (e) => {
                if (e.key === "Enter") {
                  const newPlaylistName = newPlaylistInput.value.trim();
                  if (newPlaylistName) {
                    createPlaylist(newPlaylistName);
                    newPlaylistInput.value = "";
                  } else {
                    alert("Inserisci un nome per la playlist");
                  }
                }
              });
            }

            console.log("Inizializzazione contenuti utente completata");
            
            // Carica le tracce
            loadTracks();

            // Mostra un messaggio all'utente se non sono stati caricati dati
            if (!playlistsLoaded && !favoritesLoaded) {
              console.warn("Non è stato possibile caricare playlist o preferiti");
            }
          });
        }
        
        // Funzione per tentativo diretto di caricamento playlist
        function checkDirectPlaylistsData() {
          return new Promise((resolve) => {
            if (!window.shogun || !window.shogun.gun || !window.shogun.gun.user().is) {
              console.warn("Impossibile eseguire caricamento diretto: utente non autenticato");
              return resolve(false);
            }
            
            console.log("Tentativo di caricamento diretto playlist...");
            let foundData = false;
            
            // Cerca direttamente nelle prime 10 posizioni per trovare playlist
            const promises = [];
            for (let i = 0; i < 10; i++) {
              promises.push(new Promise(resolveCheck => {
                window.shogun.gun.user().get("playlists").get(i.toString()).once((data) => {
                  if (data && data.id && data.name) {
                    console.log(`Trovata playlist diretta [${i}]:`, data.name);
                    foundData = true;
                    
                    // Converti i dati nel formato corretto
                    const playlist = {
                      id: data.id,
                      name: data.name,
                      created: data.created || Date.now(),
                      tracks: []
                    };
                    
                    // Se ci sono tracce, convertile
                    if (data.tracks && typeof data.tracks === 'object') {
                      playlist.tracks = gunObjectToArray(data.tracks);
                    }
                    
                    // Aggiungi all'array globale
                    userPlaylists.push(playlist);
                  }
                  resolveCheck();
                });
              }));
            }
            
            // Attendi che tutte le verifiche siano completate
            Promise.all(promises).then(() => {
              if (foundData) {
                console.log(`Caricamento diretto completato: trovate ${userPlaylists.length} playlist`);
                // Aggiorna l'interfaccia
                displayPlaylists();
                resolve(true);
              } else {
                console.log("Nessuna playlist trovata con caricamento diretto");
                resolve(false);
              }
            });
          });
        }
        
        // Funzione per tentativo diretto di caricamento preferiti
        function checkDirectFavoritesData() {
          return new Promise((resolve) => {
            if (!window.shogun || !window.shogun.gun || !window.shogun.gun.user().is) {
              console.warn("Impossibile eseguire caricamento diretto preferiti: utente non autenticato");
              return resolve(false);
            }
            
            console.log("Tentativo di caricamento diretto preferiti...");
            let foundData = false;
            
            // Controlla direttamente ogni categoria
            Promise.all([
              new Promise(resolveCheck => {
                window.shogun.gun.user().get("favorites").get("songs").once((data) => {
                  if (data && typeof data === 'object') {
                    console.log("Trovati brani preferiti diretti");
                    userFavorites.songs = gunObjectToArray(data);
                    foundData = true;
                  }
                  resolveCheck();
                });
              }),
              new Promise(resolveCheck => {
                window.shogun.gun.user().get("favorites").get("artists").once((data) => {
                  if (data && typeof data === 'object') {
                    console.log("Trovati artisti preferiti diretti");
                    userFavorites.artists = gunObjectToArray(data);
                    foundData = true;
                  }
                  resolveCheck();
                });
              }),
              new Promise(resolveCheck => {
                window.shogun.gun.user().get("favorites").get("albums").once((data) => {
                  if (data && typeof data === 'object') {
                    console.log("Trovati album preferiti diretti");
                    userFavorites.albums = gunObjectToArray(data);
                    foundData = true;
                  }
                  resolveCheck();
                });
              })
            ]).then(() => {
              if (foundData) {
                console.log("Caricamento diretto preferiti completato");
                console.log(
                  "Preferiti trovati:",
                  "Brani:", userFavorites.songs.length,
                  "Artisti:", userFavorites.artists.length,
                  "Album:", userFavorites.albums.length
                );
                
                // Aggiorna interfaccia
                updateFavoriteCounts();
                updateFavoritesDisplay();
                resolve(true);
              } else {
                console.log("Nessun preferito trovato con caricamento diretto");
                resolve(false);
              }
            });
          });
        }

        // Funzione per caricare le tracce musicali
        async function loadTracks() {
          try {
            console.log("Caricamento delle tracce in corso...");
            
            // Mostra il messaggio di caricamento
            const songsLoading = document.getElementById("songsLoading");
            if (songsLoading) {
              songsLoading.style.display = "block";
            }
            
            // Nascondi altri messaggi di errore o "vuoto"
            const songsError = document.getElementById("songsError");
            const songsEmpty = document.getElementById("songsEmpty");
            if (songsError) songsError.style.display = "none";
            if (songsEmpty) songsEmpty.style.display = "none";
            
            // URL dell'API di esempio per caricare le tracce
            const tracksURL = "http://localhost:3000/api/tracks";
            
            // Array di tracce di esempio (utilizzato se non è possibile caricare le tracce dall'API)
            const exampleTracks = [
              {
                id: "1",
                title: "Esempio Brano 1",
                artist: "Artista Esempio",
                album: "Album Esempio",
                duration: 180,
                artwork_path: "/assets/default-artwork.jpg"
              },
              {
                id: "2",
                title: "Esempio Brano 2",
                artist: "Artista Esempio",
                album: "Album Esempio",
                duration: 210,
                artwork_path: "/assets/default-artwork.jpg"
              },
              {
                id: "3",
                title: "Esempio Brano 3",
                artist: "Altro Artista",
                album: "Altro Album",
                duration: 240,
                artwork_path: "/assets/default-artwork.jpg"
              }
            ];
            
            let loadedTracks = [];
            
            try {
              // Tenta di caricare le tracce dall'API
              const response = await fetch(tracksURL);
              if (response.ok) {
                const data = await response.json();
                
                // Verifica che i dati ricevuti siano in formato array
                if (Array.isArray(data)) {
                  loadedTracks = data;
                } else if (data && typeof data === 'object') {
                  // Se è un oggetto, controlla se ha una proprietà che contiene le tracce
                  if (data.tracks && Array.isArray(data.tracks)) {
                    loadedTracks = data.tracks;
                  } else if (data.data && Array.isArray(data.data)) {
                    loadedTracks = data.data;
                  } else {
                    // Converte l'oggetto in array se possibile
                    const possibleTracks = Object.values(data).filter(item => 
                      item && typeof item === 'object' && 'title' in item && 'artist' in item
                    );
                    
                    if (possibleTracks.length > 0) {
                      loadedTracks = possibleTracks;
                    } else {
                      throw new Error("Formato dei dati ricevuti non valido");
                    }
                  }
                } else {
                  throw new Error("Formato dei dati ricevuti non valido");
                }
                
                console.log("Tracce caricate dall'API:", loadedTracks.length);
              } else {
                throw new Error("Impossibile caricare le tracce dall'API");
              }
            } catch (apiError) {
              console.warn("Errore nel caricamento tracce dall'API:", apiError.message);
              console.log("Utilizzo tracce di esempio");
              loadedTracks = exampleTracks;
            }
            
            // Verifica finale che loadedTracks sia un array prima di assegnarlo
            if (!Array.isArray(loadedTracks)) {
              console.warn("Il formato dei dati delle tracce non è un array. Utilizzo tracce di esempio.");
              loadedTracks = exampleTracks;
            }
            
            // Assegna alle variabili globali
            tracks = loadedTracks;
            allTracks = [...loadedTracks]; // Copia per riferimento futuro
            
            console.log("Tracce caricate globalmente:", tracks.length);
            
            // Visualizza le tracce nell'interfaccia
            displayTracks(tracks);
            
          } catch (error) {
            console.error("Errore durante il caricamento delle tracce:", error);
            
            // Nascondi il messaggio di caricamento
            const songsLoading = document.getElementById("songsLoading");
            if (songsLoading) {
              songsLoading.style.display = "none";
            }
            
            // Mostra un messaggio di errore
            const songsError = document.getElementById("songsError");
            if (songsError) {
              songsError.style.display = "block";
              songsError.textContent = `Errore nel caricamento delle tracce: ${error.message}`;
            }
            
            // In caso di errore, mostra un messaggio all'utente
            const songsList = document.getElementById("songsList");
            if (songsList) {
              songsList.innerHTML = `<li class="error-message">Errore nel caricamento delle tracce: ${error.message}</li>`;
            }
          }
        }

        // Funzione per gestire il login con username/password
        async function loginWithUsernamePassword() {
          const username = loginUsername.value.trim();
          const password = loginPassword.value.trim();

          if (!username || !password) {
            loginError.textContent = "Inserisci username e password.";
            loginError.style.display = "block";
            return;
          }

          try {
            // Uso l'istanza Shogun per autenticazione
            const result = await window.shogun.login(username, password);

            if (result && result.success === true) {
              loginSuccess.textContent = "Accesso effettuato con successo.";
              loginSuccess.style.display = "block";
              loginError.style.display = "none";

              // Aggiorna UI
              authContainer.style.display = "none";
              appContainer.style.display = "flex";

              // Aggiorna lo stato del server Gun
              updateGunStatus();

              // Aggiorna profilo utente
              updateUserProfile();

              // Inizializza contenuto
              initUserContent();
            } else {
              // Se l'autenticazione non è riuscita, mostra un errore
              loginError.textContent =
                result.error || "Credenziali non valide.";
              loginError.style.display = "block";
              loginSuccess.style.display = "none";
            }
          } catch (error) {
            loginError.textContent =
              "Errore durante l'accesso: " + error.message;
            loginError.style.display = "block";
            loginSuccess.style.display = "none";
          }
        }

        // Funzione per aggiornare lo stato della connessione Gun
        function updateGunStatus() {
          const gunStatus = document.getElementById("gunStatus");
          if (!gunStatus) return;
          
          if (window.shogun && window.shogun.gun) {
            gunStatus.textContent = "Gun.js connesso";
            gunStatus.classList.remove("offline");
            gunStatus.classList.add("online");
          } else {
            gunStatus.textContent = "Gun.js non connesso";
            gunStatus.classList.remove("online");
            gunStatus.classList.add("offline");
          }
        }

        // Funzione per gestire la registrazione con username/password
        async function signupWithUsernamePassword() {
          const username = signupUsername.value.trim();
          const password = signupPassword.value.trim();
          const passwordConfirm = signupPasswordConfirm.value.trim();

          if (!username || !password || !passwordConfirm) {
            signupError.textContent = "Compila tutti i campi.";
            signupError.style.display = "block";
            return;
          }

          if (password !== passwordConfirm) {
            signupError.textContent = "Le password non corrispondono.";
            signupError.style.display = "block";
            return;
          }

          try {
            const result = await window.shogun.signUp(username, password);

            if (result && result.success) {
              signupSuccess.textContent =
                "Registrazione effettuata con successo.";
              signupSuccess.style.display = "block";
              signupError.style.display = "none";

              // Aggiorna UI
              authContainer.style.display = "none";
              appContainer.style.display = "flex";

              // Aggiorna profilo utente
              updateUserProfile();

              // Inizializza contenuto
              initUserContent();
            } else {
              signupError.textContent =
                result.error || "Errore durante la registrazione.";
              signupError.style.display = "block";
            }
          } catch (error) {
            signupError.textContent =
              "Errore durante la registrazione: " + error.message;
            signupError.style.display = "block";
            signupSuccess.style.display = "none";
          }
        }

        // Funzione per gestire il login con WebAuthn
        async function loginWithWebAuthn() {
          try {
            // Verifica il supporto a WebAuthn
            if (!window.shogun.isWebAuthnSupported()) {
              loginError.textContent =
                "WebAuthn non è supportato dal tuo browser";
              loginError.style.display = "block";
              return;
            }

            // Ottieni il valore username dal campo di login
            const username = loginUsername.value.trim();
            if (!username) {
              loginError.textContent =
                "Inserisci un username per accedere con WebAuthn";
              loginError.style.display = "block";
              return;
            }

            // Esegui il login con WebAuthn
            const result = await window.shogun.loginWithWebAuthn(username);

            if (result.success) {
              loginSuccess.textContent =
                "Accesso con WebAuthn effettuato con successo";
              loginSuccess.style.display = "block";
              loginError.style.display = "none";

              // Aggiorna UI
              authContainer.style.display = "none";
              appContainer.style.display = "flex";

              // Aggiorna profilo utente
              updateUserProfile();

              // Inizializza contenuto
              initUserContent();
            } else {
              throw new Error(
                result.error || "Autenticazione WebAuthn fallita"
              );
            }
          } catch (error) {
            console.error("Errore WebAuthn:", error);
            loginError.textContent =
              error.message || "Errore durante l'accesso con WebAuthn";
            loginError.style.display = "block";
            loginSuccess.style.display = "none";
          }
        }

        // Funzione per gestire la registrazione con WebAuthn
        async function signupWithWebAuthn() {
          try {
            // Verifica il supporto a WebAuthn
            if (!window.shogun.isWebAuthnSupported()) {
              signupError.textContent =
                "WebAuthn non è supportato dal tuo browser";
              signupError.style.display = "block";
              return;
            }

            // Ottieni il valore username dal campo di registrazione
            const username = signupUsername.value.trim();
            if (!username) {
              signupError.textContent =
                "Inserisci un username per registrarti con WebAuthn";
              signupError.style.display = "block";
              return;
            }

            // Esegui la registrazione con WebAuthn
            const result = await window.shogun.signUpWithWebAuthn(username);

            if (result.success) {
              signupSuccess.textContent =
                "Registrazione con WebAuthn completata con successo";
              signupSuccess.style.display = "block";
              signupError.style.display = "none";

              // Aggiorna UI
              authContainer.style.display = "none";
              appContainer.style.display = "flex";

              // Aggiorna profilo utente
              updateUserProfile();

              // Inizializza contenuto
              initUserContent();
            } else {
              throw new Error(result.error || "Registrazione WebAuthn fallita");
            }
          } catch (error) {
            console.error("Errore WebAuthn:", error);
            signupError.textContent =
              error.message || "Errore durante la registrazione con WebAuthn";
            signupError.style.display = "block";
            signupSuccess.style.display = "none";
          }
        }

        // Funzione per gestire il login con MetaMask
        async function loginWithMetaMask() {
          try {
            loginError.style.display = "none";
            loginSuccess.style.display = "none";
            
            // Mostra messaggio di caricamento
            loginError.textContent = "Connessione con MetaMask in corso...";
            loginError.style.display = "block";
            loginError.style.color = "#3498db"; // Colore blu per indicare caricamento
            
            // Verifica che MetaMask sia disponibile
            if (!window.ethereum) {
              loginError.textContent =
                "MetaMask non è installato. Installa l'estensione MetaMask per continuare.";
              loginError.style.color = "#e74c3c"; // Torna al rosso per errore
              loginError.style.display = "block";
              return;
            }

            // Ottieni l'indirizzo da MetaMask
            const accounts = await window.ethereum.request({
              method: "eth_requestAccounts",
            });

            if (!accounts || accounts.length === 0) {
              throw new Error("Nessun account trovato in MetaMask");
            }

            loginError.textContent = "Account MetaMask selezionato, autenticazione in corso...";
            const address = accounts[0];

            // Login con MetaMask via Shogun
            try {
              const result = await window.shogun.loginWithMetaMask(address);

              console.log(result);

              if (result && result.success) {
                loginSuccess.textContent =
                  "Accesso con MetaMask effettuato con successo";
                loginSuccess.style.display = "block";
                loginError.style.display = "none";

                // Aggiorna UI
                authContainer.style.display = "none";
                appContainer.style.display = "flex";

                // Aggiorna profilo utente
                updateUserProfile();

                // Inizializza contenuto
                initUserContent();
              } else {
                throw new Error(
                  result.error || "Autenticazione MetaMask fallita"
                );
              }
            } catch (authError) {
              console.error("Errore durante l'autenticazione MetaMask:", authError);
              
              // Verifica se l'errore è correlato al timeout DID
              if (authError.message && authError.message.includes("Timeout")) {
                loginError.textContent = 
                  "Timeout durante la connessione. Il server potrebbe non essere raggiungibile. Riprova più tardi.";
              } else {
                loginError.textContent =
                  authError.message || "Errore durante l'accesso con MetaMask";
              }
              
              loginError.style.color = "#e74c3c"; // Rosso per errore
              loginError.style.display = "block";
              loginSuccess.style.display = "none";
            }
          } catch (error) {
            console.error("Errore MetaMask generale:", error);
            loginError.textContent =
              error.message || "Errore durante l'accesso con MetaMask";
            loginError.style.color = "#e74c3c"; // Rosso per errore
            loginError.style.display = "block";
            loginSuccess.style.display = "none";
          }
        }

        // Funzione per gestire la registrazione con MetaMask
        async function signupWithMetaMask() {
          try {
            signupError.style.display = "none";
            signupSuccess.style.display = "none";
            
            // Mostra messaggio di caricamento
            signupError.textContent = "Connessione con MetaMask in corso...";
            signupError.style.display = "block";
            signupError.style.color = "#3498db"; // Colore blu per indicare caricamento
            
            // Verifica che MetaMask sia disponibile
            if (!window.ethereum) {
              signupError.textContent =
                "MetaMask non è installato. Installa l'estensione MetaMask per continuare.";
              signupError.style.color = "#e74c3c"; // Torna al rosso per errore
              signupError.style.display = "block";
              return;
            }

            // Ottieni l'indirizzo da MetaMask
            const accounts = await window.ethereum.request({
              method: "eth_requestAccounts",
            });

            if (!accounts || accounts.length === 0) {
              throw new Error("Nessun account trovato in MetaMask");
            }

            signupError.textContent = "Account MetaMask selezionato, registrazione in corso...";
            const address = accounts[0];

            // Registrazione con MetaMask via Shogun
            try {
              const result = await window.shogun.signUpWithMetaMask(address);

              if (result && result.success) {
                signupSuccess.textContent =
                  "Registrazione con MetaMask completata con successo";
                signupSuccess.style.display = "block";
                signupError.style.display = "none";

                // Aggiorna UI
                authContainer.style.display = "none";
                appContainer.style.display = "flex";

                // Aggiorna profilo utente
                updateUserProfile();

                // Inizializza contenuto
                initUserContent();
              } else {
                if (
                  result &&
                  result.error &&
                  result.error.includes("already exists")
                ) {
                  signupError.textContent =
                    "Utente già registrato. Prova ad accedere invece.";
                  signupError.style.color = "#e74c3c"; // Rosso per errore
                  signupError.style.display = "block";
                } else {
                  throw new Error(
                    result.error || "Registrazione MetaMask fallita"
                  );
                }
              }
            } catch (authError) {
              console.error("Errore durante la registrazione MetaMask:", authError);
              
              // Verifica se l'errore è correlato al timeout DID
              if (authError.message && authError.message.includes("Timeout")) {
                signupError.textContent = 
                  "Timeout durante la connessione. Il server potrebbe non essere raggiungibile. Riprova più tardi.";
              } else {
                signupError.textContent =
                  authError.message || "Errore durante la registrazione con MetaMask";
              }
              
              signupError.style.color = "#e74c3c"; // Rosso per errore
              signupError.style.display = "block";
              signupSuccess.style.display = "none";
            }
          } catch (error) {
            console.error("Errore MetaMask generale:", error);
            signupError.textContent =
              error.message || "Errore durante la registrazione con MetaMask";
            signupError.style.color = "#e74c3c"; // Rosso per errore
            signupError.style.display = "block";
            signupSuccess.style.display = "none";
          }
        }

        // Gestione dei tab di autenticazione
        authTabs.forEach((tab) => {
          tab.addEventListener("click", () => {
            authTabs.forEach((t) => t.classList.remove("active"));
            tab.classList.add("active");
            const tabName = tab.getAttribute("data-tab");
            if (tabName === "login") {
              loginForm.style.display = "block";
              signupForm.style.display = "none";
            } else {
              loginForm.style.display = "none";
              signupForm.style.display = "block";
            }
          });
        });

        // Gestione del logout
        const logoutBtn = document.getElementById("logoutBtn");
        logoutBtn.addEventListener("click", async () => {
          try {
            await window.shogun.logout();

            // Aggiorna UI
            authContainer.style.display = "flex";
            appContainer.style.display = "none";

            // Reset dati utente
            const userProfileUsername = document.getElementById(
              "userProfileUsername"
            );
            if (userProfileUsername) {
              userProfileUsername.textContent = "Utente";
            }
          } catch (error) {
            console.error("Errore durante il logout:", error);
            alert("Errore durante il logout: " + error.message);
          }
        });

        // Gestione dei pulsanti di autenticazione
        loginButton.addEventListener("click", loginWithUsernamePassword);
        signupButton.addEventListener("click", signupWithUsernamePassword);
        webauthnLoginBtn.addEventListener("click", loginWithWebAuthn);
        webauthnSignupBtn.addEventListener("click", signupWithWebAuthn);
        metamaskLoginBtn.addEventListener("click", loginWithMetaMask);
        metamaskSignupBtn.addEventListener("click", signupWithMetaMask);
      });

      // Funzione per visualizzare le tracce
      function displayTracks(tracks) {
        const songsList = document.getElementById("songsList");
        songsList.innerHTML = "";
        
        // Nascondi il messaggio di caricamento
        document.getElementById("songsLoading").style.display = "none";

        if (!tracks || tracks.length === 0) {
          document.getElementById("songsEmpty").style.display = "block";
          return;
        }

        document.getElementById("songsEmpty").style.display = "none";

        tracks.forEach((track) => {
          const li = document.createElement("li");
          li.className = "song-item";

          // Crea l'HTML per l'artwork
          let artworkHTML = "";
          if (track.artwork_path) {
            let artworkUrl = track.artwork_path;
            if (track.artwork_path.startsWith("/") && track.originUrl) {
              artworkUrl = `${track.originUrl}${track.artwork_path}`;
            } else if (track.artwork_path.startsWith("/")) {
              // Se il percorso inizia con / ma non c'è originUrl, usa il server corrente
              artworkUrl = `${window.location.origin}${track.artwork_path}`;
            }

            artworkHTML = `<img class="artwork" src="${artworkUrl}" alt="${track.title}" onerror="this.parentNode.innerHTML='<div class=\\'artwork-placeholder\\'>♪</div>';" />`;
          } else {
            artworkHTML = `<div class="artwork-placeholder">♪</div>`;
          }

          li.innerHTML = `
            ${artworkHTML}
            <div class="song-info">
              <div class="song-title">${track.title}</div>
              <div class="song-artist">${track.artist}</div>
            </div>
            <div class="song-actions">
              <button class="play-button" data-track-id="${
                track.id
              }">Play</button>
              <button class="favorite-button" data-track-id="${track.id}">${
            isFavorite(track.id) ? "★" : "☆"
          }</button>
              <button class="options-button" data-track-id="${
                track.id
              }">⋮</button>
            </div>
          `;
          songsList.appendChild(li);
        });

        // Aggiungi eventi ai pulsanti
        const playButtons = document.querySelectorAll(".play-button");
        const favoriteButtons = document.querySelectorAll(".favorite-button");
        const optionsButtons = document.querySelectorAll(".options-button");

        playButtons.forEach((button) => {
          button.addEventListener("click", () => {
            const trackId = button.getAttribute("data-track-id");
            playSong(trackId);
          });
        });

        favoriteButtons.forEach((button) => {
          button.addEventListener("click", () => {
            const trackId = button.getAttribute("data-track-id");
            const track = getTrackById(trackId);
            toggleFavorite(trackId, "songs", track ? track.title : "Brano sconosciuto");
          });
        });

        optionsButtons.forEach((button) => {
          button.addEventListener("click", () => {
            const trackId = button.getAttribute("data-track-id");
            showTrackOptions(trackId);
          });
        });
      }

      // Funzione per aggiungere/rimuovere un elemento dai preferiti
      function toggleFavorite(id, type, name) {
        if (typeof window.toggleFavorite === 'function') {
          return window.toggleFavorite(id, type, name);
        } else if (window.FavoritesManager && typeof window.FavoritesManager.toggleFavorite === 'function') {
          return window.FavoritesManager.toggleFavorite(id, type, name);
        } else {
          console.error('Nessun sistema di preferiti disponibile');
          return false;
        }
      }

      // Funzione per verificare se una traccia è nei preferiti
      function isFavorite(trackId) {
        if (!userFavorites || !userFavorites.songs || !Array.isArray(userFavorites.songs)) {
          return false;
        }
        
        // Converti in stringa per confronto uniforme
        const trackIdStr = String(trackId);
        return userFavorites.songs.some(id => String(id) === trackIdStr);
      }

      // Funzione per visualizzare i preferiti
      function displayFavorites(type = "songs") {
        console.log("Visualizzazione preferiti di tipo:", type);

        // Mostra il tab Preferiti
        const favoritesTab = document.querySelector(
          '.content-tab[data-tab="favorites"]'
        );
        if (favoritesTab) {
          console.log("Click sul tab Preferiti");
          favoritesTab.click();
        }

        // Aggiorna l'intestazione
        let sectionTitle = "";
        switch (type) {
          case "songs":
            sectionTitle = "Brani preferiti";
            break;
          case "artists":
            sectionTitle = "Artisti preferiti";
            break;
          case "albums":
            sectionTitle = "Album preferiti";
            break;
        }

        const favoriteSectionTitle = document.getElementById(
          "currentFavoriteSection"
        );
        if (favoriteSectionTitle) {
          favoriteSectionTitle.textContent = sectionTitle;
        }

        // Nascondi tutte le sezioni di preferiti
        document.getElementById("favoriteSongsSection").style.display = "none";
        document.getElementById("favoriteArtistsSection").style.display =
          "none";
        document.getElementById("favoriteAlbumsSection").style.display = "none";

        // Mostra la sezione richiesta
        const sectionId = `favorite${
          type.charAt(0).toUpperCase() + type.slice(1)
        }Section`;
        const sectionToShow = document.getElementById(sectionId);
        if (sectionToShow) {
          sectionToShow.style.display = "block";
        }

        // Mostra i preferiti specifici in base al tipo
        switch (type) {
          case "songs":
            displayFavoriteSongs();
            break;
          case "artists":
            // Implementare la visualizzazione degli artisti preferiti
            break;
          case "albums":
            // Implementare la visualizzazione degli album preferiti
            break;
        }
      }

      // Funzione per visualizzare i brani preferiti
      function displayFavoriteSongs() {
        console.log("Visualizzazione brani preferiti...");
        
        // Ottieni il container della lista
        const favoriteSongsList = document.getElementById("favoriteSongsList");
        if (!favoriteSongsList) {
          console.error("Elemento favoriteSongsList non trovato nel DOM");
          return;
        }
        
        // Mostra loader
        const loadingElement = document.getElementById("favoriteSongsLoading");
        if (loadingElement) {
          loadingElement.style.display = "block";
        }
        
        // Svuota la lista attuale
        favoriteSongsList.innerHTML = "";

        // Verifica se ci sono preferiti da visualizzare
        if (!window.userFavorites) {
          window.userFavorites = { songs: [], artists: [], albums: [] };
        }
        
        console.log("Brani preferiti:", window.userFavorites.songs);
        
        if (!window.userFavorites.songs || !Array.isArray(window.userFavorites.songs) || window.userFavorites.songs.length === 0) {
          console.log("Nessun brano preferito da visualizzare");
          const emptyElement = document.getElementById("favoriteSongsEmpty");
          if (emptyElement) {
            emptyElement.style.display = "block";
          }
          if (loadingElement) {
            loadingElement.style.display = "none";
          }
          return;
        }

        // Nascondi il messaggio "vuoto"
        const emptyElement = document.getElementById("favoriteSongsEmpty");
        if (emptyElement) {
          emptyElement.style.display = "none";
        }

        // Elabora ciascun brano preferito
        let displayedTracks = 0;
        window.userFavorites.songs.forEach((favorite) => {
          // Gestisci sia il caso in cui favorite sia un oggetto che un ID
          const trackId = typeof favorite === 'object' ? favorite.id : favorite;
          
          // Tenta di ottenere la traccia
          const track = getTrackById(trackId);
          
          if (track) {
            // Crea elemento nella lista
            const li = document.createElement("li");
            li.className = "song-item";
            
            // Usa la funzione getArtworkHTML per gestire correttamente l'artwork
            const artworkHTML = getArtworkHTML(track);
            
            // Popola l'elemento della lista
            li.innerHTML = `
              <div class="artwork-container">${artworkHTML}</div>
              <div class="song-info">
                <div class="song-title">${track.title || 'Senza titolo'}</div>
                <div class="song-artist">${track.artist || 'Artista sconosciuto'}</div>
              </div>
              <div class="song-actions">
                <button class="play-btn" data-id="${track.id}"><i class="fas fa-play"></i></button>
                <button class="favorite-btn" data-id="${track.id}" data-type="songs" data-favorite="true">
                  <i class="fas fa-heart"></i>
                </button>
              </div>
            `;
            
            // Aggiungi alla lista
            favoriteSongsList.appendChild(li);
            displayedTracks++;
          } else {
            console.warn("Brano con ID", trackId, "non trovato nella libreria");
          }
        });
        
        // Nascondi il loader
        if (loadingElement) {
          loadingElement.style.display = "none";
        }
        
        if (displayedTracks === 0) {
          // Se non è stato visualizzato nessun brano, mostra il messaggio vuoto
          if (emptyElement) {
            emptyElement.style.display = "block";
          }
          console.log("Nessun brano preferito trovato nella libreria");
        } else {
          console.log("Visualizzati", displayedTracks, "brani preferiti");
          
          // Aggiungi evento ai pulsanti
          const playButtons = favoriteSongsList.querySelectorAll(".play-btn");
          playButtons.forEach(btn => {
            btn.addEventListener("click", function() {
              const id = this.getAttribute("data-id");
              playSong(id);
            });
          });
          
          const favoriteButtons = favoriteSongsList.querySelectorAll(".favorite-btn");
          favoriteButtons.forEach(btn => {
            btn.addEventListener("click", function() {
              const id = this.getAttribute("data-id");
              const type = this.getAttribute("data-type");
              const track = getTrackById(id);
              const name = track ? track.title : "Brano sconosciuto";
              
              // Usa FavoritesManager se disponibile
              if (window.FavoritesManager) {
                window.FavoritesManager.toggleFavorite(id, type, name);
              } else {
                toggleFavorite(id, type, name);
              }
              
              // Aggiorna subito la visualizzazione
              setTimeout(() => displayFavoriteSongs(), 100);
            });
          });
        }
      }

      // Funzione per ottenere una traccia dal suo ID
      function getTrackById(trackId) {
        console.log("Cercando traccia con ID:", trackId);
        
        // Debug disponibilità dati
        console.log("Stato variabili tracce globali:");
        console.log("- window.tracks:", window.tracks ? "disponibile" : "non disponibile");
        console.log("- window.allTracks:", window.allTracks ? `disponibile (${Object.keys(window.allTracks || {}).length} tracce)` : "non disponibile");
        console.log("- inMemoryDB:", window.inMemoryDB ? `disponibile (${Object.keys(window.inMemoryDB || {}).length} tracce)` : "non disponibile");
        
        // Verifica nel database locale (inMemoryDB)
        if (window.inMemoryDB && window.inMemoryDB[trackId]) {
          console.log("Traccia trovata in inMemoryDB:", window.inMemoryDB[trackId]);
          return window.inMemoryDB[trackId];
        }
        
        // Controlla se abbiamo una lista di tracce disponibile
        if (typeof tracks !== "undefined" && Array.isArray(tracks) && tracks.length > 0) {
          console.log("Numero di tracce disponibili:", tracks.length);
          const foundTrack = tracks.find((t) => String(t.id) === String(trackId));
          if (foundTrack) {
            console.log("Traccia trovata nell'array tracks:", foundTrack);
            return foundTrack;
          }
        } else {
          console.log("Array 'tracks' non disponibile o vuoto");
        }

        // Prova a cercare in allTracks se disponibile
        if (typeof allTracks !== "undefined" && Array.isArray(allTracks) && allTracks.length > 0) {
          console.log("Numero di tracce in allTracks:", allTracks.length);
          const foundTrack = allTracks.find((t) => String(t.id) === String(trackId));
          if (foundTrack) {
            console.log("Traccia trovata nell'array allTracks:", foundTrack);
            return foundTrack;
          }
        } else {
          console.log("Array 'allTracks' non disponibile o vuoto");
        }
        
        // Tenta di leggere da local_tracks_db.json
        console.log("Tentativo di recupero dal database locale...");
        
        // Opzione 1: Recupero dal localStorage se disponibile
        try {
          const localDB = localStorage.getItem('local_tracks_db');
          if (localDB) {
            const parsedDB = JSON.parse(localDB);
            if (parsedDB && parsedDB[trackId]) {
              console.log("Traccia trovata in localStorage:", parsedDB[trackId]);
              return parsedDB[trackId];
            }
          }
        } catch (e) {
          console.error("Errore nel recupero dal localStorage:", e);
        }
        
        // Fallback: Leggi direttamente dal file JSON (via Ajax)
        try {
          console.log("Tentativo di lettura diretta del database locale...");
          let foundTrack = null;
          
          // Usiamo una richiesta sincrona (solo per il fallback)
          const xhr = new XMLHttpRequest();
          xhr.open('GET', 'local_tracks_db.json', false); // sincrona
          xhr.send();
          
          if (xhr.status === 200) {
            const dbData = JSON.parse(xhr.responseText);
            if (dbData && dbData[trackId]) {
              console.log("Traccia trovata tramite Ajax:", dbData[trackId]);
              foundTrack = dbData[trackId];
              
              // Aggiorna inMemoryDB per future richieste
              if (!window.inMemoryDB) window.inMemoryDB = {};
              window.inMemoryDB[trackId] = foundTrack;
              
              return foundTrack;
            }
          }
        } catch (e) {
          console.error("Errore nell'accesso diretto al file JSON:", e);
        }

        // Se la traccia non è stata trovata, crea un placeholder
        console.log("Traccia con ID " + trackId + " non trovata, uso placeholder");
        
        // Verifica se possiamo ottenere info dal server
        console.log("Tentativo di recupero info traccia dal server...");
        
        // Effettua una richiesta al server per ottenere dettagli (async)
        fetch(`/api/track/${trackId}`)
          .then(response => {
            if (!response.ok) throw new Error('Risposta non valida');
            return response.json();
          })
          .then(data => {
            console.log("Dati traccia recuperati dal server:", data);
            if (data && data.id === trackId) {
              // Aggiorna l'inMemoryDB
              if (!window.inMemoryDB) window.inMemoryDB = {};
              window.inMemoryDB[trackId] = data;
              
              // Se stiamo ancora riproducendo questa traccia, aggiorna il player
              if (window.currentTrackId === trackId) {
                console.log("Riproduzione traccia con dati aggiornati");
                playSong(data);
              }
            }
          })
          .catch(err => {
            console.error("Errore nel recupero dati traccia dal server:", err);
          });
        
        // Crea un placeholder in attesa della risposta del server
        return {
          id: trackId,
          title: "Brano mancante",
          artist: "Artista sconosciuto",
          album: "Album sconosciuto",
          duration: 0,
          timestamp: Date.now(),
          audio_path: null, // Nessun percorso audio valido
          artwork_path: null,
          placeholder: true
        };
      }
      // Funzione per mostrare le opzioni di una traccia
      function showTrackOptions(trackId) {
        console.log("Mostrando opzioni per la traccia:", trackId);
        
        // Verifico se esiste già un menu dropdown
        let dropdown = document.querySelector(".track-options-dropdown");
        if (dropdown) {
          dropdown.remove();
        }

        // Trova il pulsante delle opzioni cliccato - prima cerca con la classe options-button
        let optionsButton = document.querySelector(
          `.options-button[data-track-id="${trackId}"]`
        );
        
        // Se non trovato, cerca con la classe options-btn
        if (!optionsButton) {
          optionsButton = document.querySelector(
            `.options-btn[data-id="${trackId}"]`
          );
        }
        
        if (!optionsButton) {
          console.error("Pulsante opzioni non trovato per la traccia", trackId);
          return;
        }

        // Prima di mostrare le opzioni, forza il caricamento delle playlist
        // per assicurarti che siano disponibili nell'elenco
        forceLoadPlaylists().then(playlists => {
          console.log("Playlist caricate forzatamente:", playlists);
          // Ora procedi a mostrare il dropdown con le playlist aggiornate
          createAndShowOptionsDropdown(trackId, optionsButton);
        }).catch(err => {
          console.error("Errore nel caricamento forzato delle playlist:", err);
          // In caso di errore, comunque mostra il dropdown con quello che abbiamo
          createAndShowOptionsDropdown(trackId, optionsButton);
        });
      }

      // Nuova funzione per forzare il caricamento delle playlist
      function forceLoadPlaylists() {
        return new Promise((resolve, reject) => {
          console.log("Caricamento forzato delle playlist...");
          
          // Prova prima tramite PlaylistManager
          if (window.PlaylistManager && typeof window.PlaylistManager.loadPlaylists === 'function') {
            window.PlaylistManager.loadPlaylists()
              .then(playlists => {
                console.log(`Caricate ${playlists.length} playlist tramite PlaylistManager`);
                
                // Assicurati che window.userPlaylists sia aggiornato
                window.userPlaylists = playlists;
                
                resolve(playlists);
              })
              .catch(err => {
                console.error("Errore nel caricamento playlist da PlaylistManager:", err);
                
                // Prova a caricare da localStorage come fallback
                try {
                  const localData = localStorage.getItem('local_playlists');
                  if (localData) {
                    const parsedPlaylists = JSON.parse(localData);
                    console.log(`Recuperate ${parsedPlaylists.length} playlist da localStorage`);
                    window.userPlaylists = parsedPlaylists;
                    resolve(parsedPlaylists);
                  } else {
                    console.warn("Nessuna playlist trovata in localStorage");
                    window.userPlaylists = [];
                    resolve([]);
                  }
                } catch (e) {
                  console.error("Errore nel recupero playlist da localStorage:", e);
                  window.userPlaylists = [];
                  reject(e);
                }
              });
          } else {
            console.warn("PlaylistManager non disponibile per caricare playlist");
            
            // Prova direttamente da localStorage
            try {
              const localData = localStorage.getItem('local_playlists');
              if (localData) {
                const parsedPlaylists = JSON.parse(localData);
                console.log(`Recuperate ${parsedPlaylists.length} playlist da localStorage (fallback diretto)`);
                window.userPlaylists = parsedPlaylists;
                resolve(parsedPlaylists);
              } else {
                console.warn("Nessuna playlist trovata in localStorage");
                window.userPlaylists = [];
                resolve([]);
              }
            } catch (e) {
              console.error("Errore nel recupero playlist da localStorage:", e);
              window.userPlaylists = [];
              reject(e);
            }
          }
        });
      }

      // Funzione per creare e mostrare il dropdown delle opzioni
      function createAndShowOptionsDropdown(trackId, optionsButton) {
        // Crea il menu dropdown
        dropdown = document.createElement("div");
        dropdown.className = "track-options-dropdown";
        dropdown.style.position = "fixed"; // Usiamo position fixed per evitare problemi con lo scroll
        dropdown.style.backgroundColor = "#333";
        dropdown.style.borderRadius = "4px";
        dropdown.style.boxShadow = "0 2px 10px rgba(0,0,0,0.3)";
        dropdown.style.zIndex = "1000"; // Assicuriamoci che sia sopra altri elementi
        dropdown.style.minWidth = "200px";
        // Nascondiamo inizialmente per evitare flash
        dropdown.style.visibility = "hidden";

        // Aggiungi opzioni al dropdown
        dropdown.innerHTML = `
          <div style="padding: 10px; border-bottom: 1px solid #444;">
            <div style="color: #CCC; font-size: 14px;">Aggiungi a playlist</div>
          </div>
        `;

        // Crea lista delle playlist
        const playlistsList = document.createElement("div");
        playlistsList.style.maxHeight = "200px";
        playlistsList.style.overflowY = "auto";

        // Usa window.userPlaylists che dovrebbe essere aggiornato dalla funzione forceLoadPlaylists
        if (!window.userPlaylists || window.userPlaylists.length === 0) {
          playlistsList.innerHTML = `
            <div style="padding: 10px; color: #999; font-style: italic;">
              Nessuna playlist disponibile
            </div>
          `;
          console.warn("Nessuna playlist disponibile per il menu", window.userPlaylists);
        } else {
          console.log("Playlist disponibili per il menu:", window.userPlaylists.length);
          
          // Prima di mostrare le playlist, controlliamo che siano valide
          const validPlaylists = window.userPlaylists.filter(p => p && p.id && p.name);
          console.log("Playlist valide per il menu:", validPlaylists.length);
          
          validPlaylists.forEach((playlist) => {
            console.log("Creando elemento per playlist:", playlist.name);
            const playlistItem = document.createElement("div");
            playlistItem.style.padding = "8px 16px";
            playlistItem.style.cursor = "pointer";
            playlistItem.style.transition = "background-color 0.2s";
            playlistItem.textContent = playlist.name;

            // Evidenzia se il mouse passa sopra
            playlistItem.addEventListener("mouseover", () => {
              playlistItem.style.backgroundColor = "#444";
            });
            playlistItem.addEventListener("mouseout", () => {
              playlistItem.style.backgroundColor = "transparent";
            });

            // Evento click per aggiungere alla playlist
            playlistItem.addEventListener("click", () => {
              console.log(`Click su playlist '${playlist.name}' per aggiungere traccia ${trackId}`);
              addToPlaylist(trackId, playlist.id)
                .then(result => {
                  console.log("Risultato addToPlaylist:", result);
                  if (result) {
                    alert(`Brano aggiunto alla playlist "${playlist.name}"`);
                  }
                })
                .catch(err => {
                  console.error("Errore nell'aggiunta alla playlist:", err);
                })
                .finally(() => {
                  dropdown.remove();
                });
            });

            playlistsList.appendChild(playlistItem);
          });
        }

        dropdown.appendChild(playlistsList);

        // Aggiungi opzione per creare nuova playlist
        const createPlaylistOption = document.createElement("div");
        createPlaylistOption.style.padding = "10px";
        createPlaylistOption.style.borderTop = "1px solid #444";

        const createPlaylistForm = document.createElement("div");
        createPlaylistForm.style.display = "flex";
        createPlaylistForm.style.gap = "5px";

        const playlistNameInput = document.createElement("input");
        playlistNameInput.type = "text";
        playlistNameInput.placeholder = "Nuova playlist...";
        playlistNameInput.style.flex = "1";
        playlistNameInput.style.padding = "5px";
        playlistNameInput.style.backgroundColor = "#444";
        playlistNameInput.style.border = "none";
        playlistNameInput.style.borderRadius = "3px";
        playlistNameInput.style.color = "#FFF";

        const createBtn = document.createElement("button");
        createBtn.textContent = "Crea";
        createBtn.style.padding = "5px 10px";
        createBtn.style.backgroundColor = "#1DB954";
        createBtn.style.color = "#000";
        createBtn.style.border = "none";
        createBtn.style.borderRadius = "3px";
        createBtn.style.cursor = "pointer";

        createBtn.addEventListener("click", () => {
          const playlistName = playlistNameInput.value.trim();
          if (playlistName) {
            console.log("Creazione nuova playlist:", playlistName);
            createPlaylist(playlistName)
              .then(newPlaylist => {
                if (newPlaylist) {
                  console.log("Playlist creata, ora aggiungo la traccia:", trackId);
                  // Piccolo ritardo per garantire che GunDB abbia tempo di elaborare il salvataggio
                  setTimeout(() => {
                    addToPlaylist(trackId, newPlaylist.id)
                      .then(result => {
                        if (result) {
                          alert(`Brano aggiunto alla nuova playlist "${playlistName}"`);
                        }
                      })
                      .catch(err => {
                        console.error("Errore nell'aggiunta alla playlist:", err);
                      });
                  }, 200);
                }
              })
              .catch(error => {
                console.error("Errore nella creazione della playlist:", error);
              })
              .finally(() => {
                dropdown.remove();
              });
          }
        });

        // Anche premendo Enter si crea la playlist
        playlistNameInput.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
            const playlistName = playlistNameInput.value.trim();
            if (playlistName) {
              console.log("Creazione nuova playlist (via Enter):", playlistName);
              createPlaylist(playlistName)
                .then(newPlaylist => {
                  if (newPlaylist) {
                    console.log("Playlist creata, ora aggiungo la traccia:", trackId);
                    // Piccolo ritardo per garantire che GunDB abbia tempo di elaborare il salvataggio
                    setTimeout(() => {
                      addToPlaylist(trackId, newPlaylist.id)
                        .then(result => {
                          if (result) {
                            alert(`Brano aggiunto alla nuova playlist "${playlistName}"`);
                          }
                        })
                        .catch(err => {
                          console.error("Errore nell'aggiunta alla playlist:", err);
                        });
                    }, 200);
                  }
                })
                .catch(error => {
                  console.error("Errore nella creazione della playlist:", error);
                })
                .finally(() => {
                  dropdown.remove();
                });
            }
          }
        });

        createPlaylistForm.appendChild(playlistNameInput);
        createPlaylistForm.appendChild(createBtn);
        createPlaylistOption.appendChild(createPlaylistForm);
        dropdown.appendChild(createPlaylistOption);

        // Aggiungi il dropdown al documento
        document.body.appendChild(dropdown);
        
        // Ora che il dropdown è nel DOM e ha tutte le sue dimensioni, possiamo posizionarlo correttamente
        const rect = optionsButton.getBoundingClientRect();
        
        // Posiziona il dropdown sotto il pulsante
        dropdown.style.top = `${rect.bottom + 5}px`;
        
        // Allinea il dropdown a destra del pulsante, tenendo conto del suo offset
        const rightAlign = rect.right; // Bordo destro del pulsante
        const dropdownWidth = dropdown.offsetWidth;
        
        // Posiziona il dropdown in modo che il suo bordo destro sia allineato con il bordo destro del pulsante
        dropdown.style.left = `${rightAlign - dropdownWidth}px`;
        
        // Verifica se il dropdown esce dallo schermo a sinistra
        if (parseInt(dropdown.style.left) < 10) {
            dropdown.style.left = '10px';
        }
        
        // Verifica se il dropdown esce dallo schermo a destra
        if (rightAlign > window.innerWidth - 10) {
            dropdown.style.left = `${window.innerWidth - dropdownWidth - 10}px`;
        }
        
        // Rendiamo visibile il dropdown dopo averlo posizionato
        dropdown.style.visibility = "visible";

        // Chiudi il dropdown quando si clicca altrove
        setTimeout(() => {
          const closeDropdown = (e) => {
            if (!dropdown.contains(e.target) && e.target !== optionsButton) {
              dropdown.remove();
              document.removeEventListener("click", closeDropdown);
            }
          };
          document.addEventListener("click", closeDropdown);
        }, 0);
      }

      // Funzione per aggiungere una traccia a una playlist
      function addToPlaylist(trackId, playlistId) {
        console.log(`Aggiunta traccia ${trackId} alla playlist ${playlistId}`);
        
        // Controllo preliminare
        if (!trackId || !playlistId) {
          console.error("ID traccia o playlist mancante");
          return false;
        }
        
        // Assicurati che PlaylistManager sia disponibile usando il fallback se necessario
        const manager = ensurePlaylistManager();
        
        // Ottieni la traccia completa dal database
        const track = getTrackById(trackId);
        if (!track) {
          console.error("Traccia non trovata:", trackId);
          alert("Errore: Traccia non trovata");
          return false;
        }
        
        // Usa PlaylistManager per aggiungere la traccia
        return manager.addTrackToPlaylist(playlistId, track)
          .then(result => {
            console.log(`Traccia ${trackId} aggiunta alla playlist ${playlistId}:`, result);
            
            // Se siamo nella vista playlist, aggiorna la visualizzazione
            if (currentPlaylistId === playlistId) {
              displayPlaylistTracks(playlistId);
            }
            
            return true;
          })
          .catch(error => {
            console.error("Errore nell'aggiunta della traccia alla playlist:", error);
            alert("Errore durante l'aggiunta della traccia alla playlist");
            return false;
          });
      }

      // Funzione per riprodurre una traccia
      function playSong(trackData) {
        console.log("Riproduzione traccia:", trackData);
        
        // Salva l'ID della traccia corrente
        if (typeof trackData === "string") {
          window.currentTrackId = trackData;
        } else if (trackData && trackData.id) {
          window.currentTrackId = trackData.id;
        }

        // Controllo più approfondito di WaveSurfer
        if (typeof WaveSurfer === "undefined") {
          console.error("WaveSurfer non è disponibile");
          alert("Impossibile riprodurre: il player audio non è disponibile. Ricarica la pagina.");
          
          // Tentativo di caricamento dinamico
          const script = document.createElement("script");
          script.src = "https://cdnjs.cloudflare.com/ajax/libs/wavesurfer.js/6.6.3/wavesurfer.min.js";
          script.onload = function() {
            console.log("WaveSurfer caricato con successo. Riprova la riproduzione.");
            setTimeout(() => alert("Player audio caricato. Riprova la riproduzione."), 1000);
          };
          script.onerror = () => console.error("Impossibile caricare WaveSurfer dinamicamente");
          document.head.appendChild(script);
          return;
        }

        // Se abbiamo un oggetto track, usiamo quello, altrimenti cerchiamo per ID
        let track = trackData;
        if (typeof trackData === "string") {
          track = getTrackById(trackData);
          if (!track) {
            console.error("Traccia non trovata:", trackData);
            alert("Traccia non trovata nel database. Ricarica la pagina.");
            return;
          }
        }
        
        // Verifica se è un placeholder senza audio
        if (track.placeholder === true || !track.audio_path) {
          console.warn("Tentativo di riprodurre un placeholder senza audio:", track);
          alert(`La traccia "${track.title}" non è disponibile. I dati stanno venendo caricati dal server. Riprova tra qualche secondo.`);
          
          // Tenta di ricaricare i dati dal server
          loadAllTracks().then(() => {
            console.log("Dati tracce ricaricati, tentativo di trovare la traccia richiesta");
            // Dopo il caricamento, verifica se la traccia è ora disponibile
            setTimeout(() => {
              const freshTrack = getTrackById(track.id);
              if (freshTrack && !freshTrack.placeholder && freshTrack.audio_path) {
                console.log("Traccia ora disponibile dopo ricaricamento:", freshTrack);
                alert("Traccia disponibile, riprova la riproduzione");
              }
            }, 1000);
          });
          
          return;
        }

        // Aggiorna UI player
        const nowPlaying = document.getElementById("nowPlaying");
        const nowPlayingTitle = document.getElementById("nowPlayingTitle");
        const nowPlayingArtist = document.getElementById("nowPlayingArtist");
        const nowPlayingArtwork = document.getElementById("nowPlayingArtwork");

        if (nowPlaying) nowPlaying.style.display = "flex";
        if (nowPlayingTitle)
          nowPlayingTitle.textContent = track.title || "Senza titolo";
        if (nowPlayingArtist)
          nowPlayingArtist.textContent = track.artist || "Artista sconosciuto";

        if (nowPlayingArtwork) {
          if (track.artwork_path) {
            nowPlayingArtwork.innerHTML = "";
            const img = document.createElement("img");

            // Usa l'originUrl se disponibile, altrimenti fallback
            let artworkPath = track.artwork_path;
            if (track.artwork_path.startsWith("/") && track.originUrl) {
              artworkPath = `${track.originUrl}${track.artwork_path}`;
            } else if (track.artwork_path.startsWith("/")) {
              // Se il percorso inizia con / ma non c'è originUrl, usa il server corrente
              artworkPath = `${window.location.origin}${track.artwork_path}`;
            }

            console.log("Caricamento artwork da:", artworkPath);
            img.src = artworkPath;
            img.className = "artwork";
            img.alt = "Artwork";
            img.onerror = function () {
              console.error("Errore nel caricamento dell'artwork");
              nowPlayingArtwork.innerHTML = "♪";
              nowPlayingArtwork.className = "artwork-placeholder";
            };
            nowPlayingArtwork.className = "";
            nowPlayingArtwork.appendChild(img);
          } else {
            nowPlayingArtwork.innerHTML = "♪";
            nowPlayingArtwork.className = "artwork-placeholder";
          }
        }

        // Ottieni il percorso audio
        let audioPath = track.audio_path;

        // Se il percorso non inizia con http/https, costruisci l'URL assoluto
        if (audioPath && !audioPath.startsWith("http")) {
          const baseUrl = track.originUrl || window.location.origin;
          audioPath = `${baseUrl}${audioPath}`;
        }

        console.log(`Caricamento audio da: ${audioPath}`);

        // Controllo di sicurezza: non caricare se il percorso è null o vuoto
        if (!audioPath) {
          console.error(
            "Tentativo di caricare una traccia senza percorso audio valido:",
            track
          );
          alert(
            `Errore: Impossibile trovare il file audio per la traccia "${track.title}".`
          );
          return;
        }

        try {
          // Inizializza wavesurfer se non esiste
          if (!window.wavesurfer) {
            window.wavesurfer = WaveSurfer.create({
              container: "#waveform",
              waveColor: "#4caf50",
              progressColor: "#2196f3",
              cursorColor: "#333",
              barWidth: 2,
              barRadius: 3,
              cursorWidth: 1,
              height: 80,
              barGap: 3,
              responsive: true,
              backend: 'MediaElement'  // Usa MediaElement come backend alternativo
            });

            // Inizializza gli eventi di wavesurfer
            window.wavesurfer.on("ready", function () {
              console.log("WaveSurfer pronto");
              const playBtn = document.getElementById("playBtn");
              const pauseBtn = document.getElementById("pauseBtn");
              if (playBtn) playBtn.disabled = false;
              if (pauseBtn) pauseBtn.disabled = false;

              // Avvia la riproduzione automaticamente
              window.wavesurfer.play();

              // Aggiorna l'interfaccia
              if (playBtn) playBtn.style.display = "none";
              if (pauseBtn) pauseBtn.style.display = "inline-block";
            });

            window.wavesurfer.on("finish", function () {
              console.log("Riproduzione completata");
              const playBtn = document.getElementById("playBtn");
              const pauseBtn = document.getElementById("pauseBtn");
              if (playBtn) playBtn.style.display = "inline-block";
              if (pauseBtn) pauseBtn.style.display = "none";
            });

            window.wavesurfer.on("error", function (err) {
              console.error("Errore WaveSurfer:", err);
              alert("Errore durante il caricamento dell'audio. Dettaglio: " + (err.message || err));
            });
          }

          // Carica e riproduce l'audio
          console.log("Caricamento audio:", audioPath);
          window.wavesurfer.load(audioPath);
        } catch (err) {
          console.error("Errore nell'inizializzazione del player WaveSurfer:", err);
          alert("Errore del player: " + (err.message || err));
        }
      }

      // Funzione per gestire i tab del contenuto
      function setupContentTabs() {
        console.log("Inizializzazione tab di contenuto...");
        const contentTabs = document.querySelectorAll(".content-tab");
        const tabContents = document.querySelectorAll(".tab-content");

        console.log("Tab trovati:", contentTabs.length);
        console.log("Contenuti tab trovati:", tabContents.length);

        contentTabs.forEach((tab) => {
          const tabName = tab.getAttribute("data-tab");
          console.log("Aggiungo listener al tab:", tabName);

          tab.addEventListener("click", () => {
            const clickedTabName = tab.getAttribute("data-tab");
            console.log("Tab cliccato:", clickedTabName);

            // Rimuovi active da tutti i tab
            contentTabs.forEach((t) => {
              t.classList.remove("active");
            });

            // Aggiungi active al tab cliccato
            tab.classList.add("active");

            // Nascondi tutti i contenuti
            tabContents.forEach((content) => {
              content.classList.remove("active");
              console.log("Nascosto contenuto:", content.id);
            });

            // Mostra il contenuto corrispondente
            const targetContent = document.getElementById(`${clickedTabName}-tab`);
            if (targetContent) {
              targetContent.classList.add("active");
              console.log("Mostrato contenuto:", targetContent.id);

              // Chiama la funzione di visualizzazione DOPO aver mostrato il contenuto
              if (clickedTabName === "favorites") {
                // Chiama displayFavorites per il tipo di default (songs)
                // displayFavorites gestirà la visualizzazione della sezione corretta
                displayFavorites("songs");
              } else if (clickedTabName === "playlists") {
                // Se è il tab playlist, mostra la playlist corrente o un messaggio
                if (currentPlaylistId) {
                  displayPlaylistTracks(currentPlaylistId);
                } else if (userPlaylists && userPlaylists.length > 0) {
                  // Mostra la prima playlist se nessuna è selezionata
                displayPlaylistTracks(userPlaylists[0].id);
                } else {
                  // Nessuna playlist da mostrare
                  document.getElementById("playlistEmpty").style.display = "block";
                  document.getElementById("playlistEmpty").textContent = "Nessuna playlist disponibile.";
                }
              } else if (clickedTabName === "all-tracks") {
                // Assicurati che la libreria sia visualizzata
                if (typeof displayLibrarySongs === 'function') {
                    displayLibrarySongs();
                }
              }
            } else {
              console.error("Contenuto non trovato per il tab:", clickedTabName);
            }
          });
        });

        // Attiva il tab di default (all-tracks)
        const defaultTab = document.querySelector('.content-tab[data-tab="all-tracks"]');
        const defaultContent = document.getElementById('all-tracks-tab');
        if (defaultTab && defaultContent) {
          defaultTab.classList.add('active');
          defaultContent.classList.add('active');
          console.log("Tab di default 'all-tracks' attivato");
        } else {
          console.warn("Impossibile attivare il tab di default");
        }
      }

      // Inizializza i tab del contenuto
      setupContentTabs();

      // Funzione per visualizzare le playlist
      function displayPlaylists() {
        console.log("Visualizzazione playlist dell'utente");
        const playlistsMenu = document.getElementById("playlistsMenu");
        
        if (!playlistsMenu) {
          console.error("Elemento playlistsMenu non trovato nel DOM");
          return;
        }
        
        // Svuota il menu delle playlist
        playlistsMenu.innerHTML = "";
        
        // Assicurati che PlaylistManager sia disponibile usando il fallback
        const manager = ensurePlaylistManager();
        
        // Carica sempre le playlist aggiornate prima di visualizzarle
        manager.loadPlaylists()
          .then(playlists => {
            // Aggiorna l'array globale
            window.userPlaylists = playlists;
            console.log(`Playlists ricaricate per la visualizzazione: ${playlists.length}`, playlists);
            
            // Verifica se ci sono playlist da visualizzare
            if (!playlists || playlists.length === 0) {
              console.log("Nessuna playlist disponibile");
              playlistsMenu.innerHTML =
                '<div class="playlist-item">Nessuna playlist disponibile</div>';
              return;
            }
            
            console.log(`Visualizzazione di ${playlists.length} playlist:`, playlists);
            
            // Visualizza ogni playlist
            playlists.forEach((playlist) => {
              if (!playlist || !playlist.name) {
                console.warn("Playlist non valida o senza nome:", playlist);
                return; // Salta questa playlist
              }
              
              const playlistItem = document.createElement("div");
              playlistItem.className = "playlist-item";
              
              // Evidenzia la playlist attiva
              if (currentPlaylistId === playlist.id) {
                playlistItem.classList.add("active");
              }
              
              const trackCount = playlist.tracks && Array.isArray(playlist.tracks) ? playlist.tracks.length : 0;
              
              playlistItem.innerHTML = `
                <div class="playlist-name">
                  ${playlist.name}
                  <span class="count-badge">${trackCount}</span>
                </div>
                <div class="playlist-actions">
                  <button class="playlist-small-button delete-playlist" title="Elimina playlist">×</button>
                </div>
              `;
              
              // Click sulla playlist
              playlistItem.querySelector(".playlist-name").addEventListener("click", () => {
                console.log(`Click su playlist: ${playlist.name} (ID: ${playlist.id})`);
                displayPlaylistTracks(playlist.id);
              });
              
              // Click per eliminare la playlist
              playlistItem
                .querySelector(".delete-playlist")
                .addEventListener("click", (e) => {
                  e.stopPropagation();
                  if (
                    confirm(
                      `Vuoi davvero eliminare la playlist "${playlist.name}"?`
                    )
                  ) {
                    deletePlaylist(playlist.id);
                  }
                });
              
              playlistsMenu.appendChild(playlistItem);
            });
          })
          .catch(error => {
            console.error("Errore nel caricamento delle playlist per la visualizzazione:", error);
            playlistsMenu.innerHTML =
              '<div class="playlist-item">Errore nel caricamento delle playlist</div>';
          });
      }

      // Funzione per visualizzare i brani di una playlist
      function displayPlaylistTracks(playlistId) {
        console.log("Visualizzazione tracce della playlist:", playlistId);

        // Variabile per tenere traccia della playlist corrente
        currentPlaylistId = playlistId;

        // Aggiorna il tab playlists
        document.querySelector('.content-tab[data-tab="playlists"]').click();

        // Prima di cercare la playlist, ricarica le playlist dall'origine
        const manager = ensurePlaylistManager();
        manager.loadPlaylists()
          .then(playlists => {
            // Aggiorna l'array globale
            window.userPlaylists = playlists;
            console.log(`Playlists ricaricate per il display: ${playlists.length}`, playlists);
            
            // Ora cerca la playlist usando i dati aggiornati
            const playlist = userPlaylists.find((p) => p.id === playlistId);
            if (!playlist) {
              console.error("Playlist non trovata:", playlistId);
              // Mostra un messaggio all'utente
              document.getElementById("playlistInfo").style.display = "none";
              document.getElementById("playlistEmpty").style.display = "block";
              document.getElementById("playlistEmpty").textContent = "Playlist non trovata";
              return;
            }

            // Aggiorna interfaccia
            document.getElementById("currentPlaylistName").textContent = playlist.name;
            document.getElementById("playlistInfo").style.display = "block";
            document.getElementById("playlistEmpty").style.display = "none";

            // Assicurati che l'array delle tracce esista
            if (!playlist.tracks || !Array.isArray(playlist.tracks)) {
              playlist.tracks = [];
              console.log("Inizializzato array tracce vuoto per la playlist");
            }

            // Aggiorna conteggio tracce
            const trackCount = playlist.tracks.length;
            document.getElementById("playlistTrackCount").textContent = `${trackCount} brani`;
            
            console.log(`Playlist contiene ${trackCount} tracce:`, playlist.tracks);

            // Calcola durata totale (se disponibile l'informazione)
            let totalDuration = 0;
            if (playlist.tracks && playlist.tracks.length > 0) {
              playlist.tracks.forEach((trackId) => {
                const track = getTrackById(trackId);
                if (track && track.duration) {
                  totalDuration += track.duration;
                }
              });
            }

            let durationText = "";
            if (totalDuration > 0) {
              const minutes = Math.floor(totalDuration / 60);
              durationText = `${minutes} min`;
            } else {
              durationText = "Durata sconosciuta";
            }
            document.getElementById("playlistDuration").textContent = durationText;

            // Mostra le tracce
            const playlistSongsList = document.getElementById("playlistSongsList");
            playlistSongsList.innerHTML = "";

            if (!playlist.tracks || playlist.tracks.length === 0) {
              document.getElementById("playlistEmpty").style.display = "block";
              document.getElementById("playlistEmpty").textContent = "Questa playlist è vuota";
              return;
            }

            // Recupera le tracce complete in base agli ID
            const playlistTracks = [];
            
            // Converti tutti gli ID in stringhe per uniformità
            const trackIds = playlist.tracks.map(id => String(id));
            console.log("Track IDs nella playlist:", trackIds);
            
            trackIds.forEach((trackId) => {
              console.log("Cercando traccia con ID:", trackId);
              const track = getTrackById(trackId);
              if (track) {
                console.log("Traccia trovata:", track.title);
                playlistTracks.push(track);
              } else {
                console.warn(`Traccia con ID ${trackId} non trovata`);
              }
            });

            // Se non ci sono tracce valide, mostra un messaggio
            if (playlistTracks.length === 0) {
              document.getElementById("playlistEmpty").style.display = "block";
              document.getElementById("playlistEmpty").textContent = "Nessuna traccia disponibile in questa playlist";
              return;
            }

            console.log(`Visualizzando ${playlistTracks.length} tracce nella playlist`);

            // Visualizza le tracce
            playlistTracks.forEach((track) => {
              const li = document.createElement("li");
              li.className = "song-item";
              li.setAttribute("data-id", track.id);

              let artworkHTML = "";
              if (track.artwork_path) {
                let artworkUrl = track.artwork_path;
                if (track.artwork_path.startsWith("/") && track.originUrl) {
                  artworkUrl = track.originUrl + track.artwork_path;
                } else if (track.artwork_path.startsWith("/")) {
                  artworkUrl = `${window.location.origin}${track.artwork_path}`;
                }
                artworkHTML = `<img class="artwork" src="${artworkUrl}" alt="${track.title}" onerror="this.innerHTML='<div class=\\'artwork-placeholder\\'>♪</div>';" />`;
              } else {
                artworkHTML = `<div class="artwork-placeholder">♪</div>`;
              }

              li.innerHTML = `
                ${artworkHTML}
                <div class="song-info">
                  <div class="song-title">${track.title}</div>
                  <div class="song-artist">${track.artist}</div>
                </div>
                <div class="song-actions">
                  <button class="play-button" data-track-id="${track.id}">Play</button>
                  <button class="remove-track-button" data-track-id="${track.id}" data-playlist-id="${playlistId}">Rimuovi</button>
                  <button class="favorite-button" data-track-id="${track.id}">${isFavorite(track.id) ? "★" : "☆"}</button>
                </div>
              `;

              playlistSongsList.appendChild(li);
            });

            // Aggiungi eventi ai pulsanti
            playlistSongsList.querySelectorAll(".play-button").forEach((button) => {
              button.addEventListener("click", () => {
                const trackId = button.getAttribute("data-track-id");
                playSong(trackId);
              });
            });

            playlistSongsList.querySelectorAll(".remove-track-button").forEach((button) => {
              button.addEventListener("click", () => {
                const trackId = button.getAttribute("data-track-id");
                const playlistId = button.getAttribute("data-playlist-id");
                if (confirm("Vuoi rimuovere questo brano dalla playlist?")) {
                  removeTrackFromPlaylist(trackId, playlistId);
                }
              });
            });

            playlistSongsList.querySelectorAll(".favorite-button").forEach((button) => {
              button.addEventListener("click", () => {
                const trackId = button.getAttribute("data-track-id");
                const track = getTrackById(trackId);
                toggleFavorite(trackId, "songs", track ? track.title : "Brano sconosciuto");
              });
            });
          })
          .catch(error => {
            console.error("Errore nel caricamento delle playlist per la visualizzazione:", error);
            // Mostra un messaggio all'utente
            document.getElementById("playlistInfo").style.display = "none";
            document.getElementById("playlistEmpty").style.display = "block";
            document.getElementById("playlistEmpty").textContent = "Errore nel caricamento della playlist";
          });
      }

      // Funzione per eliminare una playlist
      function deletePlaylist(playlistId) {
        console.log("Eliminazione playlist:", playlistId);
        
        // Assicurati che PlaylistManager sia disponibile usando il fallback se necessario
        const manager = ensurePlaylistManager();
        
        // Usa PlaylistManager per eliminare la playlist
        return manager.deletePlaylist(playlistId)
          .then(result => {
            console.log(`Playlist ${playlistId} eliminata:`, result);
            
            // Resetta la playlist corrente se necessario
            if (currentPlaylistId === playlistId) {
              currentPlaylistId = null;
              
              // Nascondi le informazioni della playlist
              document.getElementById("playlistInfo").style.display = "none";
              document.getElementById("playlistEmpty").style.display = "block";
              document.getElementById("playlistEmpty").textContent = "Seleziona una playlist";
              document.getElementById("playlistSongsList").innerHTML = "";
            }
            
            // Aggiorna l'interfaccia
            displayPlaylists();
            
            console.log("Playlist eliminata con successo");
            return true;
          })
          .catch(error => {
            console.error("Errore nell'eliminazione della playlist:", error);
            alert("Errore durante l'eliminazione della playlist");
            return false;
          });
      }

      // Funzione per rimuovere una traccia da una playlist
      function removeTrackFromPlaylist(trackId, playlistId) {
        console.log(`Rimozione traccia ${trackId} dalla playlist ${playlistId}`);
        
        // Controllo preliminare
        if (!trackId || !playlistId) {
          console.error("ID traccia o playlist mancante");
          return false;
        }
        
        // Assicurati che PlaylistManager sia disponibile usando il fallback se necessario
        const manager = ensurePlaylistManager();
        
        // Usa PlaylistManager per rimuovere la traccia
        return manager.removeTrackFromPlaylist(playlistId, trackId)
          .then(result => {
            console.log(`Traccia ${trackId} rimossa dalla playlist ${playlistId}:`, result);
            
            // Aggiorna la visualizzazione se necessario
            if (currentPlaylistId === playlistId) {
              displayPlaylistTracks(playlistId);
            }
            
            return true;
          })
          .catch(error => {
            console.error("Errore nella rimozione della traccia dalla playlist:", error);
            alert("Errore durante la rimozione della traccia dalla playlist");
            return false;
          });
      }

      // Funzione per creare una nuova playlist
      function createPlaylist(playlistName) {
        if (!playlistName) {
          console.error("Nome playlist non valido");
          return null;
        }
        
        console.log("Creazione nuova playlist:", playlistName);
        
        // Assicurati che PlaylistManager sia disponibile usando il fallback se necessario
        const manager = ensurePlaylistManager();
        
        // Usa PlaylistManager per creare la playlist
        return manager.createPlaylist(playlistName)
          .then(newPlaylist => {
            console.log("Playlist creata tramite API:", newPlaylist);
            
            // Forza il caricamento delle playlist per aggiornare il riferimento globale
            setTimeout(() => {
              forceLoadPlaylists().then(playlists => {
                console.log(`Playlists ricaricate dopo creazione. Totale: ${playlists.length}`);
                
                // Aggiorna l'interfaccia
                displayPlaylists();
                
                // Visualizza la nuova playlist
                displayPlaylistTracks(newPlaylist.id);
              });
            }, 300);
            
            return newPlaylist;
          })
          .catch(error => {
            console.error("Errore durante la creazione della playlist:", error);
            alert("Errore durante la creazione della playlist");
            return null;
          });
      }

      // Funzione per salvare le playlist dell'utente
      function saveUserPlaylists() {
        // Salva le playlist in GunDB
        saveUserPlaylistsToGun();
      }

      // Funzione per caricare le playlist dell'utente da Gun.js
      function loadUserPlaylistsFromGun() {
        return new Promise((resolve, reject) => {
          console.log("Caricamento playlist da PlaylistManager...");
          
          // Assicurati che PlaylistManager sia disponibile usando il fallback se necessario
          const manager = ensurePlaylistManager();
          
          // Usa PlaylistManager per caricare le playlist
          manager.loadPlaylists()
            .then(playlists => {
              console.log(`Caricate ${playlists.length} playlist tramite PlaylistManager`);
              
              // Aggiorna l'array globale
              window.userPlaylists = playlists;
              
              resolve(playlists);
            })
            .catch(error => {
              console.error("Errore nel caricamento delle playlist:", error);
              
              // Inizializza con un array vuoto in caso di errore
              window.userPlaylists = [];
              
              reject(error);
            });
        });
      }

      // Funzione per salvare le playlist in Gun.js
      function saveUserPlaylistsToGun() {
        console.log("Salvataggio playlist tramite PlaylistManager...");
        
        // Assicurati che PlaylistManager sia disponibile usando il fallback se necessario
        const manager = ensurePlaylistManager();
        
        // Verifica che userPlaylists esista
        if (!window.userPlaylists) {
          console.warn("Nessuna playlist da salvare");
          return Promise.resolve(false);
        }
        
        // Usa PlaylistManager per salvare le playlist
        return manager.savePlaylists(window.userPlaylists)
          .then(result => {
            console.log("Playlist salvate con successo tramite PlaylistManager");
            return result;
          })
          .catch(error => {
            console.error("Errore durante il salvataggio delle playlist:", error);
            throw error;
          });
      }

      // Funzione per caricare i preferiti dell'utente da Gun.js
      function loadUserFavoritesFromGun() {
        return new Promise((resolve, reject) => {
          console.log("Caricamento preferiti da Gun.js...");
          
          if (!window.shogun || !window.shogun.gun) {
            console.error("loadUserFavoritesFromGun: Gun.js non disponibile");
            reject(new Error("Gun.js non disponibile"));
            return;
          }
          
          // Verifica autenticazione o caricamento come utente generico
          const isAuthenticated = window.shogun.isLoggedIn && window.shogun.isLoggedIn();
          
          try {
            // Inizializza l'oggetto dei preferiti se non esiste
            if (!window.userFavorites) {
              window.userFavorites = { songs: [], artists: [], albums: [] };
            }
            
            // Tenta il caricamento diretto da Gun.js
            checkDirectFavoritesData()
              .then(success => {
                if (success) {
                  console.log("Preferiti caricati con successo da Gun.js");
                  resolve(window.userFavorites);
                } else {
                  console.log("Nessun dato preferiti trovato in Gun.js. Inizializzazione preferiti vuoti.");
                  // Non carica più da localStorage, risolve con l'oggetto vuoto o quello già esistente
                      resolve(window.userFavorites);
                }
              })
              .catch(err => {
                console.error("Errore nel caricamento preferiti da Gun.js:", err);
                // Non carica da localStorage in caso di errore, risolve con l'oggetto vuoto o esistente
                    resolve(window.userFavorites);
              });
          } catch (error) {
            console.error("Errore generale nel caricamento preferiti:", error);
            reject(error);
          }
        });
      }
      
      // // Funzione di supporto per salvare i preferiti in localStorage - NON PIÙ USATA
      // function saveUserFavoritesToLocalStorage() { ... }

      // Carica le tracce all'avvio
      document.addEventListener("DOMContentLoaded", function() {
        // Iniziamo controllando se abbiamo già dati in localStorage
        try {
          const localDB = localStorage.getItem('local_tracks_db');
          if (localDB) {
            const parsedDB = JSON.parse(localDB);
            const trackCount = Object.keys(parsedDB).length;
            console.log(`Caricate ${trackCount} tracce da localStorage`);
            
            // Popola inMemoryDB
            window.inMemoryDB = parsedDB;
            
            // Crea array tracks per compatibilità
            window.tracks = Object.values(parsedDB);
            window.allTracks = window.tracks;
          } else {
            console.log("Nessun dato trovato in localStorage");
            // Inizializza comunque gli array vuoti
            window.tracks = [];
            window.allTracks = [];
            window.inMemoryDB = {};
          }
        } catch (e) {
          console.error("Errore nel caricamento dei dati da localStorage:", e);
          // Inizializza gli array vuoti anche in caso di errore
          window.tracks = [];
          window.allTracks = [];
          window.inMemoryDB = {};
        }
        
        // Carica i dati dal server comunque
        loadAllTracks()
          .then(() => {
            console.log("Dati tracce inizializzati dal server");
            // Aggiorna la visualizzazione delle tracce nella libreria
            if (typeof displayLibrarySongs === 'function') {
              displayLibrarySongs();
            }
          })
          .catch(() => console.error("Errore nell'inizializzazione dei dati tracce"));
      });

      // Handler per risposta dall'API del server
      function handleTracksApiResponse(data) {
        console.log(`Ricevute ${data.length} tracce dal server API`);
        
        // Aggiorna gli array globali
        window.allTracks = data;
        window.tracks = data;
        
        // Aggiorna inMemoryDB
        if (!window.inMemoryDB) window.inMemoryDB = {};
        data.forEach(track => {
          window.inMemoryDB[track.id] = track;
        });
        
        // Salva in localStorage per uso futuro
        try {
          const simplifiedData = {};
          data.forEach(track => {
            simplifiedData[track.id] = track;
          });
          localStorage.setItem('local_tracks_db', JSON.stringify(simplifiedData));
          console.log("Tracce salvate in localStorage");
        } catch (e) {
          console.warn("Impossibile salvare in localStorage:", e);
        }
        
        return data;
      }

      // Funzione per caricare tutte le tracce dal server
      function loadAllTracks() {
        console.log("Caricamento di tutte le tracce dal server...");
        return new Promise((resolve, reject) => {
          fetch('/api/tracks')
            .then(response => {
              if (!response.ok) {
                console.error(`Errore nella risposta API: ${response.status} ${response.statusText}`);
                throw new Error('Errore nel caricamento delle tracce');
              }
              return response.json();
            })
            .then(data => {
              console.log(`API ha restituito ${Array.isArray(data) ? data.length : 'oggetto non array'} elementi`);
              
              // Se data è un oggetto con proprietà tracks, usa quello
              if (data && data.tracks && Array.isArray(data.tracks)) {
                data = data.tracks;
              } else if (!Array.isArray(data)) {
                // Se data non è un array, prova a convertirlo in array
                if (typeof data === 'object') {
                  data = Object.values(data);
                  console.log(`Convertito oggetto in array di ${data.length} elementi`);
                } else {
                  console.error('Dati inaspettati dall\'API:', data);
                  data = []; // Array vuoto come fallback
                }
              }
              
              // Usando la funzione handler per elaborare la risposta
              data = handleTracksApiResponse(data);
              
              // Log dettagliato delle prime 3 tracce per debug
              if (data.length > 0) {
                console.log("Esempio prima traccia:", JSON.stringify(data[0]));
                if (data.length > 1) console.log("Esempio seconda traccia:", JSON.stringify(data[1]));
                if (data.length > 2) console.log("Esempio terza traccia:", JSON.stringify(data[2]));
              }
              
              resolve(data);
            })
            .catch(error => {
              console.error("Errore nel caricamento delle tracce:", error);
              reject(error);
            });
        });
      }

      // Funzione per visualizzare le tracce nella libreria
      function displayLibrarySongs() {
        const songsList = document.getElementById('songsList');
        const songsLoading = document.getElementById('songsLoading');
        const songsError = document.getElementById('songsError');
        const songsEmpty = document.getElementById('songsEmpty');
        
        // Nascondi tutti gli stati
        if (songsLoading) songsLoading.style.display = 'none';
        if (songsError) songsError.style.display = 'none';
        if (songsEmpty) songsEmpty.style.display = 'none';
        
        // Verifica se abbiamo tracce da visualizzare
        if (!window.tracks || !Array.isArray(window.tracks) || window.tracks.length === 0) {
          console.warn("Nessuna traccia disponibile per la visualizzazione");
          if (songsEmpty) songsEmpty.style.display = 'block';
          return;
        }
        
        // Pulisci la lista esistente
        if (songsList) {
          songsList.innerHTML = '';
          
          // Visualizza ogni traccia
          window.tracks.forEach(track => {
            // Crea l'elemento della traccia
            const trackItem = document.createElement('li');
            trackItem.className = 'song-item';
            
            // Usa la funzione getArtworkHTML per l'artwork
            const artworkHtml = getArtworkHTML(track);
            
            // Crea un ID sicuro per la traccia (usa l'ID o genera uno basato sul titolo)
            const trackId = track.id || `track_${track.title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}`;
            
            // Ottieni lo stato del preferito
            const isTrackFavorite = window.FavoritesManager && window.FavoritesManager.isFavorite ? 
                                    window.FavoritesManager.isFavorite(trackId, 'songs') : false;
            const favoriteIcon = isTrackFavorite ? 'fas fa-heart' : 'far fa-heart';
            
            // Costruisci l'HTML dell'elemento
            trackItem.innerHTML = `
              <div class="artwork-container">${artworkHtml}</div>
              <div class="song-info">
                <div class="song-title">${track.title || 'Titolo sconosciuto'}</div>
                <div class="song-artist">${track.artist || 'Artista sconosciuto'}</div>
              </div>
              <div class="song-actions">
                <button class="play-track-btn" data-id="${trackId}">
                  <i class="fas fa-play"></i>
                </button>
                <button class="favorite-btn" data-id="${trackId}" data-type="songs" data-name="${track.title?.replace(/'/g, "\'") || 'Brano sconosciuto'}" data-favorite="${isTrackFavorite}">
                  <i class="${favoriteIcon}"></i>
                </button>
                <button class="options-btn" data-id="${trackId}" data-track-id="${trackId}">⋮</button>
              </div>
            `;
            
            // Aggiungi alla lista
            songsList.appendChild(trackItem);
          });
          
          // Aggiungi eventi ai pulsanti dopo aver aggiunto tutti gli elementi
          addEventListenersToLibraryItems();
          
          // Aggiorna lo stato dei pulsanti preferiti
          if (window.FavoritesManager) {
            window.FavoritesManager.updateAllFavoriteButtons();
          }
          
          console.log(`Visualizzate ${window.tracks.length} tracce nella libreria`);
        } else {
          console.error("Elemento songsList non trovato nel DOM");
        }
      }

      // Funzione separata per aggiungere eventi ai pulsanti della libreria
      function addEventListenersToLibraryItems() {
        const songsList = document.getElementById('songsList');
        if (!songsList) return;
        
        // Aggiungi eventi ai pulsanti Play
        songsList.querySelectorAll('.play-track-btn').forEach(btn => {
          btn.addEventListener('click', function() {
            const trackId = this.getAttribute('data-id');
            playSong(trackId);
          });
        });
        
        // Aggiungi eventi ai pulsanti Preferiti
        songsList.querySelectorAll('.favorite-btn').forEach(btn => {
          btn.addEventListener('click', function() {
            const trackId = this.getAttribute('data-id');
            const type = this.getAttribute('data-type');
            const name = this.getAttribute('data-name');
            toggleFavorite(trackId, type, name);
          });
        });
        
        // Aggiungi eventi ai pulsanti Opzioni
        songsList.querySelectorAll('.options-btn').forEach(btn => {
          btn.addEventListener('click', function() {
            const trackId = this.getAttribute('data-id');
            // Aggiungiamo anche l'attributo data-track-id per compatibilità
            this.setAttribute('data-track-id', trackId);
            showTrackOptions(trackId);
          });
        });
      }

      // Funzione per gestire il player audio
      function setupAudioPlayer() {
        const audioPlayer = document.getElementById('audioPlayer');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const progressBar = document.getElementById('progressBar');
        const volumeControl = document.getElementById('volumeControl');
        const currentTimeDisplay = document.getElementById('currentTime');
        const totalTimeDisplay = document.getElementById('totalTime');
        
        if (!audioPlayer || !playPauseBtn) {
          console.error("Elementi del player audio non trovati");
          return;
        }
        
        // Inizializza lo stato del player
        console.log("Inizializzazione player audio...");
        
        // Variabile di stato per tracciare lo stato attuale
        let isPlaying = false;
        
        // Gestione Play/Pause
        playPauseBtn.addEventListener('click', function() {
          console.log("Click su play/pause. Stato audio:", isPlaying ? "in riproduzione" : "in pausa");
          
          if (!audioPlayer.src || audioPlayer.src === window.location.href) {
            console.log("Nessuna traccia caricata");
            return;
          }
          
          if (isPlaying) {
            // Se è in riproduzione, metti in pausa
            audioPlayer.pause();
            playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
            isPlaying = false;
            console.log("Click su play/pause. Stato audio: in pausa");
          } else {
            // Se è in pausa, inizia la riproduzione
            const playPromise = audioPlayer.play();
            if (playPromise !== undefined) {
              playPromise.then(() => {
                playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                isPlaying = true;
                console.log("Click su play/pause. Stato audio: in riproduzione");
              }).catch(err => {
                console.error("Errore nella riproduzione:", err);
                playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                isPlaying = false;
              });
            }
          }
        });
        
        // Ascolta gli eventi dell'audio player
        audioPlayer.addEventListener('play', function() {
          playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
          isPlaying = true;
          console.log("Evento play rilevato");
        });
        
        audioPlayer.addEventListener('pause', function() {
          playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
          isPlaying = false;
          console.log("Evento pause rilevato");
        });
        
        audioPlayer.addEventListener('ended', function() {
          playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
          isPlaying = false;
          console.log("Riproduzione terminata");
        });
        
        audioPlayer.addEventListener('loadstart', function() {
          console.log("Inizio caricamento traccia");
        });
        
        audioPlayer.addEventListener('error', function(e) {
          console.error("Errore nel player:", e);
          playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
          isPlaying = false;
        });
        
        // Aggiorna la progress bar
        audioPlayer.addEventListener('timeupdate', function() {
          if (audioPlayer.duration) {
            const percentage = (audioPlayer.currentTime / audioPlayer.duration) * 100;
            progressBar.value = percentage;
            
            // Aggiorna il tempo corrente
            const currentMinutes = Math.floor(audioPlayer.currentTime / 60);
            const currentSeconds = Math.floor(audioPlayer.currentTime % 60);
            currentTimeDisplay.textContent = `${currentMinutes}:${currentSeconds < 10 ? '0' : ''}${currentSeconds}`;
          }
        });

        // Gestione del click sulla progress bar
        progressBar.addEventListener('input', function() {
          if (audioPlayer.duration) {
            const seekTime = (progressBar.value / 100) * audioPlayer.duration;
            audioPlayer.currentTime = seekTime;
          }
        });

        // Gestione del volume
        if (volumeControl) {
          volumeControl.addEventListener('input', function() {
            audioPlayer.volume = volumeControl.value;
          });
          
          // Imposta il volume iniziale
          audioPlayer.volume = volumeControl.value;
        }

        // Gestione del caricamento della durata totale
        audioPlayer.addEventListener('loadedmetadata', function() {
          if (audioPlayer.duration) {
            console.log("Metadata audio caricati, durata:", audioPlayer.duration);
            const totalMinutes = Math.floor(audioPlayer.duration / 60);
            const totalSeconds = Math.floor(audioPlayer.duration % 60);
            totalTimeDisplay.textContent = `${totalMinutes}:${totalSeconds < 10 ? '0' : ''}${totalSeconds}`;
          } else {
            console.log("Durata non disponibile");
            totalTimeDisplay.textContent = "0:00";
          }
        });

        console.log("Player audio inizializzato");
      }

      // Funzione per avviare la riproduzione di una canzone
      function playSong(trackId) {
        console.log("Avvio riproduzione traccia:", trackId);
        
        // Trova la traccia in base all'ID
        const track = window.tracks.find(t => t.id === trackId);
        if (!track) {
          console.error("Traccia non trovata:", trackId);
          return;
        }
        
        const audioPlayer = document.getElementById('audioPlayer');
        const playPauseBtn = document.getElementById('playPauseBtn');
        
        if (!audioPlayer) {
          console.error("Elemento audio non trovato nel DOM");
          return;
        }
        
        // Prima ferma la riproduzione corrente (se presente)
        audioPlayer.pause();
        
        // Resetta il tempo per evitare che si senta l'audio precedente
        audioPlayer.currentTime = 0;
        
        // Normalizza il percorso audio
        const audioPath = track.audio_path;
        const normalizedPath = audioPath.startsWith('/') ? audioPath : '/' + audioPath;
        
        // Imposta il file audio
        console.log("Impostazione file audio:", normalizedPath);
        audioPlayer.src = normalizedPath;
        
        // Aggiorna l'interfaccia con le info della traccia corrente
        document.getElementById('currentTrackTitle').textContent = track.title || "Senza titolo";
        document.getElementById('currentTrackArtist').textContent = track.artist || "Artista sconosciuto";
        
        // Imposta l'artwork
        const artworkContainer = document.getElementById('currentTrackArtwork');
        if (artworkContainer) {
          // Usa normalizeArtworkPath per ottenere il percorso corretto
          const artworkPath = normalizeArtworkPath(track.artwork_path, track.id);
          
          if (artworkPath) {
            artworkContainer.innerHTML = `
              <img src="${artworkPath}" alt="${track.title}" 
                onerror="this.onerror=null; this.outerHTML='<div class=\'artwork-placeholder\'>♪</div>'">
            `;
          } else {
            artworkContainer.innerHTML = `<div class="artwork-placeholder">♪</div>`;
          }
        }
        
        // Mostra il player se è nascosto
        document.getElementById('playerControls').style.display = 'flex';
        
        // Avvia la riproduzione
        const playPromise = audioPlayer.play();
        if (playPromise !== undefined) {
          playPromise
            .then(() => {
              console.log("Riproduzione avviata con successo");
              // Aggiorna il pulsante play/pause
              if (playPauseBtn) {
                playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
              }
              
              // Salva la traccia corrente
              window.currentTrack = track;
            })
            .catch(err => {
              console.error("Errore nell'avvio della riproduzione:", err);
              if (playPauseBtn) {
                playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
              }
            });
        }
      }

      // Inizializzazione all'avvio
      document.addEventListener('DOMContentLoaded', function() {
        console.log("DOM completamente caricato");
        
        // Inizializza i tab di contenuto
        setupContentTabs();
        
        // Inizializza il player audio
        setupAudioPlayer();
        
        // Inizializza i tab dei preferiti
        setupFavoriteTabs();
        
        // Verifica che loadTracks sia disponibile prima di chiamarla
        if (typeof loadTracks === 'function') {
          loadTracks();
        } else {
          console.warn("Funzione loadTracks non disponibile");
          // Aggiungiamo un controllo ritardato per vedere se la funzione diventa disponibile
          setTimeout(function() {
            if (typeof loadTracks === 'function') {
              loadTracks();
            } else {
              console.error("Funzione loadTracks non disponibile dopo il timeout");
            }
          }, 2000);
        }
      });

      // Creazione di un FavoritesManager di fallback se non disponibile
      document.addEventListener("DOMContentLoaded", function() {
        setTimeout(function() {
          if (typeof window.FavoritesManager === 'undefined') {
            console.log("FavoritesManager non disponibile dopo il caricamento di player.js");
            
            // Non creiamo più un FavoritesManager di fallback qui
            // Ora viene gestito correttamente in player.js con Gun.js
            console.log("In attesa dell'inizializzazione corretta di FavoritesManager da player.js");
          }
        }, 1000); // Controlla dopo 1 secondo
      });

      // Funzione per normalizzare il percorso di un artwork
      function normalizeArtworkPath(artwork_path, trackId) {
        // Se non c'è alcun percorso per l'artwork, generane uno basato sull'ID della traccia
        if (!artwork_path && trackId) {
          const possiblePaths = [
            `/uploads/${trackId}-artwork.png`,
            `/uploads/${trackId}-artwork.jpg`,
            `/uploads/${trackId}.png`,
            `/uploads/${trackId}.jpg`
          ];
          
          // Controlla quali file esistono
          for (const path of possiblePaths) {
            // Per sicurezza, al momento torniamo solo il primo percorso generato
            // (poi verrà gestito l'errore se il file non esiste)
            return path;
          }
        }
        
        // Se è già un URL completo, ritorna com'è
        if (artwork_path && (artwork_path.startsWith('http://') || artwork_path.startsWith('https://'))) {
          return artwork_path;
        }
        
        // Se è un percorso relativo, assicurati che inizi con /
        if (artwork_path && !artwork_path.startsWith('/')) {
          artwork_path = '/' + artwork_path;
        }
        
        return artwork_path;
      }

      // Funzione per ottenere HTML dell'artwork con fallback appropriato
      function getArtworkHTML(track, size = 'normal') {
        // Determina la classe CSS in base alla dimensione
        const sizeClass = size === 'small' ? 'artwork-small' : 'artwork';
        
        // Normalizza il percorso dell'artwork se esiste
        const artworkPath = normalizeArtworkPath(track.artwork_path, track.id);
        
        // Se non c'è un percorso per l'artwork, usa il placeholder
        if (!artworkPath) {
          return `<div class="${sizeClass} artwork-placeholder">♪</div>`;
        }
        
        // Altrimenti, crea un tag immagine con gestione dell'errore
        return `<img src="${artworkPath}" alt="${track.title || 'Brano'}" class="${sizeClass}" 
                  onerror="this.onerror=null; this.outerHTML='<div class=\'${sizeClass} artwork-placeholder\'>♪</div>'">`;
      }

      // Gestione dei tab nella sezione preferiti
      function setupFavoriteTabs() {
        console.log("Inizializzazione tabs dei preferiti...");
        const favoriteTypeButtons = document.querySelectorAll('[data-favorite-type]');
        
        if (!favoriteTypeButtons || favoriteTypeButtons.length === 0) {
          console.warn("Nessun pulsante per i tipi di preferiti trovato");
          return;
        }
        
        console.log(`Trovati ${favoriteTypeButtons.length} pulsanti per i tab preferiti`);
        
        favoriteTypeButtons.forEach(button => {
          button.addEventListener('click', function() {
            const favoriteType = this.getAttribute('data-favorite-type');
            console.log(`Click su tab preferiti: ${favoriteType}`);
            
            // Rimuovi la classe active da tutti i pulsanti
            favoriteTypeButtons.forEach(btn => btn.classList.remove('active'));
            
            // Aggiungi la classe active al pulsante cliccato
            this.classList.add('active');
            
            // Mostra i preferiti del tipo selezionato
            displayFavorites(favoriteType);
          });
        });
        
        console.log("Tab preferiti inizializzati");
      }

      // Inizializzazione generale al caricamento del documento
      document.addEventListener('DOMContentLoaded', function() {
        console.log("DOM completamente caricato");
        
        // Inizializzazione in ordine di priorità
        try {
          // 1. Setup dei contenuti tab (deve venire prima degli altri)
          if (typeof setupContentTabs === 'function') {
            setupContentTabs();
          } else {
            console.error("Funzione setupContentTabs non disponibile");
          }
          
          // 2. Setup del player audio
          if (typeof setupAudioPlayer === 'function') {
            setupAudioPlayer();
          } else {
            console.error("Funzione setupAudioPlayer non disponibile");
          }
          
          // 3. Setup dei tab dei preferiti 
          if (typeof setupFavoriteTabs === 'function') {
            setupFavoriteTabs();
          } else {
            console.error("Funzione setupFavoriteTabs non disponibile");
          }
          
          // 4. Caricamento delle tracce (deve venire dopo il setup delle tab)
          if (typeof loadTracks === 'function') {
            loadTracks();
          } else {
            console.error("Funzione loadTracks non disponibile");
          }
          
          console.log("Inizializzazione completata con successo");
        } catch (error) {
          console.error("Errore durante l'inizializzazione:", error);
        }
      });

      // Carica script necessari in modo asincrono
      function loadShogunCore() {
        console.log("Caricamento Shogun Core...");
        
        // Tenta diversi percorsi possibili
        const possiblePaths = [
          "../js/shogun-core.js",  // Relativo alla cartella UI
          "js/shogun-core.js",     // Relativo alla root del server
          "/shogun-music/js/shogun-core.js", // Percorso assoluto
          "/js/shogun-core.js"     // Percorso alternativo
        ];
        
        // Prima carica lo script shogun-core.js
        const script = document.createElement("script");
        script.src = possiblePaths[0]; // Proviamo prima con il percorso relativo
        script.type = "text/javascript";
        script.async = false; // Carica in modo sincrono
        
        // Gestione errori
        script.onerror = function() {
          console.error("Errore nel caricamento di " + script.src);
          // Tenta percorsi alternativi
          tryLoadAlternatives(possiblePaths, 1);
        };
        
        // Carica anche player.js quando shogun-core.js è caricato
        script.onload = function() {
          console.log("shogun-core.js caricato con successo");
          loadPlayerJs("../");
          loadWaveSurfer();
        };
        
        document.head.appendChild(script);
      }
      
      // Carica player.js
      function loadPlayerJs(basePath) {
        console.log("Caricamento player.js con base path:", basePath);
        
        const playerScript = document.createElement("script");
        playerScript.src = basePath + "js/player.js";
        playerScript.type = "text/javascript";
        playerScript.async = false; // Carica in modo sincrono
        
        playerScript.onerror = function() {
          console.error("Errore nel caricamento di " + playerScript.src);
          // Tenta con percorsi alternativi
          const altPaths = [
            "js/player.js",
            "/shogun-music/js/player.js",
            "/js/player.js"
          ];
          
          tryLoadPlayerAlternatives(altPaths, 0);
        };
        
        playerScript.onload = function() {
          console.log("player.js caricato con successo");
          
          // Verifica che FavoritesManager sia disponibile dopo il caricamento
          setTimeout(function() {
            if (typeof window.FavoritesManager === 'undefined') {
              console.error("FavoritesManager non disponibile dopo il caricamento di player.js");

              // Mostra un messaggio di errore all'utente
              const errorDiv = document.createElement('div');
              errorDiv.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
              errorDiv.style.color = 'white';
              errorDiv.style.padding = '10px';
              errorDiv.style.borderRadius = '5px';
              errorDiv.style.position = 'fixed';
              errorDiv.style.top = '10px';
              errorDiv.style.left = '50%';
              errorDiv.style.transform = 'translateX(-50%)';
              errorDiv.style.zIndex = '9999';
              errorDiv.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
              errorDiv.innerHTML = `
                <b>Errore caricamento modulo preferiti</b><br>
                Ricarica la pagina o contatta il supporto
                <button style="margin-left:15px;padding:5px 10px;background:white;color:red;border:none;border-radius:3px;cursor:pointer" onclick="location.reload()">Ricarica</button>
              `;
              document.body.appendChild(errorDiv);
            } else {
              console.log("FavoritesManager correttamente disponibile");
            }
          }, 1000);
        };
        
        document.head.appendChild(playerScript);
      }

      // Funzione per tentare percorsi alternativi per player.js
      function tryLoadPlayerAlternatives(paths, index) {
        if (index >= paths.length) {
          console.error("Impossibile caricare player.js da nessun percorso alternativo");
          showErrorBanner("Errore di caricamento script player.js");
          return;
        }
        
        const altPath = paths[index];
        console.log("Tentativo con percorso alternativo per player.js:", altPath);
        
        const altScript = document.createElement("script");
        altScript.src = altPath;
        altScript.type = "text/javascript";
        
        altScript.onerror = function() {
          console.warn("Fallito caricamento di player.js da " + altPath);
          tryLoadPlayerAlternatives(paths, index + 1);
        };
        
        altScript.onload = function() {
          console.log("player.js caricato con successo da percorso alternativo:", altPath);
          
          // Dopo 1 secondo, verifica che FavoritesManager sia disponibile
          setTimeout(function() {
            if (typeof window.FavoritesManager === 'undefined') {
              console.error("FavoritesManager non disponibile dopo il caricamento alternativo di player.js");
            } else {
              console.log("FavoritesManager disponibile dopo caricamento alternativo");
            }
          }, 1000);
        };
        
        document.head.appendChild(altScript);
      }

      // Opzione 1: Recupero dal localStorage se disponibile
      function findTrackInLocalDB(trackId) {
        try {
          // Usa GunDB invece di localStorage
          return new Promise((resolve) => {
            if (!window.shogun || !window.shogun.gun) {
              console.error("GunDB non disponibile per tracce locali");
              resolve(null);
              return;
            }
            
            window.shogun.gun.get('local_tracks').get(trackId).once((data) => {
              if (data) {
                console.log("Traccia trovata in GunDB:", data);
                resolve(data);
              } else {
                console.log("Traccia non trovata in GunDB:", trackId);
                resolve(null);
              }
            });
          });
        } catch (e) {
          console.error("Errore nel recupero da GunDB:", e);
          return Promise.resolve(null);
        }
      }

      // Funzione per caricare le tracce - usa GunDB invece di localStorage
      function loadLocalTracks() {
        console.log("Caricamento tracce locali...");
        
        // Verifica se Gun.js è disponibile
        if (!window.shogun || !window.shogun.gun) {
          console.error("Gun.js non disponibile, impossibile caricare tracce");
          return Promise.reject("Gun.js non disponibile");
        }
        
        return new Promise((resolve, reject) => {
          // Carica da GunDB
          window.shogun.gun.get('local_tracks').once((data) => {
            if (data) {
              const tracks = [];
              let trackCount = 0;
              
              // Converti l'oggetto GunDB in array
              Object.keys(data).forEach(key => {
                if (key !== '_' && data[key]) {
                  tracks.push(data[key]);
                  trackCount++;
                }
              });
              
              if (trackCount > 0) {
                console.log(`Caricate ${trackCount} tracce da GunDB`);
                window.tracks = tracks;
                updateTracksDisplay();
                resolve(tracks);
              } else {
                console.log("Nessun dato trovato in GunDB, carico tracce di fallback");
                loadFallbackTracks().then(resolve).catch(reject);
              }
            } else {
              console.log("Nessun dato trovato in GunDB, carico tracce di fallback");
              loadFallbackTracks().then(resolve).catch(reject);
            }
          });
        });
      }

      // Funzione per salvare le tracce in GunDB
      function saveLocalTracks(tracks) {
        // Verifica che Gun.js sia disponibile
        if (!window.shogun || !window.shogun.gun) {
          console.error("Gun.js non disponibile, impossibile salvare tracce");
          return;
        }
        
        try {
          // Crea una versione semplificata dei dati
          const simplifiedData = {};
          
          tracks.forEach(track => {
            simplifiedData[track.id] = {
              id: track.id,
              title: track.title,
              artist: track.artist,
              album: track.album,
              audio_path: track.audio_path,
              artwork: track.artwork,
              duration: track.duration
            };
          });
          
          // Salva in GunDB per uso futuro
          window.shogun.gun.get('local_tracks').put(simplifiedData, (ack) => {
            if (ack.err) {
              console.error("Errore nel salvare le tracce in GunDB:", ack.err);
            } else {
              console.log("Tracce salvate in GunDB");
            }
          });
        } catch (e) {
          console.warn("Impossibile salvare in GunDB:", e);
        }
      }

      // Carica player.js e api.js come moduli ES6
      function loadPlayerJs(basePath) {
        console.log("Caricamento moduli API e Player con base path:", basePath);
        
        // Carica prima API.js come modulo
        const apiScript = document.createElement('script');
        apiScript.type = 'module';
        apiScript.src = `${basePath}/js/api.js`;
        
        // Gestisci errori di caricamento API
        apiScript.onerror = function() {
          console.error("Errore nel caricamento del modulo API");
          showErrorBanner("Impossibile caricare il sistema API");
        };
        
        // Dopo che API è caricato, carica player.js
        apiScript.onload = function() {
          console.log("API.js caricato come modulo");
          
          // Ora carica player.js come modulo
          const playerScript = document.createElement('script');
          playerScript.type = 'module';
          playerScript.src = `${basePath}/js/player.js`;
          
          playerScript.onerror = function() {
            console.error("Errore nel caricamento del modulo Player");
            showErrorBanner("Impossibile caricare il sistema Player");
          };
          
          playerScript.onload = function() {
            console.log("Player.js caricato come modulo");
            
            // Verifica dopo un breve ritardo che FavoritesManager sia disponibile
            setTimeout(function() {
              if (!window.FavoritesManager) {
                console.error("FavoritesManager non disponibile dopo il caricamento");
                showErrorBanner("Si è verificato un errore nell'inizializzazione del sistema dei preferiti. Ricarica la pagina o contatta il supporto se il problema persiste.");
              } else {
                console.log("FavoritesManager correttamente disponibile");
              }
            }, 1000);
          };
          
          document.head.appendChild(playerScript);
        };
        
        document.head.appendChild(apiScript);
      }

      function toggleFavoriteClick(event) {
        const btn = event.currentTarget;
        const id = btn.getAttribute('data-id');
        const type = btn.getAttribute('data-type');
        const name = btn.getAttribute('data-name') || '';
        
        // Usa la funzione globale toggleFavorite invece di FavoritesManager.toggleFavorite
        const isNowFavorite = toggleFavorite(id, type, name);
        
        // Aggiorna l'icona del pulsante subito per feedback visivo immediato
        btn.setAttribute('data-favorite', isNowFavorite ? 'true' : 'false');
        btn.innerHTML = isNowFavorite ? '<i class="fas fa-heart"></i>' : '<i class="far fa-heart"></i>';
      }

      // Verifica e inizializza PlaylistManager se non disponibile
      function ensurePlaylistManager() {
        if (window.PlaylistManager) {
          console.log("PlaylistManager già disponibile");
          return window.PlaylistManager;
        }
        
        // Prima di creare un fallback, cerchiamo di vedere se gli script esterni sono già caricati
        if (typeof window.PlaylistManagerSingleton === 'function') {
          console.log("Classe PlaylistManagerSingleton trovata, creazione istanza...");
          window.PlaylistManager = new window.PlaylistManagerSingleton();
          return window.PlaylistManager;
        }
        
        console.warn("PlaylistManager non disponibile, creazione di una versione fallback...");
        
        // Verifica che shogunMusicAPI sia disponibile
        if (!window.shogunMusicAPI && window.shogun && window.shogun.gun) {
          // Tenta di creare shogunMusicAPI se non esiste ma gun è disponibile
          try {
            console.log("Tentativo di creazione shogunMusicAPI...");
            // Verifica se la classe ShogunMusicAPI è disponibile
            if (typeof window.ShogunMusicAPI === 'function') {
              window.shogunMusicAPI = new window.ShogunMusicAPI(window.shogun.gun);
              window.shogunMusicAPI.initEventListeners();
              console.log("shogunMusicAPI creato con successo");
            } else {
              console.error("Classe ShogunMusicAPI non disponibile globalmente");
            }
          } catch (e) {
            console.error("Errore nella creazione di shogunMusicAPI:", e);
          }
        }
        
        // Crea una versione di PlaylistManager fallback
        const fallbackPlaylistManager = {
          // Stato locale
          playlists: [],
          
          // Carica playlist da localStorage come fallback
          _loadFromLocalStorage: function() {
            try {
              // Usa local_playlists invece di user_playlists per compatibilità con gli altri script
              const saved = localStorage.getItem('local_playlists');
              if (saved) {
                this.playlists = JSON.parse(saved);
                console.log(`Caricate ${this.playlists.length} playlist da localStorage (fallback)`);
                window.userPlaylists = this.playlists;
                return this.playlists;
              }
            } catch (e) {
              console.error("Errore nel caricamento playlist da localStorage:", e);
            }
            this.playlists = [];
            window.userPlaylists = this.playlists;
            return this.playlists;
          },
          
          // Salva playlist in localStorage come fallback
          _saveToLocalStorage: function() {
            try {
              // Usa local_playlists invece di user_playlists per compatibilità con gli altri script
              localStorage.setItem('local_playlists', JSON.stringify(this.playlists));
              console.log(`Salvate ${this.playlists.length} playlist in localStorage (fallback)`);
              return true;
            } catch (e) {
              console.error("Errore nel salvataggio playlist in localStorage:", e);
              return false;
            }
          },
          
          // API Methods
          createPlaylist: function(name, tracks = []) {
            console.log("Creazione playlist (fallback):", name);
            return new Promise((resolve, reject) => {
              try {
                // Carica le playlist esistenti
                this._loadFromLocalStorage();
                
                // Verifica se esiste già una playlist con lo stesso nome
                const existingPlaylist = this.playlists.find(p => p.name === name);
                if (existingPlaylist) {
                  console.warn(`Playlist con nome "${name}" già esistente, uso quella`);
                  resolve(existingPlaylist);
                  return;
                }
                
                // Crea la nuova playlist
                const newPlaylist = {
                  id: 'playlist_' + Date.now() + '_' + Math.floor(Math.random() * 1000),
                  name: name,
                  tracks: tracks.map(track => typeof track === 'object' ? String(track.id) : String(track)),
                  createdAt: Date.now(),
                  updatedAt: Date.now()
                };
                
                // Aggiungi la playlist e salva
                this.playlists.push(newPlaylist);
                this._saveToLocalStorage();
                
                // Aggiorna userPlaylists per retrocompatibilità
                window.userPlaylists = this.playlists;
                
                resolve(newPlaylist);
              } catch (e) {
                console.error("Errore nella creazione playlist (fallback):", e);
                reject(e);
              }
            });
          },
          
          addTrackToPlaylist: function(playlistId, track) {
            console.log(`Aggiunta traccia alla playlist ${playlistId} (fallback)`);
            return new Promise((resolve, reject) => {
              try {
                // Carica le playlist esistenti
                this._loadFromLocalStorage();
                
                // Trova la playlist
                const playlistIndex = this.playlists.findIndex(p => p.id === playlistId);
                if (playlistIndex === -1) {
                  reject(new Error(`Playlist con ID ${playlistId} non trovata`));
                  return;
                }
                
                // Ottieni l'ID della traccia
                const trackId = typeof track === 'object' ? String(track.id) : String(track);
                
                // Verifica se la traccia è già presente
                if (this.playlists[playlistIndex].tracks.includes(trackId)) {
                  console.log(`Traccia ${trackId} già presente nella playlist`);
                  resolve(false);
                  return;
                }
                
                // Aggiungi la traccia
                this.playlists[playlistIndex].tracks.push(trackId);
                this.playlists[playlistIndex].updatedAt = Date.now();
                
                // Salva le modifiche
                this._saveToLocalStorage();
                
                // Aggiorna userPlaylists per retrocompatibilità
                window.userPlaylists = this.playlists;
                
                resolve(true);
              } catch (e) {
                console.error("Errore nell'aggiunta traccia alla playlist (fallback):", e);
                reject(e);
              }
            });
          },
          
          removeTrackFromPlaylist: function(playlistId, trackId) {
            console.log(`Rimozione traccia ${trackId} dalla playlist ${playlistId} (fallback)`);
            return new Promise((resolve, reject) => {
              try {
                // Carica le playlist esistenti
                this._loadFromLocalStorage();
                
                // Trova la playlist
                const playlistIndex = this.playlists.findIndex(p => p.id === playlistId);
                if (playlistIndex === -1) {
                  reject(new Error(`Playlist con ID ${playlistId} non trovata`));
                  return;
                }
                
                // Converti l'ID in stringa
                const trackIdStr = String(trackId);
                
                // Verifica se la traccia è presente
                const trackIndex = this.playlists[playlistIndex].tracks.indexOf(trackIdStr);
                if (trackIndex === -1) {
                  console.log(`Traccia ${trackId} non trovata nella playlist ${playlistId}`);
                  resolve(false);
                  return;
                }
                
                // Rimuovi la traccia
                this.playlists[playlistIndex].tracks.splice(trackIndex, 1);
                this.playlists[playlistIndex].updatedAt = Date.now();
                
                // Salva le modifiche
                this._saveToLocalStorage();
                
                // Aggiorna userPlaylists per retrocompatibilità
                window.userPlaylists = this.playlists;
                
                resolve(true);
              } catch (e) {
                console.error("Errore nella rimozione traccia dalla playlist (fallback):", e);
                reject(e);
              }
            });
          },
          
          deletePlaylist: function(playlistId) {
            console.log(`Eliminazione playlist ${playlistId} (fallback)`);
            return new Promise((resolve, reject) => {
              try {
                // Carica le playlist esistenti
                this._loadFromLocalStorage();
                
                // Trova la playlist
                const playlistIndex = this.playlists.findIndex(p => p.id === playlistId);
                if (playlistIndex === -1) {
                  reject(new Error(`Playlist con ID ${playlistId} non trovata`));
                  return;
                }
                
                // Rimuovi la playlist
                this.playlists.splice(playlistIndex, 1);
                
                // Salva le modifiche
                this._saveToLocalStorage();
                
                // Aggiorna userPlaylists per retrocompatibilità
                window.userPlaylists = this.playlists;
                
                resolve(true);
              } catch (e) {
                console.error("Errore nell'eliminazione playlist (fallback):", e);
                reject(e);
              }
            });
          },
          
          loadPlaylists: function() {
            console.log("Caricamento playlist (fallback)");
            return new Promise((resolve) => {
              const playlists = this._loadFromLocalStorage();
              resolve(playlists);
            });
          },
          
          savePlaylists: function(playlists) {
            console.log("Salvataggio playlist (fallback)");
            return new Promise((resolve, reject) => {
              try {
                this.playlists = playlists;
                window.userPlaylists = playlists;
                this._saveToLocalStorage();
                resolve(true);
              } catch (e) {
                console.error("Errore nel salvataggio playlist (fallback):", e);
                reject(e);
              }
            });
          }
        };
        
        // Salva in window.PlaylistManager
        window.PlaylistManager = fallbackPlaylistManager;
        
        console.log("PlaylistManager fallback inizializzato");
        return window.PlaylistManager;
      }

      // Function to toggle the content tab
      function setupContentTabs() {
        // ... existing code ...
      }

      // Event listeners for the elements in the page
      document.addEventListener("DOMContentLoaded", function () {
        // ... existing code ...
        
        // Aggiunta evento al pulsante per creare una nuova playlist
        const createPlaylistBtn = document.getElementById("createPlaylistBtn");
        if (createPlaylistBtn) {
          createPlaylistBtn.addEventListener("click", function() {
            const playlistNameInput = document.getElementById("newPlaylistName");
            const playlistName = playlistNameInput ? playlistNameInput.value.trim() : "";
            
            if (!playlistName) {
              // Se l'input è vuoto, chiedi il nome tramite un prompt
              const promptName = prompt("Inserisci il nome della nuova playlist:");
              if (promptName && promptName.trim()) {
                createPlaylistAndUpdate(promptName.trim());
              }
            } else {
              // Usa il nome dall'input
              createPlaylistAndUpdate(playlistName);
              // Pulisci l'input dopo la creazione
              playlistNameInput.value = "";
            }
          });
        }
        
        // Aggiungi evento anche all'input per creare premendo Enter
        const newPlaylistNameInput = document.getElementById("newPlaylistName");
        if (newPlaylistNameInput) {
          newPlaylistNameInput.addEventListener("keypress", function(e) {
            if (e.key === "Enter") {
              const playlistName = this.value.trim();
              if (playlistName) {
                createPlaylistAndUpdate(playlistName);
                this.value = "";
              }
            }
          });
        }
      });
      
      // Funzione per creare una playlist e aggiornare l'interfaccia
      function createPlaylistAndUpdate(playlistName) {
        console.log(`Creazione nuova playlist: "${playlistName}"`);
        
        // Verifica che la funzione createPlaylist sia disponibile
        if (typeof createPlaylist === 'function') {
          createPlaylist(playlistName)
            .then(newPlaylist => {
              if (newPlaylist) {
                console.log("Playlist creata con successo:", newPlaylist);
                
                // Aggiorna l'interfaccia
                if (typeof displayPlaylists === 'function') {
                  displayPlaylists();
                }
              } else {
                console.error("Errore nella creazione della playlist");
                alert("Errore nella creazione della playlist");
              }
            })
            .catch(err => {
              console.error("Errore nella creazione della playlist:", err);
              alert("Errore nella creazione della playlist: " + (err.message || "Errore sconosciuto"));
            });
        } else if (window.PlaylistManager && typeof window.PlaylistManager.createPlaylist === 'function') {
          // Usa direttamente PlaylistManager se disponibile
          window.PlaylistManager.createPlaylist(playlistName)
            .then(newPlaylist => {
              console.log("Playlist creata con PlaylistManager:", newPlaylist);
              
              // Aggiorna l'interfaccia
              if (typeof displayPlaylists === 'function') {
                displayPlaylists();
              }
            })
            .catch(err => {
              console.error("Errore nella creazione della playlist:", err);
              alert("Errore nella creazione della playlist: " + (err.message || "Errore sconosciuto"));
            });
        } else {
          console.error("Nessun sistema disponibile per creare playlist");
          alert("Errore: Nessun sistema disponibile per creare playlist");
        }
      }
    </script>
  </body>
</html>

