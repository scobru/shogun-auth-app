<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Stazione Radio Decentralizzata</title>
    <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/radix.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/radisk.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/store.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/rindexed.js"></script>
    <script src="https://unpkg.com/wavesurfer.js@6.6.3/dist/wavesurfer.min.js"></script>

    <!-- Fallback per WaveSurfer in caso di problemi con il CDN principale -->
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        if (typeof WaveSurfer === "undefined") {
          console.warn(
            "WaveSurfer non caricato dal CDN principale, tentativo con CDN alternativo..."
          );
          const script = document.createElement("script");
          script.src =
            "https://cdnjs.cloudflare.com/ajax/libs/wavesurfer.js/6.6.3/wavesurfer.min.js";
          script.onload = () =>
            console.log("WaveSurfer caricato da CDN alternativo");
          script.onerror = () =>
            console.error("Impossibile caricare WaveSurfer da entrambi i CDN");
          document.head.appendChild(script);
        } else {
          console.log("WaveSurfer caricato correttamente dal CDN principale");
        }
      });
    </script>

    <style>
      body {
        font-family: sans-serif;
        padding: 20px;
        background: #f0f0f0;
      }
      h1 {
        text-align: center;
      }
      input,
      button {
        margin: 5px 0;
        padding: 8px;
        font-size: 1rem;
      }
      #waveform {
        margin-top: 20px;
        background: #fff;
        border-radius: 8px;
        height: 100px;
      }
      .song-card {
        background: white;
        padding: 15px;
        margin: 15px 0;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      #relayList {
        margin: 15px 0;
      }
      .relay-item {
        display: flex;
        align-items: center;
        background: white;
        padding: 10px;
        margin: 5px 0;
        border-radius: 8px;
      }
      .relay-item button {
        margin-left: 10px;
      }
      .artwork-preview {
        width: 100px;
        height: 100px;
        object-fit: cover;
        border-radius: 8px;
        margin-right: 15px;
      }
      .song-card {
        display: flex;
        align-items: center;
      }
      .song-card .song-info {
        flex-grow: 1;
      }
      .artwork-placeholder {
        width: 100px;
        height: 100px;
        background: #ddd;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 15px;
      }
      .upload-progress {
        margin-top: 10px;
        height: 20px;
        background-color: #eee;
        border-radius: 4px;
        overflow: hidden;
      }
      .progress-bar {
        height: 100%;
        background-color: #4caf50;
        width: 0%;
        transition: width 0.3s;
      }
      .status-badge {
        display: inline-block;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        margin-left: 10px;
      }
      .online {
        background-color: #4caf50;
        color: white;
      }
      .offline {
        background-color: #f44336;
        color: white;
      }
    </style>
  </head>
  <body>
    <h1>üéß Stazione Radio Decentralizzata</h1>
    <div id="peerStatus" style="text-align: center; margin-bottom: 10px">
      <span class="status-badge offline">Offline</span>
      <span id="connectedPeers">0 peers connessi</span>
    </div>

    <div>
      <input type="file" id="audioFile" accept="audio/*" />
      <input type="text" id="title" placeholder="Titolo" />
      <input type="text" id="artist" placeholder="Artista" />
      <input type="file" id="artworkFile" accept="image/*" />
      <label for="artworkFile">üñºÔ∏è Artwork</label>
      <div id="artworkPreview"></div>
      <button id="uploadBtn">üì§ Carica Traccia</button>
      <div id="uploadStatus"></div>
      <div class="upload-progress">
        <div class="progress-bar" id="progressBar"></div>
      </div>
    </div>

    <div id="waveform"></div>
    <button id="playBtn">‚ñ∂Ô∏è Play / Pause</button>

    <hr />

    <h2>üîå Relay</h2>
    <div>
      <input
        type="text"
        id="relayAddress"
        placeholder="http://localhost:8765/gun"
      />
      <button id="addRelay">Aggiungi Relay</button>
    </div>
    <div id="relayList"></div>

    <h2>üé∂ Canzoni</h2>
    <div id="songList"></div>

    <script>
      // Debug function per verificare lo stato dei chunks
      window.verificaChunks = function (trackId) {
        if (!trackId) {
          alert("Inserisci un ID traccia per verificare i chunks");
          return;
        }

        console.log(`Verificando chunks per traccia ${trackId}...`);

        tracksNode.get(`${trackId}_metadata`).once((metadata) => {
          if (!metadata) {
            console.error(`Nessun metadata trovato per traccia ${trackId}`);
            alert(`Nessun metadata trovato per traccia ${trackId}`);
            return;
          }

          console.log("Metadata:", metadata);

          if (!metadata.chunks) {
            console.log("La traccia non usa chunks");
            alert(`La traccia ${trackId} non usa chunks`);
            return;
          }

          console.log(
            `Traccia ${trackId} ha ${metadata.chunks} chunks. Verificando...`
          );
          let trovati = 0;
          let mancanti = [];

          for (let i = 0; i < metadata.chunks; i++) {
            tracksNode.get(`${trackId}_chunk_${i}`).once((chunk) => {
              if (chunk && chunk.data) {
                trovati++;
                console.log(`Chunk ${i} trovato (${chunk.data.length} bytes)`);
              } else {
                console.warn(`Chunk ${i} MANCANTE`);
                mancanti.push(i);
              }

              if (i === metadata.chunks - 1) {
                console.log(
                  `Verifica completata: ${trovati}/${metadata.chunks} chunks trovati`
                );
                if (mancanti.length > 0) {
                  console.warn(`Chunks mancanti: ${mancanti.join(", ")}`);
                  alert(
                    `Trovati ${trovati}/${
                      metadata.chunks
                    } chunks. Mancanti: ${mancanti.join(", ")}`
                  );
                } else {
                  alert(
                    `Tutti i ${metadata.chunks} chunks trovati correttamente!`
                  );
                }
              }
            });
          }
        });
      };

      // Aggiunge pulsante di debug nella UI
      document.addEventListener("DOMContentLoaded", function () {
        const debugDiv = document.createElement("div");
        debugDiv.innerHTML = `
      <hr>
      <h3>üîß Debug</h3>
      <input type="text" id="trackIdDebug" placeholder="ID Traccia">
      <button onclick="window.verificaChunks(document.getElementById('trackIdDebug').value)">
        Verifica Chunks
      </button>
    `;
        document.body.appendChild(debugDiv);
      });

      // Inizializza Gun con super peer pubblici predefiniti
      const defaultRelays = [
        "http://localhost:3002/gun",
        "https://gun-manhattan.herokuapp.com/gun", // Relay pubblico come fallback
      ];

      // Configurazione iniziale Gun
      let gun = Gun({
        peers: defaultRelays,
        localStorage: false,
        radisk: false,
        retry: 1500, // Riprova ogni 1.5 secondi
        max: 3, // Massimo 3 tentativi
      });

      // Aggiunge header di autenticazione a GUN per migliorare la gestione dei messaggi
      Gun.on("opt", function(ctx) {
        if (ctx.once) return;
        
        // Aumenta il timeout per le operazioni
        ctx.opt.wait = 99999;
        
        // Aumenta la dimensione massima del messaggio (anche se questo dipende dal server)
        ctx.opt.maxMessages = 5000;
        
        // Aggiunge headers per autenticazione (se il server li utilizza)
        ctx.on("out", function(msg) {
          var to = this.to;
          msg.headers = {
            token: "thisIsTheTokenForReals"
          };
          to.next(msg);
        });
      });

      // Riferimenti globali ai nodi Gun
      const relaysNode = gun.get("relays");
      const tracksNode = gun.get("tracks");
      const artworkNode = gun.get("artwork");
      const metadataNode = gun.get("audio_metadata");

      const songList = document.getElementById("songList");
      const relayList = document.getElementById("relayList");
      const peerStatus = document
        .getElementById("peerStatus")
        .querySelector(".status-badge");
      const connectedPeers = document.getElementById("connectedPeers");

      let wavesurfer;
      let activeRelays = [...defaultRelays];

      // Monitoraggio connessione
      gun.on("hi", (peer) => {
        console.log("Connesso al peer:", peer);
        peerStatus.className = "status-badge online";
        peerStatus.textContent = "Online";
        updatePeerCounter();
      });

      gun.on("bye", (peer) => {
        updatePeerCounter();
        if (Object.keys(gun._.opt.peers).length === 0) {
          peerStatus.className = "status-badge offline";
          peerStatus.textContent = "Offline";
        }
      });

      function updatePeerCounter() {
        const count = Object.keys(gun._.opt.peers).length;
        connectedPeers.textContent = `${count} peer${
          count !== 1 ? "s" : ""
        } connessi`;
      }

      // Converti file in base64 e dividi in chunk se necessario
      function fileToBase64(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.readAsDataURL(file);
          reader.onload = () => resolve(reader.result);
          reader.onerror = (error) => reject(error);
        });
      }

      // Aggiungiamo funzione per comprimere i dati Base64
      function compressBase64(base64Data) {
        try {
          console.log(`Compressione dati (lunghezza originale: ${base64Data.length})`);
          // Simple RLE-style compression for Base64
          let compressed = "";
          let count = 1;
          let currentChar = base64Data[0];
          
          for (let i = 1; i < base64Data.length; i++) {
            if (base64Data[i] === currentChar && count < 255) {
              count++;
            } else {
              // Usa un formato pi√π compatto: solo quando ci sono ripetizioni
              if (count > 3) {
                compressed += `${currentChar}#${count}`;
              } else {
                compressed += currentChar.repeat(count);
              }
              currentChar = base64Data[i];
              count = 1;
            }
          }
          
          // Aggiungi l'ultimo carattere
          if (count > 3) {
            compressed += `${currentChar}#${count}`;
          } else {
            compressed += currentChar.repeat(count);
          }
          
          console.log(`Compressione completata (lunghezza dopo: ${compressed.length}, risparmio: ${Math.round((1 - compressed.length/base64Data.length) * 100)}%)`);
          return compressed;
        } catch (e) {
          console.error("Errore nella compressione:", e);
          return base64Data; // In caso di errore, ritorna i dati originali
        }
      }
      
      // Aggiungiamo funzione per decomprimere i dati Base64
      function decompressBase64(compressedData) {
        try {
          console.log(`Decompressione dati (lunghezza compressa: ${compressedData.length})`);
          // Decomprime il formato RLE-style
          let decompressed = "";
          let i = 0;
          
          while (i < compressedData.length) {
            let char = compressedData[i];
            i++;
            
            if (i < compressedData.length && compressedData[i] === '#') {
              i++; // Salta il carattere #
              let countStr = "";
              while (i < compressedData.length && /[0-9]/.test(compressedData[i])) {
                countStr += compressedData[i];
                i++;
              }
              const count = parseInt(countStr, 10);
              decompressed += char.repeat(count);
            } else {
              decompressed += char;
            }
          }
          
          console.log(`Decompressione completata (lunghezza dopo: ${decompressed.length})`);
          return decompressed;
        } catch (e) {
          console.error("Errore nella decompressione:", e);
          return compressedData; // In caso di errore, ritorna i dati compressi
        }
      }

      // Dividi dati in chunks
      function splitIntoChunks(data, chunkSize = 20000) { // Ridotto a 20KB per chunk
        console.log(`Dividendo i dati in chunks (lunghezza dati: ${data.length})`);
        const chunks = [];
        for (let i = 0; i < data.length; i += chunkSize) {
          chunks.push(data.substring(i, i + chunkSize));
        }
        console.log(`Creati ${chunks.length} chunks (dimensione chunk: ${chunkSize})`);
        return chunks;
      }

      // Unisci chunks in un unico dato
      function joinChunks(chunks) {
        console.log(`Unendo ${chunks.length} chunks`);
        return chunks.join("");
      }

      // Converti base64 in Blob
      function base64ToBlob(base64, mimeType) {
        const byteString = atob(base64.split(",")[1]);
        const ab = new ArrayBuffer(byteString.length);
        const ia = new Uint8Array(ab);

        for (let i = 0; i < byteString.length; i++) {
          ia[i] = byteString.charCodeAt(i);
        }

        return new Blob([ab], { type: mimeType });
      }

      // Inizializza player audio
      function initPlayer(blob) {
        try {
          if (wavesurfer) wavesurfer.destroy();

          if (typeof WaveSurfer === "undefined") {
            console.error(
              "WaveSurfer non √® definito. Verifica che la libreria sia caricata correttamente."
            );
            alert(
              "Errore: impossibile caricare il player audio. Ricarica la pagina e riprova."
            );
            return;
          }

          wavesurfer = WaveSurfer.create({
            container: "#waveform",
            waveColor: "violet",
            progressColor: "purple",
            height: 100,
            responsive: true,
          });
          const objectURL = URL.createObjectURL(blob);
          wavesurfer.load(objectURL);
        } catch (error) {
          console.error("Errore nell'inizializzazione del player:", error);
          alert(
            "Errore nell'inizializzazione del player audio: " + error.message
          );
        }
      }

      document.getElementById("playBtn").addEventListener("click", () => {
        if (wavesurfer) wavesurfer.playPause();
      });

      // Preview dell'artwork
      document
        .getElementById("artworkFile")
        .addEventListener("change", function (event) {
          const file = event.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = function (e) {
              const preview = document.getElementById("artworkPreview");
              preview.innerHTML = `<img src="${e.target.result}" class="artwork-preview">`;
            };
            reader.readAsDataURL(file);
          }
        });

      // Gestione caricamento file
      document
        .getElementById("uploadBtn")
        .addEventListener("click", async () => {
          const fileInput = document.getElementById("audioFile");
          const artworkInput = document.getElementById("artworkFile");
          const title =
            document.getElementById("title").value || "Senza titolo";
          const artist =
            document.getElementById("artist").value || "Sconosciuto";
          const audioFile = fileInput.files[0];

          if (!audioFile) return alert("Seleziona un file audio.");

          // Verifica dimensione file
          const maxFileSizeMB = 10;
          if (audioFile.size > maxFileSizeMB * 1024 * 1024) {
            alert(
              `Il file √® troppo grande. Dimensione massima: ${maxFileSizeMB}MB`
            );
            return;
          }

          const id = Math.random().toString(36).substr(2, 9);
          const progressBar = document.getElementById("progressBar");
          const uploadStatus = document.getElementById("uploadStatus");

          uploadStatus.innerText = "‚è≥ Preparazione per il caricamento...";
          progressBar.style.width = "10%";

          try {
            // Prepara metadati
            const metadata = {
              id,
              title,
              artist,
              timestamp: Date.now(),
              mimeType: audioFile.type,
            };

            progressBar.style.width = "20%";

            // Processa l'artwork se presente
            if (artworkInput.files[0]) {
              uploadStatus.innerText = "‚è≥ Preparazione artwork...";
              try {
                const artworkBase64 = await fileToBase64(artworkInput.files[0]);
                metadata.hasArtwork = true;
                metadata.artworkMimeType = artworkInput.files[0].type;

                if (artworkBase64.length > 100000) {
                  // L'artwork √® troppo grande, salviamo in chunks
                  const artworkChunks = splitIntoChunks(artworkBase64);
                  metadata.artworkChunks = artworkChunks.length;

                  // Salva chunks in Gun
                  for (let i = 0; i < artworkChunks.length; i++) {
                    await new Promise((resolve) => {
                      artworkNode.get(`${id}_chunk_${i}`).put(
                        {
                          data: artworkChunks[i],
                          index: i,
                          total: artworkChunks.length,
                        },
                        (ack) => resolve()
                      );
                    });
                  }
                } else {
                  // Artwork piccolo, salva direttamente
                  artworkNode.get(id).put({ data: artworkBase64 });
                }
              } catch (artworkError) {
                console.error("Errore nel processare l'artwork:", artworkError);
                metadata.hasArtwork = false;
              }
            } else {
              metadata.hasArtwork = false;
            }

            progressBar.style.width = "30%";

            // Salva metadati
            await new Promise((resolve) => {
              metadataNode.get(id).put(metadata, (ack) => {
                console.log("Metadati salvati:", ack);
                resolve();
              });
            });

            progressBar.style.width = "40%";

            // Carica file audio su Gun
            uploadStatus.innerText =
              "‚è≥ Caricamento del file audio in corso...";

            // Converti in base64
            try {
              const audioBase64 = await fileToBase64(audioFile);
              
              // Comprimi i dati prima di suddividerli
              const compressedAudioBase64 = compressBase64(audioBase64);
              
              // Dividi in chunks per evitare "Message too big!"
              const chunkSize = 10000; // Ridotto ulteriormente a 10KB per chunk
              const chunks = splitIntoChunks(compressedAudioBase64, chunkSize);
              console.log(`File diviso in ${chunks.length} chunks di circa ${chunkSize} bytes ciascuno`);
              
              // Metadati del file con informazioni sui chunks
              const audioMetadata = {
                id,
                mimeType: audioFile.type,
                chunks: chunks.length,
                chunkSize: chunkSize,
                size: audioBase64.length,
                compressedSize: compressedAudioBase64.length,
                isCompressed: true,
                filename: audioFile.name,
                uploadedAt: Date.now()
              };
              
              // Salva metadati dei chunks
              console.log(`Salvando metadati: ${JSON.stringify(audioMetadata)}`);
              await new Promise((resolve) => {
                tracksNode.get(`${id}_metadata`).put(audioMetadata, (ack) => {
                  console.log(`Metadati salvati, risposta:`, ack);
                  resolve();
                });
              });
              
              progressBar.style.width = "60%";
              uploadStatus.innerText = `‚è≥ Caricamento chunks (0/${chunks.length})...`;
              
              // Carica chunks uno per uno con una gestione pi√π precisa degli errori
              let chunksCompletati = 0;
              let chunkErrors = [];
              
              // Funzione per provare a caricare un singolo chunk con pi√π tentativi
              const uploadChunkWithRetry = async (i, maxRetries = 3) => {
                let retries = 0;
                let success = false;
                
                while (retries < maxRetries && !success) {
                  try {
                    await new Promise((resolve, reject) => {
                      const timeout = setTimeout(() => {
                        console.log(`Timeout per chunk ${i}, tentativo ${retries + 1}`);
                        reject(new Error("Timeout"));
                      }, 10000); // 10 secondi di timeout
                      
                      const chunkData = {
                        data: chunks[i],
                        index: i,
                        total: chunks.length,
                        retry: retries
                      };
                      
                      tracksNode.get(`${id}_chunk_${i}`).put(chunkData, (ack) => {
                        clearTimeout(timeout);
                        if (ack.err) {
                          console.error(`Errore nel chunk ${i}, tentativo ${retries + 1}:`, ack.err);
                          reject(new Error(ack.err));
                        } else {
                          success = true;
                          resolve();
                        }
                      });
                    });
                  } catch (error) {
                    console.warn(`Tentativo ${retries + 1} fallito per chunk ${i}: ${error.message}`);
                    retries++;
                    // Attendi pi√π a lungo tra i tentativi successivi
                    await new Promise(r => setTimeout(r, 1000 * retries));
                  }
                }
                
                return success;
              };
              
              // Carica i chunk in piccoli gruppi per evitare di sovraccaricare il server
              const batchSize = 5; // Carica 5 chunk alla volta
              for (let batchStart = 0; batchStart < chunks.length; batchStart += batchSize) {
                const batchEnd = Math.min(batchStart + batchSize, chunks.length);
                const batchPromises = [];
                
                for (let i = batchStart; i < batchEnd; i++) {
                  batchPromises.push(uploadChunkWithRetry(i).then(success => {
                    if (success) {
                      chunksCompletati++;
                      console.log(`Chunk ${i + 1}/${chunks.length} caricato con successo`);
                    } else {
                      chunkErrors.push({ index: i, error: "Tentativi esauriti" });
                      console.error(`Impossibile caricare il chunk ${i} dopo multipli tentativi`);
                    }
                    
                    // Aggiorna la UI
                    const percentuale = 60 + (chunksCompletati * 40 / chunks.length);
                    progressBar.style.width = `${percentuale}%`;
                    uploadStatus.innerText = `‚è≥ Caricamento chunks (${chunksCompletati}/${chunks.length})...`;
                  }));
                }
                
                // Attendi che tutti i chunks del batch siano stati processati
                await Promise.all(batchPromises);
                
                // Piccola pausa tra i batch
                await new Promise(resolve => setTimeout(resolve, 500));
              }

              if (chunkErrors.length > 0) {
                console.warn(
                  `Completato con ${chunkErrors.length} errori nei chunks`,
                  chunkErrors
                );
                uploadStatus.innerText = `‚ö†Ô∏è Caricato con ${chunkErrors.length} errori (${chunksCompletati}/${chunks.length} chunks completati)`;
              } else {
                console.log(
                  `Tutti i ${chunks.length} chunks caricati con successo`
                );
                uploadStatus.innerText = "‚úÖ Traccia caricata con successo!";
              }

              progressBar.style.width = "100%";

              // Reset form
              fileInput.value = "";
              artworkInput.value = "";
              document.getElementById("artworkPreview").innerHTML = "";
              document.getElementById("title").value = "";
              document.getElementById("artist").value = "";

              // Aggiorna la lista dopo il caricamento
              setTimeout(() => {
                displaySongs();
                progressBar.style.width = "0%";
              }, 2000);
            } catch (audioError) {
              console.error("Errore nel caricamento dell'audio:", audioError);
              progressBar.style.width = "0%";
              uploadStatus.innerText =
                "‚ùå Errore nel caricamento dell'audio: " + audioError.message;
            }
          } catch (error) {
            console.error("Errore generale:", error);
            progressBar.style.width = "0%";
            uploadStatus.innerText = "‚ùå Errore: " + error.message;
          }
        });

      // Visualizza le canzoni
      function displaySongs() {
        songList.innerHTML = "";

        metadataNode.map().once((data, key) => {
          if (!data || !data.id) return;

          const container = document.createElement("div");
          container.className = "song-card";
          container.id = "song-" + key;

          // Artwork
          let artworkElement = document.createElement("div");
          artworkElement.className = "artwork-placeholder";
          artworkElement.textContent = "üéµ";
          container.appendChild(artworkElement);

          // Carica artwork se disponibile
          if (data.hasArtwork) {
            if (data.artworkChunks) {
              // L'artwork √® in chunks, ricostruiscilo
              const artworkChunks = [];
              const loadChunks = async () => {
                for (let i = 0; i < data.artworkChunks; i++) {
                  await new Promise((resolve) => {
                    artworkNode.get(`${key}_chunk_${i}`).once((chunk) => {
                      if (chunk && chunk.data) {
                        artworkChunks[chunk.index] = chunk.data;
                      }
                      resolve();
                    });
                  });
                }

                // Ricostruisci e mostra l'artwork
                const fullArtwork = joinChunks(artworkChunks);
                const artworkImg = document.createElement("img");
                artworkImg.src = fullArtwork;
                artworkImg.className = "artwork-preview";
                artworkElement.replaceWith(artworkImg);
              };

              loadChunks();
            } else {
              // Artwork standard
              artworkNode.get(key).once((artwork) => {
                if (artwork && artwork.data) {
                  const artworkImg = document.createElement("img");
                  artworkImg.src = artwork.data;
                  artworkImg.className = "artwork-preview";
                  artworkElement.replaceWith(artworkImg);
                }
              });
            }
          }

          // Info della canzone
          const infoContainer = document.createElement("div");
          infoContainer.className = "song-info";

          const info = document.createElement("div");
          info.innerHTML = `<strong>${data.title}</strong> ‚Äì ${data.artist}`;
          infoContainer.appendChild(info);

          const playBtn = document.createElement("button");
          playBtn.textContent = "‚ñ∂Ô∏è Ascolta";
          playBtn.onclick = () => {
            playBtn.textContent = "‚è≥ Caricamento...";

            // Prima controlla se ci sono chunks o un file singolo
            tracksNode.get(`${key}_metadata`).once(async (metadata) => {
              console.log("Metadati brano:", metadata);

              if (metadata && metadata.chunks) {
                // Il file √® salvato in chunks, ricostruiscilo
                try {
                  console.log(
                    `Caricamento di ${metadata.chunks} chunks per la traccia ${key}`
                  );
                  uploadStatus.innerText = `‚è≥ Caricamento chunks (0/${metadata.chunks})...`;

                  const chunks = new Array(metadata.chunks);
                  let chunksCaricati = 0;

                  for (let i = 0; i < metadata.chunks; i++) {
                    await new Promise((resolve) => {
                      tracksNode.get(`${key}_chunk_${i}`).once((chunk) => {
                        if (chunk && chunk.data) {
                          chunks[chunk.index] = chunk.data;
                          chunksCaricati++;
                          uploadStatus.innerText = `‚è≥ Caricamento chunks (${chunksCaricati}/${metadata.chunks})...`;
                          console.log(
                            `Chunk ${i + 1}/${metadata.chunks} caricato`
                          );
                        } else {
                          console.warn(`Chunk ${i} non trovato o danneggiato`);
                        }
                        resolve();
                      });
                    });
                  }

                  if (chunks.some((c) => !c)) {
                    console.warn(
                      "Alcuni chunks mancanti:",
                      chunks
                        .map((c, i) => (c ? null : i))
                        .filter((i) => i !== null)
                    );
                    playBtn.textContent = "‚ùå Dati incompleti";
                    return;
                  }

                  // Ricostruisci il file
                  console.log("Ricostruzione file dai chunks...");
                  let fullData = joinChunks(chunks);
                  
                  // Decompressione se necessario
                  if (metadata.isCompressed) {
                    console.log("Il file √® compresso, avvio decompressione...");
                    fullData = decompressBase64(fullData);
                  }
                  
                  console.log(`File ricostruito, dimensione: ${fullData.length}`);

                  try {
                    const blob = base64ToBlob(
                      fullData,
                      metadata.mimeType || "audio/mpeg"
                    );
                    console.log("Blob creato, inizializzazione player...");
                    initPlayer(blob);
                    playBtn.textContent = "‚ñ∂Ô∏è Ascolta";
                  } catch (blobError) {
                    console.error(
                      "Errore nella conversione del blob:",
                      blobError
                    );
                    playBtn.textContent = "‚ùå Errore conversione";
                    alert(
                      "Errore nella conversione del file: " + blobError.message
                    );
                  }
                } catch (error) {
                  console.error("Errore nel ricostruire i chunks:", error);
                  playBtn.textContent = "‚ùå Errore";
                  alert(
                    "Errore nella ricostruzione dei chunks: " + error.message
                  );
                }
              } else {
                // Prova il metodo tradizionale (file singolo)
                console.log("Tentativo di caricamento file singolo");
                tracksNode.get(key).once((track) => {
                  if (track && track.data) {
                    try {
                      console.log(
                        "File singolo trovato, inizializzazione player..."
                      );
                      const blob = base64ToBlob(
                        track.data,
                        data.mimeType || "audio/mpeg"
                      );
                      initPlayer(blob);
                      playBtn.textContent = "‚ñ∂Ô∏è Ascolta";
                    } catch (error) {
                      console.error(
                        "Errore nella conversione dell'audio:",
                        error
                      );
                      playBtn.textContent = "‚ùå Errore";
                      alert("Errore nella riproduzione: " + error.message);
                    }
                  } else {
                    playBtn.textContent = "‚ùå Non trovato";
                    console.error("Traccia non trovata:", key);
                  }
                });
              }
            });
          };
          infoContainer.appendChild(playBtn);

          container.appendChild(infoContainer);
          songList.appendChild(container);
        });
      }

      // Gestione relay
      function loadRelays() {
        relayList.innerHTML = "";

        // Aggiungi prima i relay predefiniti
        defaultRelays.forEach((url) => {
          addRelayToList(url, true);
        });

        // Carica relay salvati in Gun
        relaysNode.map().once((relay, key) => {
          if (relay && relay.url && !defaultRelays.includes(relay.url)) {
            addRelayToList(relay.url);
          }
        });
      }

      function addRelayToList(url, isDefault = false) {
        if (activeRelays.includes(url) && !isDefault) return;

        if (!activeRelays.includes(url)) {
          activeRelays.push(url);
          // Aggiungi il peer se non √® gi√† nella lista
          gun.opt({ peers: [url] });
        }

        const relayItem = document.createElement("div");
        relayItem.className = "relay-item";
        relayItem.innerHTML = `<span>${url} ${
          isDefault ? "(predefinito)" : ""
        }</span>`;

        if (!isDefault) {
          const removeBtn = document.createElement("button");
          removeBtn.textContent = "‚ùå";
          removeBtn.onclick = () => removeRelay(url, relayItem);
          relayItem.appendChild(removeBtn);
        }

        relayList.appendChild(relayItem);
      }

      function removeRelay(url, element) {
        activeRelays = activeRelays.filter((relay) => relay !== url);
        element.remove();

        // Rimuovi da Gun
        relaysNode.get(url).put(null);

        // Rimuovi il peer
        if (gun._.opt.peers[url]) {
          gun._.opt.peers[url].wire.close();
          delete gun._.opt.peers[url];
        }
      }

      function connectToRelay(url) {
        if (!url || !url.trim()) return;

        try {
          url = url.trim();

          // Verifica se l'URL √® ben formato
          if (!url.startsWith("http://") && !url.startsWith("https://")) {
            alert(
              "Errore: l'URL del relay deve iniziare con http:// o https://"
            );
            return;
          }

          console.log("Tentativo di connessione al relay:", url);

          // Salva relay in Gun
          relaysNode.get(url).put({ url: url, added: Date.now() });

          // Aggiungi alla UI
          addRelayToList(url);

          // Aggiorna lista canzoni
          displaySongs();
        } catch (error) {
          console.error("Errore nella connessione al relay:", error);
          alert("Errore nella connessione al relay: " + error.message);
        }
      }

      document.getElementById("addRelay").addEventListener("click", () => {
        const address = document.getElementById("relayAddress").value.trim();
        if (!address) return alert("Inserisci un relay valido.");
        connectToRelay(address);
        document.getElementById("relayAddress").value = "";
      });

      // Inizializza
      loadRelays();
      displaySongs();
    </script>
  </body>
</html>
