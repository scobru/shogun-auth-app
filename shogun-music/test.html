<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Stazione Radio Decentralizzata</title>
    <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/radix.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/radisk.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/store.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/rindexed.js"></script>
    <script src="https://unpkg.com/wavesurfer.js@6.6.3/dist/wavesurfer.min.js"></script>

    <!-- Fallback per WaveSurfer in caso di problemi con il CDN principale -->
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        if (typeof WaveSurfer === "undefined") {
          console.warn(
            "WaveSurfer non caricato dal CDN principale, tentativo con CDN alternativo..."
          );
          const script = document.createElement("script");
          script.src =
            "https://cdnjs.cloudflare.com/ajax/libs/wavesurfer.js/6.6.3/wavesurfer.min.js";
          script.onload = () =>
            console.log("WaveSurfer caricato da CDN alternativo");
          script.onerror = () =>
            console.error("Impossibile caricare WaveSurfer da entrambi i CDN");
          document.head.appendChild(script);
        } else {
          console.log("WaveSurfer caricato correttamente dal CDN principale");
        }
      });
    </script>

    <style>
      body {
        font-family: sans-serif;
        padding: 20px;
        background: #f0f0f0;
      }
      h1 {
        text-align: center;
      }
      input,
      button {
        margin: 5px 0;
        padding: 8px;
        font-size: 1rem;
      }
      #waveform {
        margin-top: 20px;
        background: #fff;
        border-radius: 8px;
        height: 100px;
      }
      .song-card {
        background: white;
        padding: 15px;
        margin: 15px 0;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      #relayList {
        margin: 15px 0;
      }
      .relay-item {
        display: flex;
        align-items: center;
        background: white;
        padding: 10px;
        margin: 5px 0;
        border-radius: 8px;
      }
      .relay-item button {
        margin-left: 10px;
      }
      .artwork-preview {
        width: 100px;
        height: 100px;
        object-fit: cover;
        border-radius: 8px;
        margin-right: 15px;
      }
      .song-card {
        display: flex;
        align-items: center;
      }
      .song-card .song-info {
        flex-grow: 1;
      }
      .artwork-placeholder {
        width: 100px;
        height: 100px;
        background: #ddd;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 15px;
      }
      .upload-progress {
        margin-top: 10px;
        height: 20px;
        background-color: #eee;
        border-radius: 4px;
        overflow: hidden;
      }
      .progress-bar {
        height: 100%;
        background-color: #4caf50;
        width: 0%;
        transition: width 0.3s;
      }
      .status-badge {
        display: inline-block;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        margin-left: 10px;
      }
      .online {
        background-color: #4caf50;
        color: white;
      }
      .offline {
        background-color: #f44336;
        color: white;
      }
      .server-status {
        position: fixed;
        top: 10px;
        right: 10px;
        padding: 5px 10px;
        border-radius: 5px;
        font-size: 12px;
        z-index: 1000;
        cursor: pointer;
      }
      .status-online {
        background-color: #4CAF50;
        color: white;
      }
      .status-offline {
        background-color: #f44336;
        color: white;
      }
      .status-warning {
        background-color: #ff9800;
        color: white;
      }
      .server-details {
        position: fixed;
        top: 40px;
        right: 10px;
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 5px;
        padding: 10px;
        width: 300px;
        max-height: 400px;
        overflow-y: auto;
        z-index: 999;
        display: none;
      }
    </style>
  </head>
  <body>
    <h1>üéß Stazione Radio Decentralizzata</h1>
    <div id="peerStatus" style="text-align: center; margin-bottom: 10px">
      <span class="status-badge offline">Offline</span>
      <span id="connectedPeers">0 peers connessi</span>
    </div>

    <div>
      <input type="file" id="audioFile" accept="audio/*" />
      <input type="text" id="title" placeholder="Titolo" />
      <input type="text" id="artist" placeholder="Artista" />
      <input type="file" id="artworkFile" accept="image/*" />
      <label for="artworkFile">üñºÔ∏è Artwork</label>
      <div id="artworkPreview"></div>
      <button id="uploadBtn">üì§ Carica Traccia</button>
      <div id="uploadStatus"></div>
      <div class="upload-progress">
        <div class="progress-bar" id="progressBar"></div>
      </div>
    </div>

    <div id="waveform"></div>
    <button id="playBtn">‚ñ∂Ô∏è Play / Pause</button>

    <hr />

    <h2>üîå Relay</h2>
    <div>
      <input
        type="text"
        id="relayAddress"
        placeholder="http://localhost:8765/gun"
      />
      <button id="addRelay">Aggiungi Relay</button>
    </div>
    <div id="relayList"></div>

    <h2>üé∂ Canzoni</h2>
    <div id="songList"></div>

    <div class="server-status status-offline" id="serverStatus">Server: Verifica...</div>
    <div class="server-details" id="serverDetails"></div>

    <script>
      // Debug function per verificare lo stato dei chunks
      window.verificaChunks = function (trackId) {
        if (!trackId) {
          alert("Inserisci un ID traccia per verificare i chunks");
          return;
        }

        console.log(`Verificando chunks per traccia ${trackId}...`);

        tracksNode.get(`${trackId}_metadata`).once((metadata) => {
          if (!metadata) {
            console.error(`Nessun metadata trovato per traccia ${trackId}`);
            alert(`Nessun metadata trovato per traccia ${trackId}`);
            return;
          }

          console.log("Metadata:", metadata);

          if (!metadata.chunks) {
            console.log("La traccia non usa chunks");
            alert(`La traccia ${trackId} non usa chunks`);
            return;
          }

          console.log(
            `Traccia ${trackId} ha ${metadata.chunks} chunks. Verificando...`
          );
          let trovati = 0;
          let mancanti = [];

          for (let i = 0; i < metadata.chunks; i++) {
            tracksNode.get(`${trackId}_chunk_${i}`).once((chunk) => {
              if (chunk && chunk.data) {
                trovati++;
                console.log(`Chunk ${i} trovato (${chunk.data.length} bytes)`);
              } else {
                console.warn(`Chunk ${i} MANCANTE`);
                mancanti.push(i);
              }

              if (i === metadata.chunks - 1) {
                console.log(
                  `Verifica completata: ${trovati}/${metadata.chunks} chunks trovati`
                );
                if (mancanti.length > 0) {
                  console.warn(`Chunks mancanti: ${mancanti.join(", ")}`);
                  alert(
                    `Trovati ${trovati}/${
                      metadata.chunks
                    } chunks. Mancanti: ${mancanti.join(", ")}`
                  );
                } else {
                  alert(
                    `Tutti i ${metadata.chunks} chunks trovati correttamente!`
                  );
                }
              }
            });
          }
        });
      };

      // Aggiunge pulsante di debug nella UI
      document.addEventListener("DOMContentLoaded", function () {
        const debugDiv = document.createElement("div");
        debugDiv.innerHTML = `
      <hr>
      <h3>üîß Debug</h3>
      <input type="text" id="trackIdDebug" placeholder="ID Traccia">
      <button onclick="window.verificaChunks(document.getElementById('trackIdDebug').value)">
        Verifica Chunks
      </button>
    `;
        document.body.appendChild(debugDiv);
      });

      // Inizializzazione Gun e variabili
      // Inizializzazione WaveSurfer
      let wavesurfer;
      let isPlaying = false;
      let currentSongId = null;

      // Inizializzazione di Gun
      // Replace old Gun initialization with our new method
      window.gun = null; // Will be set in setupGunWithRetry
      
      const songs = gun ? gun.get('songs') : null;
      const relays = gun ? gun.get('relays') : null;

      document.addEventListener('DOMContentLoaded', function() {
        // Avvia il monitoraggio del server
        checkServerStatus();
        serverMonitoringInterval = setInterval(checkServerStatus, 10000); // Controllo ogni 10 secondi
        
        // Usa il nuovo setup di Gun con retry
        window.gun = setupGunWithRetry();
        window.songs = gun.get('songs');
        window.relays = gun.get('relays');
        
        // Carica i dati
        loadRelays();
        displaySongs();
        
        // Inizializza WaveSurfer
        initWaveSurfer();
      });

      // Monitoraggio connessione
      gun.on("hi", (peer) => {
        console.log("Connesso al peer:", peer);
        peerStatus.className = "status-badge online";
        peerStatus.textContent = "Online";
        updatePeerCounter();
      });

      gun.on("bye", (peer) => {
        updatePeerCounter();
        if (Object.keys(gun._.opt.peers).length === 0) {
          peerStatus.className = "status-badge offline";
          peerStatus.textContent = "Offline";
        }
      });

      function updatePeerCounter() {
        const count = Object.keys(gun._.opt.peers).length;
        connectedPeers.textContent = `${count} peer${
          count !== 1 ? "s" : ""
        } connessi`;
      }

      // Converti file in base64 e dividi in chunk se necessario
      function fileToBase64(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.readAsDataURL(file);
          reader.onload = () => resolve(reader.result);
          reader.onerror = (error) => reject(error);
        });
      }

      // Aggiungiamo funzione per comprimere i dati Base64
      function compressBase64(base64Data) {
        try {
          console.log(`Compressione dati (lunghezza originale: ${base64Data.length})`);
          // Simple RLE-style compression for Base64
          let compressed = "";
          let count = 1;
          let currentChar = base64Data[0];
          
          for (let i = 1; i < base64Data.length; i++) {
            if (base64Data[i] === currentChar && count < 255) {
              count++;
            } else {
              // Usa un formato pi√π compatto: solo quando ci sono ripetizioni
              if (count > 3) {
                compressed += `${currentChar}#${count}`;
              } else {
                compressed += currentChar.repeat(count);
              }
              currentChar = base64Data[i];
              count = 1;
            }
          }
          
          // Aggiungi l'ultimo carattere
          if (count > 3) {
            compressed += `${currentChar}#${count}`;
          } else {
            compressed += currentChar.repeat(count);
          }
          
          console.log(`Compressione completata (lunghezza dopo: ${compressed.length}, risparmio: ${Math.round((1 - compressed.length/base64Data.length) * 100)}%)`);
          return compressed;
        } catch (e) {
          console.error("Errore nella compressione:", e);
          return base64Data; // In caso di errore, ritorna i dati originali
        }
      }
      
      // Aggiungiamo funzione per decomprimere i dati Base64
      function decompressBase64(compressedData) {
        try {
          console.log(`Decompressione dati (lunghezza compressa: ${compressedData.length})`);
          // Decomprime il formato RLE-style
          let decompressed = "";
          let i = 0;
          
          while (i < compressedData.length) {
            let char = compressedData[i];
            i++;
            
            if (i < compressedData.length && compressedData[i] === '#') {
              i++; // Salta il carattere #
              let countStr = "";
              while (i < compressedData.length && /[0-9]/.test(compressedData[i])) {
                countStr += compressedData[i];
                i++;
              }
              const count = parseInt(countStr, 10);
              decompressed += char.repeat(count);
            } else {
              decompressed += char;
            }
          }
          
          console.log(`Decompressione completata (lunghezza dopo: ${decompressed.length})`);
          return decompressed;
        } catch (e) {
          console.error("Errore nella decompressione:", e);
          return compressedData; // In caso di errore, ritorna i dati compressi
        }
      }

      // Dividi dati in chunks
      function splitIntoChunks(data, chunkSize = 20000) { // Ridotto a 20KB per chunk
        console.log(`Dividendo i dati in chunks (lunghezza dati: ${data.length})`);
        const chunks = [];
        for (let i = 0; i < data.length; i += chunkSize) {
          chunks.push(data.substring(i, i + chunkSize));
        }
        console.log(`Creati ${chunks.length} chunks (dimensione chunk: ${chunkSize})`);
        return chunks;
      }

      // Unisci chunks in un unico dato
      function joinChunks(chunks) {
        console.log(`Unendo ${chunks.length} chunks`);
        return chunks.join("");
      }

      // Converti base64 in Blob
      function base64ToBlob(base64, mimeType) {
        const byteString = atob(base64.split(",")[1]);
        const ab = new ArrayBuffer(byteString.length);
        const ia = new Uint8Array(ab);

        for (let i = 0; i < byteString.length; i++) {
          ia[i] = byteString.charCodeAt(i);
        }

        return new Blob([ab], { type: mimeType });
      }

      // Inizializza player audio
      function initPlayer(blob) {
        try {
          if (wavesurfer) wavesurfer.destroy();

          if (typeof WaveSurfer === "undefined") {
            console.error(
              "WaveSurfer non √® definito. Verifica che la libreria sia caricata correttamente."
            );
            alert(
              "Errore: impossibile caricare il player audio. Ricarica la pagina e riprova."
            );
            return;
          }

          wavesurfer = WaveSurfer.create({
            container: "#waveform",
            waveColor: "violet",
            progressColor: "purple",
            height: 100,
            responsive: true,
          });
          const objectURL = URL.createObjectURL(blob);
          wavesurfer.load(objectURL);
        } catch (error) {
          console.error("Errore nell'inizializzazione del player:", error);
          alert(
            "Errore nell'inizializzazione del player audio: " + error.message
          );
        }
      }

      document.getElementById("playBtn").addEventListener("click", () => {
        if (wavesurfer) wavesurfer.playPause();
      });

      // Preview dell'artwork
      document
        .getElementById("artworkFile")
        .addEventListener("change", function (event) {
          const file = event.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = function (e) {
              const preview = document.getElementById("artworkPreview");
              preview.innerHTML = `<img src="${e.target.result}" class="artwork-preview">`;
            };
            reader.readAsDataURL(file);
          }
        });

      // Gestione caricamento file
      document
        .getElementById("uploadBtn")
        .addEventListener("click", async () => {
          const fileInput = document.getElementById("audioFile");
          const artworkInput = document.getElementById("artworkFile");
          const title =
            document.getElementById("title").value || "Senza titolo";
          const artist =
            document.getElementById("artist").value || "Sconosciuto";
          const audioFile = fileInput.files[0];

          if (!audioFile) return alert("Seleziona un file audio.");

          // Verifica dimensione file
          const maxFileSizeMB = 10;
          if (audioFile.size > maxFileSizeMB * 1024 * 1024) {
            alert(
              `Il file √® troppo grande. Dimensione massima: ${maxFileSizeMB}MB`
            );
            return;
          }

          const progressBar = document.getElementById("progressBar");
          const uploadStatus = document.getElementById("uploadStatus");

          uploadStatus.innerText = "‚è≥ Preparazione per il caricamento...";
          progressBar.style.width = "10%";

          try {
            // Crea FormData per inviare i file al server
            const formData = new FormData();
            formData.append('audioFile', audioFile);
            formData.append('title', title);
            formData.append('artist', artist);
            
            if (artworkInput.files[0]) {
              formData.append('artworkFile', artworkInput.files[0]);
            }
            
            progressBar.style.width = "20%";
            uploadStatus.innerText = "‚è≥ Upload in corso...";
            
            // Invia i file al server tramite API REST
            const response = await fetch('/api/upload', {
              method: 'POST',
              body: formData
            });
            
            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(errorData.message || 'Errore durante l\'upload');
            }
            
            const result = await response.json();
            console.log('Upload completato:', result);
            
            // Aggiorna progress bar
            progressBar.style.width = "100%";
            uploadStatus.innerText = "‚úÖ Traccia caricata con successo!";
            
            // Reset form
            fileInput.value = "";
            artworkInput.value = "";
            document.getElementById("artworkPreview").innerHTML = "";
            document.getElementById("title").value = "";
            document.getElementById("artist").value = "";
            
            // Aggiorna la lista delle canzoni
            setTimeout(() => {
              displaySongs();
              progressBar.style.width = "0%";
            }, 2000);

          } catch (error) {
            console.error("Errore generale:", error);
            progressBar.style.width = "0%";
            uploadStatus.innerText = "‚ùå Errore: " + error.message;
          }
        });

      // Visualizza le canzoni
      function displaySongs() {
        const songList = document.getElementById('songList');
        songList.innerHTML = '<div class="loading">Caricamento tracce...</div>';
        
        // Usa la nuova API REST per ottenere le tracce
        fetch('/api/tracks')
          .then(response => {
            if (!response.ok) {
              throw new Error('Errore nel recupero delle tracce');
            }
            return response.json();
          })
          .then(data => {
            songList.innerHTML = '';
            
            if (!data.success) {
              throw new Error(data.message || 'Errore nel recupero delle tracce');
            }
            
            if (data.tracks.length === 0) {
              songList.innerHTML = '<div class="alert alert-info">Nessuna traccia disponibile</div>';
              return;
            }
            
            // Crea un elemento per ogni traccia
            data.tracks.forEach(song => {
              const songCard = document.createElement('div');
              songCard.className = 'card mb-3';
              songCard.id = `song-${song.id}`;
              
              // Contenuto card
              const cardBody = document.createElement('div');
              cardBody.className = 'card-body';
              
              // Se c'√® un artwork, lo mostriamo
              if (song.artwork_path) {
                const artwork = document.createElement('img');
                artwork.src = song.artwork_path;
                artwork.className = 'artwork-preview';
                artwork.alt = song.title;
                cardBody.appendChild(artwork);
              }
              
              // Titolo e artista
              const title = document.createElement('h5');
              title.className = 'card-title';
              title.textContent = song.title;
              
              const artist = document.createElement('p');
              artist.className = 'card-text';
              artist.textContent = song.artist || 'Artista sconosciuto';
              
              // Pulsanti di azione
              const btnPlay = document.createElement('button');
              btnPlay.className = 'btn btn-primary me-2';
              btnPlay.textContent = 'Play';
              btnPlay.onclick = function() {
                playSong(song.id, song);
              };
              
              const btnDelete = document.createElement('button');
              btnDelete.className = 'btn btn-danger';
              btnDelete.textContent = 'Elimina';
              btnDelete.onclick = function() {
                deleteSong(song.id);
              };
              
              // Assembla la card
              cardBody.appendChild(title);
              cardBody.appendChild(artist);
              cardBody.appendChild(btnPlay);
              cardBody.appendChild(btnDelete);
              songCard.appendChild(cardBody);
              songList.appendChild(songCard);
            });
          })
          .catch(error => {
            console.error('Errore nel caricamento delle tracce:', error);
            songList.innerHTML = `<div class="alert alert-danger">Errore: ${error.message}</div>`;
          });
      }

      // Aggiorna funzione deleteSong per usare l'API REST
      function deleteSong(id) {
        if (!id) {
          console.error('ID traccia non specificato');
          return;
        }
        
        if (confirm('Sei sicuro di voler eliminare questa canzone?')) {
          fetch(`/api/tracks/${id}`, {
            method: 'DELETE'
          })
          .then(response => {
            if (!response.ok) {
              throw new Error('Errore nell\'eliminazione della traccia');
            }
            return response.json();
          })
          .then(data => {
            if (data.success) {
              console.log('Traccia eliminata con successo');
              // Rimuovi l'elemento dalla UI
              const songElement = document.getElementById(`song-${id}`);
              if (songElement) {
                songElement.remove();
              }
              // Se non ci sono pi√π tracce, aggiorna la UI
              const songList = document.getElementById('songList');
              if (songList.children.length === 0) {
                songList.innerHTML = '<div class="alert alert-info">Nessuna traccia disponibile</div>';
              }
            } else {
              throw new Error(data.message || 'Errore nell\'eliminazione della traccia');
            }
          })
          .catch(error => {
            console.error('Errore nell\'eliminazione della traccia:', error);
            alert(`Errore: ${error.message}`);
          });
        }
      }

      // Gestione relay
      function loadRelays() {
        const relayList = document.getElementById('relayList');
        relayList.innerHTML = '';

        if (!window.relays) {
          console.warn('I relays non sono ancora inizializzati');
          return;
        }

        window.relays.map().once(function(relay, id) {
          if (relay) {
            const li = document.createElement('li');
            li.className = 'list-group-item d-flex justify-content-between align-items-center';
            li.textContent = relay.url;
            
            const btnDelete = document.createElement('button');
            btnDelete.className = 'btn btn-danger btn-sm';
            btnDelete.textContent = 'Elimina';
            btnDelete.onclick = function() {
              window.relays.get(id).put(null);
              li.remove();
            };
            
            li.appendChild(btnDelete);
            relayList.appendChild(li);
          }
        });
      }

      // Aggiorna funzione addRelay
      document.getElementById('addRelayForm').addEventListener('submit', function(e) {
        e.preventDefault();
        const relayAddress = document.getElementById('relayAddress').value;
        if (relayAddress) {
          if (!window.relays) {
            console.error('I relays non sono ancora inizializzati');
            return;
          }
          window.relays.set({url: relayAddress, added: new Date().toISOString()});
          document.getElementById('relayAddress').value = '';
          setTimeout(loadRelays, 500); // Ricarica i relay dopo un breve ritardo
        }
      });

      // Sistema di monitoraggio del server
      let serverMonitoringInterval;
      let serverOnline = false;
      let failedHealthchecks = 0;
      const maxConsecutiveFailures = 3;

      function checkServerStatus() {
        fetch('/healthcheck')
          .then(response => {
            if (!response.ok) {
              throw new Error('Stato server non OK');
            }
            return response.json();
          })
          .then(data => {
            serverOnline = true;
            failedHealthchecks = 0;
            updateServerStatusUI(data);
          })
          .catch(error => {
            console.error('Errore controllo server:', error);
            failedHealthchecks++;
            
            if (failedHealthchecks >= maxConsecutiveFailures) {
              serverOnline = false;
              updateServerStatusUI(null);
            } else {
              // Imposta lo stato di warning se ci sono fallimenti ma non abbiamo superato la soglia
              const statusEl = document.getElementById('serverStatus');
              statusEl.className = 'server-status status-warning';
              statusEl.textContent = `Server: Instabile (${failedHealthchecks}/${maxConsecutiveFailures})`;
            }
          });
      }

      function updateServerStatusUI(data) {
        const statusEl = document.getElementById('serverStatus');
        const detailsEl = document.getElementById('serverDetails');
        
        if (serverOnline && data) {
          statusEl.className = 'server-status status-online';
          statusEl.textContent = `Server: Online`;
          
          // Aggiorna i dettagli del server
          const memoryInfo = data.memory;
          const dbInfo = data.db;
          
          detailsEl.innerHTML = `
            <h4>Stato Server</h4>
            <p><strong>Uptime:</strong> ${Math.floor(data.uptime / 60)} minuti</p>
            <p><strong>Timestamp:</strong> ${new Date(data.timestamp).toLocaleTimeString()}</p>
            <h4>Memoria</h4>
            <p>RSS: ${memoryInfo.rss}</p>
            <p>Heap Totale: ${memoryInfo.heapTotal}</p>
            <p>Heap Usato: ${memoryInfo.heapUsed}</p>
            <h4>Database</h4>
            <p>Chiavi: ${dbInfo.keys}</p>
            <p>Dimensione: ${dbInfo.totalSizeMB.toFixed(2)} MB</p>
            <button id="cleanupBtn" class="btn btn-sm btn-warning">Esegui Cleanup</button>
          `;
          
          // Aggiungi event listener per il pulsante di cleanup
          document.getElementById('cleanupBtn').addEventListener('click', function() {
            fetch('/admin/cleanup', { method: 'POST' })
              .then(response => response.json())
              .then(data => {
                if (data.success) {
                  alert(`Cleanup completato! Rimossi ${data.cleanup.removedItems} elementi. Spazio liberato: ${data.cleanup.memorySaved}`);
                  checkServerStatus(); // Aggiorna lo stato
                } else {
                  alert('Errore durante il cleanup: ' + data.message);
                }
              })
              .catch(err => {
                console.error('Errore durante il cleanup:', err);
                alert('Errore di connessione durante il cleanup');
              });
          });
        } else {
          statusEl.className = 'server-status status-offline';
          statusEl.textContent = 'Server: Offline';
          detailsEl.innerHTML = '<p>Server non disponibile</p>';
        }
      }

      // Toggle dei dettagli del server
      document.getElementById('serverStatus').addEventListener('click', function() {
        const detailsEl = document.getElementById('serverDetails');
        detailsEl.style.display = detailsEl.style.display === 'none' ? 'block' : 'none';
      });

      // Miglioramento del meccanismo di retry per Gun
      function setupGunWithRetry() {
        let retryCount = 0;
        let gun = null;
        
        function connectGun() {
          console.log(`Tentativo di connessione a Gun (${retryCount + 1})...`);
          
          // Verifica se esiste gi√† un'istanza
          if (gun) {
            // Pulisci eventuali listener
            try {
              gun.off();
            } catch (e) {
              console.warn('Errore durante la disconnessione di Gun:', e);
            }
          }
          
          // Crea una nuova istanza con i parametri corretti
          gun = Gun({
            peers: ['http://localhost:3002/gun'],
            localStorage: false,
            radisk: false,
            store: null,
            radix: false,
            retry: 1500,
            max: 3,
            chunk: 10240,
            axe: false,
            // Aggiungi un timeout pi√π lungo per connessioni lente
            wait: 5000
          });
          
          // Aggiungi logger per Gun
          gun.on('hi', peer => {
            console.log('Connesso al peer:', peer);
            retryCount = 0; // Reset del contatore dei tentativi quando ci connettiamo
            
            // Aggiorna UI
            const statusEl = document.getElementById('serverStatus');
            statusEl.className = 'server-status status-online';
            statusEl.textContent = 'Server: Online';
          });
          
          gun.on('bye', peer => {
            console.log('Disconnesso dal peer:', peer);
          });
          
          // Gestione errori Gun
          gun.on('error', err => {
            console.error('Errore Gun:', err);
            handleGunError(err);
          });
          
          return gun;
        }
        
        function handleGunError(err) {
          // Controlla se l'errore √® dovuto a problemi di connessione
          if (err.toString().includes('disconnect') || err.toString().includes('timeout')) {
            retryCount++;
            
            const statusEl = document.getElementById('serverStatus');
            statusEl.className = 'server-status status-warning';
            statusEl.textContent = `Server: Riconnessione (${retryCount})`;
            
            if (retryCount <= 5) {
              console.log(`Riconnessione a Gun in ${1000 * retryCount}ms...`);
              setTimeout(() => {
                gun = connectGun();
              }, 1000 * retryCount); // Backoff esponenziale
            } else {
              console.error('Troppi tentativi di riconnessione, necessario refresh manuale');
              statusEl.className = 'server-status status-offline';
              statusEl.textContent = 'Server: Offline (refresh)';
            }
          }
        }
        
        // Connessione iniziale
        gun = connectGun();
        return gun;
      }

      // Aggiungere una funzione per riprodurre le canzoni
      function playSong(id, song) {
        console.log(`Riproducendo canzone con ID: ${id}`, song);
        
        if (!song || !song.audio_path) {
          alert('Audio non disponibile per questa canzone');
          return;
        }
        
        // Inizializza WaveSurfer se non √® ancora stato fatto
        if (!wavesurfer) {
          initWaveSurfer();
        }
        
        // Carica l'audio
        wavesurfer.load(song.audio_path);
        
        // Imposta eventi di WaveSurfer
        wavesurfer.on('ready', function() {
          wavesurfer.play();
          currentSongId = id;
        });
        
        wavesurfer.on('error', function(err) {
          console.error('Errore durante il caricamento dell\'audio:', err);
          alert('Errore durante il caricamento dell\'audio');
        });
      }
      
      // Inizializza WaveSurfer
      function initWaveSurfer() {
        if (wavesurfer) {
          wavesurfer.destroy();
        }
        
        wavesurfer = WaveSurfer.create({
          container: '#waveform',
          waveColor: 'violet',
          progressColor: 'purple',
          height: 100,
          responsive: true
        });
        
        // Aggiungi event listener per play/pause
        document.getElementById('playBtn').addEventListener('click', function() {
          if (wavesurfer) {
            wavesurfer.playPause();
          }
        });
      }
    </script>
  </body>
</html>
