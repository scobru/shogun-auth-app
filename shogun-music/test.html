<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Shogun Music - Player Decentralizzato</title>
    <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/radix.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/radisk.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/store.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/rindexed.js"></script>
    <script src="https://unpkg.com/wavesurfer.js@6.6.3/dist/wavesurfer.min.js"></script>

    <!-- Fallback per WaveSurfer in caso di problemi con il CDN principale -->
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        if (typeof WaveSurfer === "undefined") {
          console.warn(
            "WaveSurfer non caricato dal CDN principale, tentativo con CDN alternativo..."
          );
          const script = document.createElement("script");
          script.src =
            "https://cdnjs.cloudflare.com/ajax/libs/wavesurfer.js/6.6.3/wavesurfer.min.js";
          script.onload = () =>
            console.log("WaveSurfer caricato da CDN alternativo");
          script.onerror = () =>
            console.error("Impossibile caricare WaveSurfer da entrambi i CDN");
          document.head.appendChild(script);
        } else {
          console.log("WaveSurfer caricato correttamente dal CDN principale");
        }
      });
    </script>

    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        line-height: 1.6;
        color: #333;
        background-color: #f5f5f5;
      }
      h1,
      h2,
      h3 {
        color: #2c3e50;
      }
      .header-container {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }
      .status-container {
        display: flex;
        gap: 20px;
      }
      .server-status {
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 14px;
        font-weight: bold;
      }
      .status-online {
        background-color: #d4edda;
        color: #155724;
      }
      .status-offline {
        background-color: #f8d7da;
        color: #721c24;
      }
      .status-warning {
        background-color: #fff3cd;
        color: #856404;
      }
      .container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-gap: 20px;
      }
      @media (max-width: 768px) {
        .container {
          grid-template-columns: 1fr;
        }
      }
      .upload-container,
      .player-container,
      .playlist-container {
        background: white;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .form-group {
        margin-bottom: 15px;
      }
      label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
      }
      input[type="text"],
      input[type="file"] {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        box-sizing: border-box;
      }
      button {
        background-color: #4caf50;
        color: white;
        border: none;
        padding: 8px 16px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 14px;
        border-radius: 4px;
        cursor: pointer;
        margin-right: 5px;
      }
      button:hover {
        background-color: #45a049;
      }
      button.delete-btn {
        background-color: #f44336;
      }
      button.delete-btn:hover {
        background-color: #d32f2f;
      }
      .progress-container {
        width: 100%;
        background-color: #ddd;
        border-radius: 4px;
        margin-bottom: 15px;
      }
      .progress-bar {
        height: 10px;
        background-color: #4caf50;
        width: 0%;
        border-radius: 4px;
        transition: width 0.3s ease;
      }
      #uploadStatus {
        margin-top: 5px;
        font-size: 14px;
      }
      #songsList {
        list-style-type: none;
        padding: 0;
      }
      .song-item {
        display: flex;
        align-items: center;
        padding: 10px;
        border-bottom: 1px solid #eee;
        position: relative;
      }
      .song-item:hover {
        background-color: #f9f9f9;
      }
      .song-info {
        flex-grow: 1;
        padding-left: 15px;
      }
      .song-title {
        font-weight: bold;
        margin-bottom: 3px;
      }
      .song-artist {
        font-size: 14px;
        color: #666;
        margin: 0;
      }
      .song-actions {
        display: flex;
        gap: 5px;
      }
      .artwork {
        width: 50px;
        height: 50px;
        object-fit: cover;
        border-radius: 4px;
      }
      .artwork-placeholder {
        width: 50px;
        height: 50px;
        background-color: #ddd;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        color: #888;
      }
      .player-controls {
        display: flex;
        align-items: center;
        margin-top: 20px;
        gap: 10px;
      }
      .play-btn,
      .pause-btn {
        background-color: #2196f3;
        font-size: 16px;
        padding: 10px 20px;
      }
      .play-btn:hover,
      .pause-btn:hover {
        background-color: #0b7dda;
      }
      .now-playing {
        margin-bottom: 10px;
        padding: 10px;
        background-color: #e8f5e9;
        border-radius: 4px;
        display: flex;
        align-items: center;
      }
      .now-playing-info {
        margin-left: 15px;
      }
      #artworkPreview {
        margin-top: 10px;
      }
      #waveform {
        width: 100%;
        height: 100px;
        margin-top: 20px;
        background-color: #f5f5f5;
        border-radius: 4px;
      }
      .relay-container,
      .peer-container {
        background: white;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
      }
      .relay-input {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
      }
      .relay-input input {
        flex-grow: 1;
      }
      #relayList {
        list-style-type: none;
        padding: 0;
      }
      .relay-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px;
        border-bottom: 1px solid #eee;
        font-size: 14px;
      }
      .relay-item button {
        margin-left: 10px;
        padding: 4px 8px;
        font-size: 12px;
      }
      .status-badge {
        padding: 3px 6px;
        border-radius: 4px;
        font-size: 12px;
        margin-left: 10px;
      }
      .status-badge.online {
        background-color: #d4edda;
        color: #155724;
      }
      .status-badge.offline {
        background-color: #f8d7da;
        color: #721c24;
      }
      .status-badge.warning {
        background-color: #fff3cd;
        color: #856404;
      }
      .peer-status {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }
      .peer-actions {
        display: flex;
        gap: 10px;
      }
      .progress-inner {
        height: 100%;
        background-color: #3498db;
        width: 0%;
        animation: progress-animation 2s infinite ease-in-out;
      }

      @keyframes progress-animation {
        0% {
          width: 0%;
        }
        50% {
          width: 70%;
        }
        100% {
          width: 0%;
        }
      }

      .file-info {
        font-size: 0.8em;
        color: #7f8c8d;
        margin-top: 5px;
      }

      /* Stili per le operazioni di eliminazione */
      .song-card.deleting {
        opacity: 0.6;
        transform: scale(0.95);
        transition: all 0.3s ease;
        pointer-events: none; /* Impedisce interazioni durante l'eliminazione */
        position: relative;
        overflow: hidden;
      }

      .song-card.deleting::after {
        content: "Eliminazione...";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
      }

      .song-card.deleted {
        animation: deleteAnimation 0.5s ease forwards;
      }

      @keyframes deleteAnimation {
        0% {
          opacity: 0.6;
          transform: scale(0.95);
        }
        50% {
          opacity: 0.3;
          transform: scale(0.85) translateX(0);
        }
        100% {
          opacity: 0;
          transform: scale(0.8) translateX(-100%);
        }
      }

      /* Stili per messaggi di caricamento e errore */
      .loading,
      .error,
      .empty-library {
        padding: 20px;
        text-align: center;
        background-color: #f8f9fa;
        border-radius: 8px;
        margin: 20px 0;
        width: 100%;
      }

      .loading {
        color: #3498db;
        animation: pulse 1.5s infinite ease-in-out;
      }

      .error {
        color: #e74c3c;
        border-left: 4px solid #e74c3c;
      }

      .empty-library {
        color: #7f8c8d;
        font-style: italic;
      }

      @keyframes pulse {
        0% {
          opacity: 0.6;
        }
        50% {
          opacity: 1;
        }
        100% {
          opacity: 0.6;
        }
      }

      /* Stili per la modalit√† fallback */
      .song-card.fallback {
        background-color: #f8f9fa;
        border: 1px dashed #95a5a6;
      }

      .song-card.fallback .song-title::after {
        content: " (fallback)";
        color: #e74c3c;
        font-size: 0.8em;
        font-weight: normal;
        margin-left: 5px;
      }

      /* Responsive adjustments */
      @media (max-width: 700px) {
        .song-list {
          grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        }

        .input-group,
        .button-group {
          flex-direction: column;
        }

        .status-section {
          flex-direction: column;
          text-align: center;
        }

        #networkInfo {
          margin-top: 10px;
        }
      }
    </style>
  </head>
  <body>
    <div class="header-container">
      <h1>Shogun Music</h1>
      <div class="status-container">
        <div id="serverStatus" class="server-status status-offline">
          Server: Offline
        </div>
        <div id="serverDetails" style="display: none"></div>
      </div>
    </div>

    <!-- Nuova sezione per la gestione dei peer e relay -->
    <div class="peer-container">
      <h2>Gestione Peer e Relay</h2>

      <div class="peer-status" id="peerStatus">
        <div>
          <span>Stato Rete: </span>
          <span class="status-badge offline">Offline</span>
        </div>
        <div id="connectedPeers">0 peers connessi</div>
        <div class="peer-actions">
          <button id="refreshPeers">Aggiorna Peers</button>
          <button id="connectAll">Connetti a Tutti</button>
        </div>
      </div>

      <div class="relay-container">
        <h3>Relay Disponibili</h3>
        <div class="relay-input">
          <input
            type="text"
            id="relayUrl"
            placeholder="URL del relay (es. http://server:3000/gun)"
          />
          <button id="addRelay" type="button" onclick="window.addRelay(event)">Aggiungi Relay</button>
        </div>
        <ul id="relayList"></ul>
      </div>
    </div>

    <div class="container">
      <div class="upload-container">
        <h2>Carica Nuova Traccia</h2>
        <div class="form-group">
          <label for="uploadPeer">Carica su:</label>
          <select id="uploadPeer" class="form-control">
            <option value="http://localhost:3000" selected>
              Locale (http://localhost:3000)
            </option>
          </select>
        </div>
        <div class="form-group">
          <label for="title">Titolo</label>
          <input type="text" id="title" placeholder="Inserisci titolo" />
        </div>
        <div class="form-group">
          <label for="artist">Artista</label>
          <input type="text" id="artist" placeholder="Inserisci artista" />
        </div>
        <div class="form-group">
          <label for="audioFile">File Audio (MP3, OGG, WAV)</label>
          <input type="file" id="audioFile" accept="audio/*" />
        </div>
        <div class="form-group">
          <label for="artworkFile">Copertina (opzionale)</label>
          <input
            type="file"
            id="artworkFile"
            accept="image/*"
            onchange="previewArtwork(this)"
          />
          <div id="artworkPreview"></div>
        </div>
        <div class="progress-container">
          <div id="progressBar" class="progress-bar"></div>
        </div>
        <div id="uploadStatus"></div>
        <button id="uploadBtn">Carica</button>
      </div>

      <div class="player-container">
        <h2>Player</h2>
        <div class="now-playing" id="nowPlayingContainer" style="display: none">
          <div id="currentArtwork" class="artwork-placeholder">‚ô™</div>
          <div class="now-playing-info">
            <div id="currentTitle">Nessun brano selezionato</div>
            <div id="currentArtist"></div>
          </div>
        </div>
        <div id="waveform"></div>
        <div class="player-controls">
          <button id="playBtn" class="play-btn">‚ñ∫</button>
          <button id="pauseBtn" class="pause-btn" style="display: none">
            ‚ùö‚ùö
          </button>
          <div id="timeInfo">00:00 / 00:00</div>
        </div>
      </div>
    </div>

    <!-- Libreria brani -->
    <div class="playlist-container">
      <h3>Libreria Musicale</h3>
      <div style="margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
        <button onclick="displaySongs()" class="btn btn-sm btn-primary">Aggiorna lista</button>
        <span id="loadStatus"></span>
      </div>
      <ul id="songsList"></ul>
    </div>

    <script>
      // Debug function per verificare lo stato dei chunks
      window.verificaChunks = function (trackId) {
        if (!trackId) {
          alert("Inserisci un ID traccia per verificare i chunks");
          return;
        }

        console.log(`Verificando chunks per traccia ${trackId}...`);

        tracksNode.get(`${trackId}_metadata`).once((metadata) => {
          if (!metadata) {
            console.error(`Nessun metadata trovato per traccia ${trackId}`);
            alert(`Nessun metadata trovato per traccia ${trackId}`);
            return;
          }

          console.log("Metadata:", metadata);

          if (!metadata.chunks) {
            console.log("La traccia non usa chunks");
            alert(`La traccia ${trackId} non usa chunks`);
            return;
          }

          console.log(
            `Traccia ${trackId} ha ${metadata.chunks} chunks. Verificando...`
          );
          let trovati = 0;
          let mancanti = [];

          for (let i = 0; i < metadata.chunks; i++) {
            tracksNode.get(`${trackId}_chunk_${i}`).once((chunk) => {
              if (chunk && chunk.data) {
                trovati++;
                console.log(`Chunk ${i} trovato (${chunk.data.length} bytes)`);
              } else {
                console.warn(`Chunk ${i} MANCANTE`);
                mancanti.push(i);
              }

              if (i === metadata.chunks - 1) {
                console.log(
                  `Verifica completata: ${trovati}/${metadata.chunks} chunks trovati`
                );
                if (mancanti.length > 0) {
                  console.warn(`Chunks mancanti: ${mancanti.join(", ")}`);
                  alert(
                    `Trovati ${trovati}/${
                      metadata.chunks
                    } chunks. Mancanti: ${mancanti.join(", ")}`
                  );
                } else {
                  alert(
                    `Tutti i ${metadata.chunks} chunks trovati correttamente!`
                  );
                }
              }
            });
          }
        });
      };

      // Aggiunge pulsante di debug nella UI
      document.addEventListener("DOMContentLoaded", function () {
        const debugDiv = document.createElement("div");
        debugDiv.innerHTML = `
      <hr>
      <h3>üîß Debug</h3>
      <input type="text" id="trackIdDebug" placeholder="ID Traccia">
      <button onclick="window.verificaChunks(document.getElementById('trackIdDebug').value)">
        Verifica Chunks
      </button>
    `;
        document.body.appendChild(debugDiv);
      });

      // Sistema di monitoraggio del server
      let serverMonitoringInterval;
      let serverOnline = false;
      let failedHealthchecks = 0;
      const maxConsecutiveFailures = 3;

      // Inizializzazione Gun e variabili
      // Inizializzazione WaveSurfer
      let wavesurfer;
      let isPlaying = false;
      let currentSongId = null;

      // Inizializzazione di Gun
      // Replace old Gun initialization with our new method
      window.gun = null; // Will be set in setupGunWithRetry

      // Funzione per inizializzare Gun con retry automatico in caso di problemi di connessione
      function setupGunWithRetry() {
        try {
          console.log("Inizializzazione Gun.js con opzione di retry...");
          
          // Opzioni base per Gun
          const gunOptions = {
            peers: { 'http://localhost:3000/gun': {} }, // Peer di default
            localStorage: true,       // Usa localStorage per persistenza
            multicast: false,         // Disabilita multicast per evitare problemi
            retry: 2000,              // Riprova ogni 2 secondi
            axe: false,               // Disabilita AXE per evitare problemi
            WebSocket: window.WebSocket // Usa WebSocket del browser
          };
          
          // Crea istanza Gun
          const gunInstance = Gun(gunOptions);
          
          // Configura handler errori e debug
          gunInstance.on('error', function(err) {
            console.error("Errore Gun.js:", err);
          });
          
          console.log("Gun.js inizializzato con successo");
          return gunInstance;
        } catch (error) {
          console.error("Errore nella configurazione di Gun.js:", error);
          
          // Fallback a configurazione minima
          console.warn("Tentativo fallback con configurazione minima Gun.js");
          try {
            return Gun({ peers: { 'http://localhost:3000/gun': {} } });
          } catch (fallbackError) {
            console.error("Anche il fallback Gun.js √® fallito:", fallbackError);
            // Ritorna un oggetto fittizio per evitare errori
            return {
              get: function() { return { get: function() { return {}; } }; },
              on: function() {},
              _: { opt: { peers: {} } }
            };
          }
        }
      }

      document.addEventListener("DOMContentLoaded", function () {
        // Usa il nuovo setup di Gun con retry
        window.gun = setupGunWithRetry();
        
        // Inizializza le variabili Gun dopo averlo configurato
        window.songs = gun.get('songs');
        window.relays = gun.get('relays');
        
        // Avvia il monitoraggio del server
        checkServerStatus();
        serverMonitoringInterval = setInterval(checkServerStatus, 10000); // Controllo ogni 10 secondi
        
        // Carica i dati
        loadRelays();
        displaySongs();
        
        // Inizializza WaveSurfer
        initWaveSurfer();
        
        // Monitoraggio connessione
        const peerStatus = document.querySelector('#peerStatus .status-badge');
        const connectedPeers = document.getElementById('connectedPeers');
        
        gun.on("hi", (peer) => {
          console.log("Connesso al peer:", peer);
          peerStatus.className = "status-badge online";
          peerStatus.textContent = "Online";
          updatePeerCounter();
        });
        
        gun.on("bye", (peer) => {
          updatePeerCounter();
          if (Object.keys(gun._.opt.peers).length === 0) {
            peerStatus.className = "status-badge offline";
            peerStatus.textContent = "Offline";
          }
        });
        
        function updatePeerCounter() {
          const count = Object.keys(gun._.opt.peers).length;
          connectedPeers.textContent = `${count} peer${
            count !== 1 ? "s" : ""
          } connessi`;
        }
        
        // Toggle dei dettagli del server
        document
          .getElementById("serverStatus")
          .addEventListener("click", function () {
            const detailsEl = document.getElementById("serverDetails");
            if (detailsEl) {
              detailsEl.style.display =
                detailsEl.style.display === "none" ? "block" : "none";
            }
          });
      });

      // Converti file in base64 e dividi in chunk se necessario
      function fileToBase64(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.readAsDataURL(file);
          reader.onload = () => resolve(reader.result);
          reader.onerror = (error) => reject(error);
        });
      }

      // Aggiungiamo funzione per comprimere i dati Base64
      function compressBase64(base64Data) {
        try {
          console.log(
            `Compressione dati (lunghezza originale: ${base64Data.length})`
          );
          // Simple RLE-style compression for Base64
          let compressed = "";
          let count = 1;
          let currentChar = base64Data[0];

          for (let i = 1; i < base64Data.length; i++) {
            if (base64Data[i] === currentChar && count < 255) {
              count++;
            } else {
              // Usa un formato pi√π compatto: solo quando ci sono ripetizioni
              if (count > 3) {
                compressed += `${currentChar}#${count}`;
              } else {
                compressed += currentChar.repeat(count);
              }
              currentChar = base64Data[i];
              count = 1;
            }
          }

          // Aggiungi l'ultimo carattere
          if (count > 3) {
            compressed += `${currentChar}#${count}`;
          } else {
            compressed += currentChar.repeat(count);
          }

          console.log(
            `Compressione completata (lunghezza dopo: ${
              compressed.length
            }, risparmio: ${Math.round(
              (1 - compressed.length / base64Data.length) * 100
            )}%)`
          );
          return compressed;
        } catch (e) {
          console.error("Errore nella compressione:", e);
          return base64Data; // In caso di errore, ritorna i dati originali
        }
      }

      // Aggiungiamo funzione per decomprimere i dati Base64
      function decompressBase64(compressedData) {
        try {
          console.log(
            `Decompressione dati (lunghezza compressa: ${compressedData.length})`
          );
          // Decomprime il formato RLE-style
          let decompressed = "";
          let i = 0;

          while (i < compressedData.length) {
            let char = compressedData[i];
            i++;

            if (i < compressedData.length && compressedData[i] === "#") {
              i++; // Salta il carattere #
              let countStr = "";
              while (
                i < compressedData.length &&
                /[0-9]/.test(compressedData[i])
              ) {
                countStr += compressedData[i];
                i++;
              }
              const count = parseInt(countStr, 10);
              decompressed += char.repeat(count);
            } else {
              decompressed += char;
            }
          }

          console.log(
            `Decompressione completata (lunghezza dopo: ${decompressed.length})`
          );
          return decompressed;
        } catch (e) {
          console.error("Errore nella decompressione:", e);
          return compressedData; // In caso di errore, ritorna i dati compressi
        }
      }

      // Dividi dati in chunks
      function splitIntoChunks(data, chunkSize = 20000) {
        // Ridotto a 20KB per chunk
        console.log(
          `Dividendo i dati in chunks (lunghezza dati: ${data.length})`
        );
        const chunks = [];
        for (let i = 0; i < data.length; i += chunkSize) {
          chunks.push(data.substring(i, i + chunkSize));
        }
        console.log(
          `Creati ${chunks.length} chunks (dimensione chunk: ${chunkSize})`
        );
        return chunks;
      }

      // Unisci chunks in un unico dato
      function joinChunks(chunks) {
        console.log(`Unendo ${chunks.length} chunks`);
        return chunks.join("");
      }

      // Converti base64 in Blob
      function base64ToBlob(base64, mimeType) {
        const byteString = atob(base64.split(",")[1]);
        const ab = new ArrayBuffer(byteString.length);
        const ia = new Uint8Array(ab);

        for (let i = 0; i < byteString.length; i++) {
          ia[i] = byteString.charCodeAt(i);
        }

        return new Blob([ab], { type: mimeType });
      }

      // Inizializza player audio
      function initPlayer(blob) {
        try {
          if (wavesurfer) wavesurfer.destroy();

          if (typeof WaveSurfer === "undefined") {
            console.error(
              "WaveSurfer non √® definito. Verifica che la libreria sia caricata correttamente."
            );
            alert(
              "Errore: impossibile caricare il player audio. Ricarica la pagina e riprova."
            );
            return;
          }

          wavesurfer = WaveSurfer.create({
            container: "#waveform",
            waveColor: "violet",
            progressColor: "purple",
            height: 100,
            responsive: true,
          });
          const objectURL = URL.createObjectURL(blob);
          wavesurfer.load(objectURL);
        } catch (error) {
          console.error("Errore nell'inizializzazione del player:", error);
          alert(
            "Errore nell'inizializzazione del player audio: " + error.message
          );
        }
      }

      document.getElementById("playBtn").addEventListener("click", () => {
        if (wavesurfer) wavesurfer.playPause();
      });

      // Preview dell'artwork
      document
        .getElementById("artworkFile")
        .addEventListener("change", function (event) {
          const file = event.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = function (e) {
              const preview = document.getElementById("artworkPreview");
              preview.innerHTML = `<img src="${e.target.result}" class="artwork-preview">`;
            };
            reader.readAsDataURL(file);
          }
        });

      // Gestione caricamento file
      document
        .getElementById("uploadBtn")
        .addEventListener("click", async function () {
          const fileInput = document.getElementById("audioFile");
          const artworkInput = document.getElementById("artworkFile");
          const title =
            document.getElementById("title").value || "Senza titolo";
          const artist =
            document.getElementById("artist").value || "Artista sconosciuto";
          const audioFile = fileInput.files[0];

          if (!audioFile) {
            alert("Seleziona un file audio.");
            return;
          }

          // Ottieni il peer selezionato per l'upload
          const uploadPeerSelect = document.getElementById("uploadPeer");
          const selectedPeer = uploadPeerSelect
            ? uploadPeerSelect.value
            : "http://localhost:3000";

          console.log(`Preparazione upload su peer: ${selectedPeer}`);

          // Verifica dimensione file - riduciamo ulteriormente la dimensione massima
          const maxFileSizeMB = 20; // Ridotto da 20MB a 5MB per evitare problemi di dimensione payload
          if (audioFile.size > maxFileSizeMB * 1024 * 1024) {
            alert(
              `Il file √® troppo grande (${(
                audioFile.size /
                (1024 * 1024)
              ).toFixed(2)}MB). Dimensione massima: ${maxFileSizeMB}MB`
            );
            return;
          }

          const progressBar = document.getElementById("progressBar");
          const uploadStatus = document.getElementById("uploadStatus");

          uploadStatus.innerText = "‚è≥ Preparazione per il caricamento...";
          progressBar.style.width = "10%";

          try {
            // Crea FormData per inviare i file al server
            const formData = new FormData();
            formData.append("audioFile", audioFile);
            formData.append("title", title);
            formData.append("artist", artist);

            if (artworkInput.files[0]) {
              // Verifica anche la dimensione dell'artwork
              if (artworkInput.files[0].size > 500 * 1024) {
                // Max 500KB per l'artwork
                alert(`L'artwork √® troppo grande. Dimensione massima: 500KB`);
                progressBar.style.width = "0%";
                uploadStatus.innerText = "‚ùå Artwork troppo grande";
                return;
              }
              formData.append("artworkFile", artworkInput.files[0]);
            }

            progressBar.style.width = "20%";
            uploadStatus.innerText = `‚è≥ Upload in corso su ${selectedPeer}...`;

            // Invia i file al server tramite API REST con gestione timeouts e retry
            let attempts = 0;
            const maxAttempts = 3;
            let success = false;

            async function attemptUpload() {
              try {
                // Aggiungiamo timeout pi√π lungo e segnaliamo progress
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000); // 60 sec timeout

                // Usa il peer selezionato per l'upload - IMPORTANTE: correzione URL
                // Assicuriamoci di usare /api/upload e non /gun/api/upload
                const uploadUrl = `${selectedPeer}/api/upload`;
                console.log(`Tentativo upload su: ${uploadUrl}`, {
                  audioSize: (audioFile.size / 1024).toFixed(2) + "KB",
                  artworkSize: artworkInput.files[0]
                    ? (artworkInput.files[0].size / 1024).toFixed(2) + "KB"
                    : "none",
                });

                progressBar.style.width = "40%";

                const response = await fetch(uploadUrl, {
                  method: "POST",
                  body: formData,
                  signal: controller.signal,
                });

                clearTimeout(timeoutId);

                if (response.status === 413) {
                  throw new Error(
                    "Il file √® troppo grande per il server. Riduci la dimensione del file audio."
                  );
                }

                progressBar.style.width = "80%";

                if (!response.ok) {
                  const errorText = await response.text();
                  console.error(
                    "Risposta server non OK:",
                    response.status,
                    errorText
                  );
                  throw new Error(
                    `Errore server: ${response.status} ${errorText}`
                  );
                }

                const result = await response.json();
                console.log("Upload completato:", result);

                // Aggiorna progress bar
                progressBar.style.width = "100%";
                uploadStatus.innerText = `‚úÖ Traccia caricata con successo su ${selectedPeer}!`;

                // Reset form
                fileInput.value = "";
                artworkInput.value = "";
                document.getElementById("artworkPreview").innerHTML = "";
                document.getElementById("title").value = "";
                document.getElementById("artist").value = "";

                // Aggiorna la lista delle canzoni
                setTimeout(() => {
                  console.log("Aggiorno lista canzoni dopo upload");
                  displaySongs();
                  progressBar.style.width = "0%";
                }, 2000);
              } catch (err) {
                console.error("Errore durante upload:", err);

                if (err.name === "AbortError") {
                  console.error("Richiesta interrotta per timeout");
                  throw new Error(
                    "Timeout durante l'upload. Il server potrebbe essere sovraccarico."
                  );
                }

                if (
                  attempts < maxAttempts &&
                  !err.message.includes("troppo grande")
                ) {
                  attempts++;
                  console.log(`Tentativo ${attempts}/${maxAttempts}`);
                  progressBar.style.width = `${20 + attempts * 10}%`;
                  uploadStatus.innerText = `‚è≥ Nuovo tentativo (${attempts}/${maxAttempts})...`;

                  // Attendi un po' prima di riprovare
                  await new Promise((resolve) => setTimeout(resolve, 2000));
                  return await attemptUpload();
                } else {
                  throw err;
                }
              }
            }

            await attemptUpload();
          } catch (error) {
            console.error("Errore generale:", error);
            progressBar.style.width = "0%";
            uploadStatus.innerText = "‚ùå Errore: " + error.message;
          }
        });

      // Visualizza le canzoni
      function displaySongs() {
        const songsList = document.getElementById("songsList");
        if (!songsList) {
          console.error("Elemento 'songsList' non trovato nel DOM");
          return;
        }

        songsList.innerHTML =
          '<div class="loading">Caricamento tracce...</div>';

        // Usa la nuova API REST per ottenere le tracce
        fetch("http://localhost:3000/api/tracks")
          .then((response) => {
            if (!response.ok) {
              throw new Error("Errore nel recupero delle tracce");
            }
            return response.json();
          })
          .then((data) => {
            console.log("Risposta API tracks:", data);
            songsList.innerHTML = "";

            if (!data.success) {
              throw new Error(
                data.message || "Errore nel recupero delle tracce"
              );
            }

            if (!data.tracks || data.tracks.length === 0) {
              songsList.innerHTML =
                '<div class="alert alert-info">Nessuna traccia disponibile</div>';
              return;
            }

            console.log(
              `Ricevute ${data.tracks.length} tracce da visualizzare`
            );

            // Creiamo un insieme con gli ID delle tracce per eliminare eventuali duplicati
            const uniqueTrackIds = new Set();
            const uniqueTracks = [];

            // Filtra i duplicati basandosi sugli ID
            data.tracks.forEach((track) => {
              if (track && track.id && !uniqueTrackIds.has(track.id)) {
                uniqueTrackIds.add(track.id);
                uniqueTracks.push(track);
              }
            });

            console.log(
              `Dopo rimozione duplicati: ${uniqueTracks.length} tracce da visualizzare`
            );

            // Crea un elemento per ogni traccia
            uniqueTracks.forEach((song) => {
              if (!song || !song.id) {
                console.warn("Traccia invalida saltata:", song);
                return; // Salta tracce invalide
              }

              console.log(
                `Creazione elemento per traccia ${song.id}: ${song.title}`
              );

              const li = document.createElement("li");
              li.className = "song-item";
              li.id = `song-${song.id}`;

              // Se c'√® un artwork, lo mostriamo
              if (song.artwork_path) {
                const artwork = document.createElement("img");
                // Assicuriamoci che l'URL sia completo
                if (song.artwork_path.startsWith("http")) {
                  artwork.src = song.artwork_path;
                } else {
                  artwork.src = `http://localhost:3000${song.artwork_path}`;
                }
                artwork.className = "artwork";
                artwork.alt = song.title || "Senza titolo";
                artwork.onerror = function () {
                  console.error(`Errore caricamento artwork: ${artwork.src}`);
                  // Sostituisci con placeholder
                  this.outerHTML = '<div class="artwork-placeholder">‚ô™</div>';
                };
                li.appendChild(artwork);
              } else {
                // Placeholder per artwork mancante
                const artworkPlaceholder = document.createElement("div");
                artworkPlaceholder.className = "artwork-placeholder";
                artworkPlaceholder.innerHTML = "&#9835;"; // Emoji nota musicale HTML entity
                li.appendChild(artworkPlaceholder);
              }

              const songInfo = document.createElement("div");
              songInfo.className = "song-info";

              // Titolo e artista
              const titleEl = document.createElement("div");
              titleEl.className = "song-title";
              titleEl.textContent = song.title || "Senza titolo";

              const artistEl = document.createElement("div");
              artistEl.className = "song-artist";
              artistEl.textContent = song.artist || "Artista sconosciuto";

              songInfo.appendChild(titleEl);
              songInfo.appendChild(artistEl);
              li.appendChild(songInfo);

              // Pulsanti di azione
              const actionDiv = document.createElement("div");
              actionDiv.className = "song-actions";

              const btnPlay = document.createElement("button");
              btnPlay.textContent = "Play";
              btnPlay.onclick = function () {
                playSong(song.id, song);
              };

              const btnDelete = document.createElement("button");
              btnDelete.textContent = "Elimina";
              btnDelete.className = "delete-btn";
              btnDelete.onclick = function () {
                deleteSong(song.id);
              };

              actionDiv.appendChild(btnPlay);
              actionDiv.appendChild(btnDelete);
              li.appendChild(actionDiv);

              songsList.appendChild(li);
            });
          })
          .catch((error) => {
            console.error("Errore nel caricamento delle tracce:", error);
            songsList.innerHTML = `<div style="color: red; padding: 10px; background: #ffeeee; border-radius: 5px;">Errore: ${error.message}</div>`;

            // Riprova dopo 10 secondi se il server potrebbe essere offline
            setTimeout(() => {
              if (songsList.innerHTML.includes("Errore")) {
                displaySongs();
              }
            }, 10000);
          });
      }

      // Aggiorna funzione deleteSong per usare l'API REST
      function deleteSong(trackId) {
        if (!trackId) {
          console.error("ID della traccia mancante");
          return;
        }
        
        // Chiedi conferma all'utente prima di eliminare
        if (!confirm(`Sei sicuro di voler eliminare questa traccia (ID: ${trackId})?`)) {
          return;
        }
        
        console.log(`Eliminazione traccia con ID: ${trackId}`);
        
        // Mostra lo stato dell'operazione se l'elemento esiste
        const statusEl = document.getElementById('loadStatus');
        if (statusEl) {
          statusEl.textContent = `Eliminazione in corso...`;
        }
        
        // Aggiungi classe di eliminazione alla card
        const songCard = document.querySelector(`.song-card[data-id="${trackId}"]`);
        if (songCard) {
          songCard.classList.add('deleting');
        }
        
        // Configura timeout per la richiesta
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 sec timeout
        
        // Effettua la richiesta DELETE con anti-cache headers
        fetch(`http://localhost:3000/api/tracks/${trackId}`, {
          method: 'DELETE',
          headers: {
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache',
            'Expires': '0'
          },
          signal: controller.signal
        })
        .then(response => {
          clearTimeout(timeoutId);
          
          // Controllo specifico per 404 con messaggi personalizzati
          if (response.status === 404) {
            return response.text().then(text => {
              console.warn(`Server ha risposto 404: ${text}`);
              throw new Error('Traccia non trovata sul server. Potrebbe essere gi√† stata eliminata.');
            });
          }
          
          // Controllo per altri errori
          if (!response.ok) {
            return response.text().then(text => {
              console.error(`Errore del server (${response.status}): ${text}`);
              throw new Error(`Errore del server: ${response.status} - ${text}`);
            });
          }
          
          // Gestione della risposta
          return response.text().then(text => {
            let data;
            try {
              // Tenta di analizzare come JSON
              data = JSON.parse(text);
            } catch (e) {
              // Se non √® JSON valido, usa il testo come messaggio di risposta
              console.log('Risposta non JSON:', text);
              return { success: true, message: text || 'Operazione completata' };
            }
            return data;
          });
        })
        .then(data => {
          console.log('Risposta eliminazione:', data);
          
          // Verifica lo stato della risposta
          if (data.success === false) {
            throw new Error(data.message || 'Errore durante l\'eliminazione');
          }
          
          // Rimuovi l'elemento dalla UI
          if (songCard) {
            songCard.classList.add('deleted');
            // Rimuovi dopo l'animazione
            setTimeout(() => {
              songCard.remove();
            }, 500);
          }
          
          // Aggiorna lo stato se l'elemento esiste
          if (statusEl) {
            statusEl.textContent = 'Traccia eliminata con successo';
          }
          
          // Aggiorna anche direttamente in Gun per sincronizzazione
          try {
            if (window.songs) {
              console.log('Rimozione della traccia anche da Gun...');
              window.songs.get(trackId).put(null);
              
              // Rimuovi anche eventuali chunks
              let chunkIndex = 0;
              const maxChunks = 100; // Limite di sicurezza
              
              const removeChunks = (index) => {
                if (index >= maxChunks) return;
                
                const chunkId = `${trackId}_chunk_${index}`;
                window.songs.get(chunkId).once((chunk) => {
                  if (chunk) {
                    console.log(`Rimozione chunk ${index}...`);
                    window.songs.get(chunkId).put(null);
                    removeChunks(index + 1);
                  }
                });
              };
              
              removeChunks(0);
            }
          } catch (e) {
            console.warn('Errore durante la pulizia in Gun:', e);
          }
          
          // Ricarica la lista delle canzoni dopo un breve ritardo
          setTimeout(() => {
            console.log('Ricarico la lista dopo eliminazione');
            if (typeof loadSongs === 'function') {
              loadSongs();
            } else if (typeof displaySongs === 'function') {
              displaySongs();
            }
          }, 1000);
        })
        .catch(error => {
          console.error('Errore durante l\'eliminazione:', error);
          
          // Rimuovi la classe di eliminazione dalla card
          if (songCard) {
            songCard.classList.remove('deleting');
          }
          
          // Gestione specifica per timeout
          if (error.name === 'AbortError') {
            if (statusEl) {
              statusEl.textContent = 'Timeout durante l\'eliminazione';
            }
            alert('L\'operazione √® durata troppo a lungo. Riprova pi√π tardi.');
          } else {
            if (statusEl) {
              statusEl.textContent = `Errore: ${error.message}`;
            }
            alert(`Errore durante l'eliminazione: ${error.message}`);
          }
          
          // Ricarica comunque la lista dopo un errore per aggiornare lo stato
          setTimeout(() => {
            if (typeof loadSongs === 'function') {
              loadSongs();
            } else if (typeof displaySongs === 'function') {
              displaySongs();
            }
          }, 3000);
        });
      }

      // Gestione relay
      function loadRelays() {
        console.log('Caricamento dei relay salvati...');
        
        // Pulisci il div
        const relayListDiv = document.getElementById('relayList');
        if (relayListDiv) {
          relayListDiv.innerHTML = '';
        } else {
          console.error('Elemento relayList non trovato');
          return;
        }
        
        // Aggiungi sempre il server locale come primo relay
        const localPeerItem = document.createElement('li');
        localPeerItem.innerHTML = `http://localhost:3000 <span class="status-connected">locale</span>`;
        relayListDiv.appendChild(localPeerItem);
        
        // Carica i relay salvati
        window.relays.map().once(function(relay) {
          if (relay && relay.url) {
            const relayItem = document.createElement('li');
            relayItem.innerHTML = `${relay.url} <span class="status-disconnected">disconnesso</span>`;
            
            // Aggiungi pulsante per rimuovere il relay
            const removeButton = document.createElement('button');
            removeButton.innerHTML = 'Rimuovi';
            removeButton.className = 'remove-relay';
            removeButton.onclick = function() {
              if (confirm('Sei sicuro di voler rimuovere questo relay?')) {
                // Rimuovi dalla memoria Gun
                window.relays.get(relay._['#']).put(null);
                // Rimuovi anche dalla lista di peer attivi
                if (window.gun && window.gun._ && window.gun._.opt && window.gun._.opt.peers) {
                  let peerUrl = relay.url;
                  if (!peerUrl.endsWith('/gun')) {
                    peerUrl = peerUrl.endsWith('/') ? peerUrl + 'gun' : peerUrl + '/gun';
                  }
                  delete window.gun._.opt.peers[peerUrl];
                }
                // Rimuovi dalla UI
                relayItem.remove();
                // Aggiorna la lista dei peer per l'upload
                setTimeout(updatePeerList, 500);
              }
            };
            relayItem.appendChild(removeButton);
            
            relayListDiv.appendChild(relayItem);
          }
        });
      }

      // Connetti a tutti i relay salvati
      function connectToAllRelays() {
        try {
          console.log('Tentativo di connessione a tutti i relay...');
          
          // Raccogli tutti i relay
          const relays = [];
          
          // Aggiungi il server locale
          relays.push('http://localhost:3000');
          
          // Raccoglie gli altri relay
          window.relays.map().once(function(relay) {
            if (relay && relay.url) {
              relays.push(relay.url);
            }
          });
          
          console.log('Connessione a tutti i relay:', relays);
          
          // Aggiungi sempre il peer locale
          const peerUrls = [];
          
          // Aggiungi prima il peer locale se non √® gi√† presente
          const localPeerUrl = 'http://localhost:3000/gun';
          if (!peerUrls.includes(localPeerUrl)) {
            peerUrls.push(localPeerUrl);
          }
          
          // Aggiungi gli altri relay solo se hanno un formato URL valido e non sono duplicati
          relays.forEach(relay => {
            // Assicurati che l'URL termini con /gun altrimenti aggiungilo
            let relayUrl = relay;
            if (relay && !relay.endsWith('/gun')) {
              relayUrl = relay.endsWith('/') ? relay + 'gun' : relay + '/gun';
            }
            
            if (relayUrl && relayUrl.startsWith('http') && !peerUrls.includes(relayUrl)) {
              peerUrls.push(relayUrl);
            }
          });
          
          console.log('Peer URLs finali:', peerUrls);
          
          // Aggiorna UI
          const statusEl = document.getElementById('serverStatus');
          if (statusEl) {
            statusEl.className = "server-status status-warning";
            statusEl.textContent = "Connessione ai peer...";
          }
          
          // Verifica che Gun sia inizializzato correttamente
          if (!window.gun || !window.gun._ || !window.gun._.opt) {
            console.error('Gun non √® inizializzato correttamente');
            alert('Errore: Gun non √® inizializzato. Ricarica la pagina e riprova.');
            return;
          }
          
          // Rimuovi vecchi peer per evitare duplicati
          if (window.gun._.opt.peers) {
            Object.keys(window.gun._.opt.peers).forEach(peer => {
              console.log(`Rimozione peer esistente: ${peer}`);
              delete window.gun._.opt.peers[peer];
            });
          } else {
            window.gun._.opt.peers = {};
          }
          
          // Connessione a tutti i peer
          let connectedCount = 0;
          
          // FONDAMENTALE: Imposta limiti molto bassi per i messaggi per evitare "Message too big!"
          // Questo √® il problema principale che causa la disconnessione immediata dei peer
          
          // Aggiungi filtri per i messaggi sia in entrata che in uscita
          // Imposta un limite MOLTO PICCOLO per i messaggi
          
          // Filtra messaggi in entrata
          window.gun._.on('in', function(msg) {
            try {
              if (msg && msg.put) {
                const size = JSON.stringify(msg).length;
                // Ridotto a 5KB per evitare "Message too big!"
                if (size > 5000) {
                  console.warn(`Messaggio in entrata troppo grande (${Math.round(size/1024)}KB), ignorato`);
                  return; // Non inoltriamo messaggi troppo grandi
                }
              }
            } catch (e) {
              console.error("Errore durante l'analisi del messaggio in entrata:", e);
            }
            
            // Inoltra solo messaggi di dimensioni accettabili
            this.to.next(msg);
          });
          
          // Filtra messaggi in uscita
          window.gun._.on('out', function(msg) {
            try {
              if (msg && msg.put) {
                const size = JSON.stringify(msg).length;
                // Ridotto a 5KB per evitare "Message too big!"
                if (size > 5000) {
                  console.warn(`Messaggio in uscita troppo grande (${Math.round(size/1024)}KB), bloccato`);
                  return; // Non inviamo messaggi troppo grandi
                }
              }
            } catch (e) {
              console.error("Errore durante l'analisi del messaggio in uscita:", e);
            }
            
            // Inoltra solo messaggi di dimensioni accettabili
            this.to.next(msg);
          });
          
          // Aggiungi handler per errori di Gun
          window.gun.on('err', function(err) {
            console.error('Gun errore:', err);
            
            // Gestisci specificamente gli errori "Message too big"
            if (err.toString().includes('too big')) {
              console.warn('Rilevato errore "Message too big" - Questo potrebbe causare disconnessioni');
            }
          });
          
          // Aggiungi handler per connessione
          window.gun.on('hi', function(peer) {
            console.log(`Connesso a peer: ${peer.url || 'sconosciuto'}`);
            connectedCount++;
            updateRelayStatus(peer.url, true);
            
            // Aggiorna lo stato del server
            if (statusEl && connectedCount > 0) {
              statusEl.className = "server-status status-online";
              statusEl.textContent = `Server: Online (${connectedCount} peer)`;
            }
            
            // Aggiorna la lista dei peer per l'upload
            updatePeerList();
          });
          
          // Aggiungi handler per disconnessione
          window.gun.on('bye', function(peer) {
            console.log(`Disconnesso da peer: ${peer.url || 'sconosciuto'}`);
            updateRelayStatus(peer.url, false);
            
            // Riduci il contatore
            if (connectedCount > 0) {
              connectedCount--;
            }
            
            // Aggiorna lo stato del server
            if (statusEl) {
              if (connectedCount > 0) {
                statusEl.textContent = `Server: Online (${connectedCount} peer)`;
              } else {
                statusEl.className = "server-status status-warning";
                statusEl.textContent = "Server: Nessun peer connesso";
              }
            }
            
            // Aggiorna la lista dei peer per l'upload dopo disconnessione
            updatePeerList();
          });
          
          // Utilizziamo il wrapper sicuro per aggiungere i peer
          peerUrls.forEach(url => {
            console.log(`Aggiungendo peer ${url} in modo sicuro`);
            addPeerSafely(url);
          });
          
          // Aggiorna lo stato dopo un breve ritardo
          setTimeout(() => {
            console.log(`Stato connessione: ${connectedCount} peer connessi`);
            
            // Aggiorna la lista dei peer per l'upload
            updatePeerList();
            
            // Verifica se ci sono peer connessi
            if (connectedCount === 0) {
              console.warn("Nessun peer connesso dopo il tentativo di connessione");
              
              if (statusEl) {
                statusEl.className = "server-status status-warning";
                statusEl.textContent = "Server: Tentativo riconnessione...";
              }
              
              // Riprova ancora una volta con un backoff
              setTimeout(() => {
                console.log("Secondo tentativo di connessione...");
                peerUrls.forEach(url => {
                  try {
                    console.log(`Secondo tentativo di connessione a ${url}`);
                    // Prova ad usare il wrapper sicuro
                    addPeerSafely(url);
                  } catch (e) {
                    console.error(`Errore nel secondo tentativo di connessione a ${url}:`, e);
                  }
                });
                
                // Aggiorna il contatore dopo un altro ritardo
                setTimeout(() => {
                  console.log(`Stato finale: ${connectedCount} peer connessi`);
                  
                  if (connectedCount === 0 && statusEl) {
                    statusEl.className = "server-status status-offline";
                    statusEl.textContent = "Server: Offline (riprova)";
                  }
                  
                  // Ricarica le canzoni comunque da tutti i peer disponibili
                  loadSongs();
                }, 3000);
              }, 3000);
            } else {
              // Ricarica le canzoni da tutti i peer
              loadSongs();
            }
          }, 2000);
        } catch (error) {
          console.error("Errore durante la connessione ai relay:", error);
          alert("Errore durante la connessione ai relay: " + error.message);
        }
      }

      // Aggiorna lo stato della rete nella UI
      function updateNetworkStatus(peerCount) {
        const networkStatusElement = document.getElementById('networkStatus');
        if (networkStatusElement) {
          if (peerCount > 1) {
            networkStatusElement.innerHTML = `<span class="status-connected">Connesso a ${peerCount} peer</span>`;
          } else if (peerCount === 1) {
            networkStatusElement.innerHTML = `<span class="status-warning">Solo connessione locale</span>`;
          } else {
            networkStatusElement.innerHTML = `<span class="status-disconnected">Disconnesso</span>`;
          }
        }
      }

      // Funzione per aggiornare la lista dei peer disponibili
      async function updatePeerList() {
        try {
          const peerSelect = document.getElementById('uploadPeer');
          if (!peerSelect) {
            console.warn("Elemento 'uploadPeer' non trovato nel DOM");
            return;
          }
          
          console.log("Aggiornamento lista peer per upload...");
          
          // Salva la selezione corrente
          const currentSelection = peerSelect.value;
          
          // Mantieni solo il peer locale
          while (peerSelect.options.length > 0) {
            peerSelect.remove(0);
          }
          
          const audioFile = audioFileInput.files[0];
          let artworkFile = artworkFileInput.files[0];

          // Validazione della dimensione del file audio (5MB max)
          const maxAudioSize = 5 * 1024; // 5MB in KB
          if (audioFile.size > maxAudioSize * 1024) {
            try {
              // Prova a comprimere l'audio (anche se al momento solo restituisce un errore)
              const compressedAudio = await compressAudioFile(
                audioFile,
                maxAudioSize
              );
              // Se siamo qui, la compressione √® riuscita
              console.log("Audio compresso con successo");
            } catch (e) {
              alert(e.message);
              document.getElementById("uploadStatus").textContent = "";
              document.getElementById("uploadProgress").style.display = "none";
              return;
            }
          }

          // Ridimensiona l'immagine se esiste
          let artworkBlob = null;
          if (artworkFile) {
            try {
              // Ridimensiona a 300x300px con qualit√† 0.85
              artworkBlob = await resizeImage(artworkFile, 300, 300, 0.85);
              console.log(
                `Immagine ridimensionata: da ${Math.round(
                  artworkFile.size / 1024
                )}KB a ${Math.round(artworkBlob.size / 1024)}KB`
              );

              // Crea un nuovo File object dal Blob
              artworkFile = new File([artworkBlob], artworkFile.name, {
                type: artworkFile.type,
                lastModified: new Date().getTime(),
              });
            } catch (e) {
              console.error(
                "Errore durante il ridimensionamento dell'immagine:",
                e
              );
              // Continua con l'immagine originale se la riduzione fallisce
            }
          }

          // Crea FormData
          const formData = new FormData();
          formData.append("title", titleInput.value);
          formData.append("artist", artistInput.value);
          formData.append("audioFile", audioFile);
          if (artworkFile) {
            formData.append("artworkFile", artworkFile);
          }

          // URL del peer selezionato
          const selectedPeerUrl = peerSelect.value;
          if (!selectedPeerUrl) {
            alert("Per favore seleziona un peer per l'upload");
            document.getElementById("uploadStatus").textContent = "";
            document.getElementById("uploadProgress").style.display = "none";
            return;
          }

          // Costruisci l'URL corretto per l'upload
          let uploadUrl = selectedPeerUrl;
          if (uploadUrl.endsWith("/gun")) {
            uploadUrl = uploadUrl.substring(0, uploadUrl.length - 4);
          }
          uploadUrl += "/api/upload";

          console.log(`Invio upload a: ${uploadUrl}`);
          document.getElementById(
            "uploadStatus"
          ).textContent = `Caricamento su ${uploadUrl}...`;

          let attempts = 0;
          const maxAttempts = 3;
          let success = false;

          while (attempts < maxAttempts && !success) {
            attempts++;
            try {
              // Imposta un timeout per la richiesta
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 secondi

              const response = await fetch(uploadUrl, {
                method: "POST",
                body: formData,
                signal: controller.signal,
              });

              clearTimeout(timeoutId);

              if (response.ok) {
                success = true;
                const result = await response.json();
                console.log("Upload completato con successo:", result);

                // Aggiorna la UI
                document.getElementById("uploadStatus").textContent =
                  "Caricamento completato!";
                document.getElementById("uploadProgress").style.display =
                  "none";

                // Pulisci il form
                titleInput.value = "";
                artistInput.value = "";
                audioFileInput.value = "";
                artworkFileInput.value = "";

                // Ricarica la lista dei brani per mostrare quello nuovo
                setTimeout(loadSongs, 1000);
              } else {
                const errorText = await response.text();
                throw new Error(`Errore HTTP ${response.status}: ${errorText}`);
              }
            } catch (error) {
              console.error(`Tentativo ${attempts} fallito:`, error);

              if (attempts >= maxAttempts) {
                alert(
                  `Upload fallito dopo ${maxAttempts} tentativi: ${error.message}`
                );
                document.getElementById("uploadStatus").textContent =
                  "Caricamento fallito";
                document.getElementById("uploadProgress").style.display =
                  "none";
              } else {
                document.getElementById(
                  "uploadStatus"
                ).textContent = `Riprova ${attempts}/${maxAttempts}...`;
                // Attesa esponenziale tra i tentativi
                await new Promise((resolve) =>
                  setTimeout(resolve, 1000 * attempts)
                );
              }
            }
          }
        } catch (error) {
          console.error("Errore durante l'upload:", error);
          document.getElementById("uploadStatus").textContent =
            "Errore: " + error.message;
          document.getElementById("uploadProgress").style.display = "none";
        }
      }

      // Carica le canzoni
      function loadSongs() {
        const songsList = document.getElementById("songsList");
        if (!songsList) {
          console.error("Elemento 'songsList' non trovato nel DOM");
          return;
        }

        // Mostra indicatore di caricamento
        songsList.innerHTML =
          '<div class="loading">Caricamento tracce in corso...</div>';
        document.getElementById("loadStatus").textContent = "Caricamento...";

        // Configura opzioni per la richiesta con timeout
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 sec timeout

        // Usa la API REST con gestione errori migliorata
        fetch("http://localhost:3000/api/tracks", {
          signal: controller.signal,
          headers: {
            // Aggiungi header anti-cache per evitare problemi con cache del browser
            "Cache-Control": "no-cache, no-store, must-revalidate",
            Pragma: "no-cache",
            Expires: "0",
          },
        })
          .then((response) => {
            clearTimeout(timeoutId);

            if (response.status === 404) {
              throw new Error(
                "API non disponibile. Il server potrebbe essere offline."
              );
            }

            if (!response.ok) {
              throw new Error(`Errore server: ${response.status}`);
            }

            return response.json();
          })
          .then((data) => {
            console.log("Risposta API tracks:", data);

            if (!data.success) {
              throw new Error(
                data.message || "Errore nel recupero delle tracce"
              );
            }

            // Pulisci la lista
            songsList.innerHTML = "";

            if (!data.tracks || data.tracks.length === 0) {
              songsList.innerHTML =
                '<div class="empty-library">Nessuna traccia disponibile</div>';
              document.getElementById("loadStatus").textContent =
                "Nessuna traccia trovata";
              return;
            }

            console.log(
              `Ricevute ${data.tracks.length} tracce da visualizzare`
            );

            // Filtra duplicati e tracce invalide
            const uniqueTrackIds = new Set();
            const uniqueTracks = [];

            // Validazione delle tracce
            data.tracks.forEach((track) => {
              if (track && track.id && !uniqueTrackIds.has(track.id)) {
                uniqueTrackIds.add(track.id);

                // Validazione dei campi obbligatori
                if (track.title && track.audio_path) {
                  uniqueTracks.push(track);
                } else {
                  console.warn(
                    `Traccia con ID ${track.id} ignorata perch√© mancano campi obbligatori`,
                    track
                  );
                }
              }
            });

            console.log(
              `${uniqueTracks.length} tracce uniche e valide da visualizzare`
            );

            // Ordina per data di caricamento (pi√π recenti prima)
            uniqueTracks.sort((a, b) => {
              // Usa il timestamp se disponibile, altrimenti fallback all'ID
              const timeA = a.timestamp
                ? new Date(a.timestamp).getTime()
                : parseInt(a.id);
              const timeB = b.timestamp
                ? new Date(b.timestamp).getTime()
                : parseInt(b.id);
              return timeB - timeA;
            });

            // Visualizza le tracce
            uniqueTracks.forEach((track) => {
              const songCard = document.createElement("div");
              songCard.className = "song-card";
              songCard.dataset.id = track.id;

              // Determina il percorso dell'artwork
              let artworkElement = "";
              if (track.artwork_path) {
                let artworkUrl = track.artwork_path;
                if (
                  !artworkUrl.startsWith("http") &&
                  !artworkUrl.startsWith("data:")
                ) {
                  artworkUrl = `http://localhost:3000${artworkUrl}`;
                }
                artworkElement = `<img src="${artworkUrl}" alt="${track.title}" onerror="this.onerror=null; this.innerHTML='‚ô™'; this.className='artwork-placeholder';">`;
              } else {
                artworkElement = `<div class="artwork-placeholder">‚ô™</div>`;
              }

              // Crea la card della canzone
              songCard.innerHTML = `
          <div class="song-artwork">${artworkElement}</div>
          <div class="song-info">
            <div class="song-title">${track.title}</div>
            <div class="song-artist">${
              track.artist || "Artista sconosciuto"
            }</div>
            <div class="song-controls">
              <button class="play-btn" onclick="playSong('${
                track.id
              }', ${JSON.stringify(track).replace(
                /"/g,
                "&quot;"
              )})">‚ñ∂Ô∏è Play</button>
              <button class="delete-btn" onclick="deleteSong('${
                track.id
              }')">üóëÔ∏è Elimina</button>
            </div>
          </div>
        `;

              songsList.appendChild(songCard);
            });

            document.getElementById(
              "loadStatus"
            ).textContent = `${uniqueTracks.length} brani caricati`;
          })
          .catch((error) => {
            console.error("Errore nel caricamento delle tracce:", error);

            if (error.name === "AbortError") {
              songsList.innerHTML =
                '<div class="error">Timeout durante il caricamento delle tracce</div>';
              document.getElementById("loadStatus").textContent =
                "Timeout - riprova";
            } else {
              songsList.innerHTML = `<div class="error">Errore: ${error.message}</div>`;
              document.getElementById("loadStatus").textContent =
                "Errore di caricamento";
            }

            // Tentativo fallback con Gun.js diretto
            console.log("Tentativo fallback con Gun.js per le tracce...");
            try {
              if (window.songs) {
                songsList.innerHTML +=
                  '<div class="loading">Tentativo fallback Gun.js...</div>';

                window.songs.map().once((song, id) => {
                  if (song && id && song.title && !id.includes("_chunk_")) {
                    console.log(`Fallback: trovata traccia ${id}`, song);

                    const songCard = document.createElement("div");
                    songCard.className = "song-card fallback";
                    songCard.dataset.id = id;

                    let artworkElement =
                      '<div class="artwork-placeholder">‚ô™</div>';

                    songCard.innerHTML = `
                <div class="song-artwork">${artworkElement}</div>
                <div class="song-info">
                  <div class="song-title">${song.title} (fallback)</div>
                  <div class="song-artist">${
                    song.artist || "Artista sconosciuto"
                  }</div>
                  <div class="song-controls">
                    <button class="delete-btn" onclick="deleteSong('${id}')">üóëÔ∏è Elimina</button>
                  </div>
                </div>
              `;

                    songsList.appendChild(songCard);
                    document.getElementById("loadStatus").textContent =
                      "Modalit√† fallback";
                  }
                });
              }
            } catch (fallbackError) {
              console.error(
                "Anche il fallback Gun.js √® fallito:",
                fallbackError
              );
            }
          });
      }

      // Funzioni di compatibilit√†
      if (typeof loadSongs !== 'function' && typeof displaySongs === 'function') {
        console.log("Aggiungendo funzione di compatibilit√† loadSongs -> displaySongs");
        function loadSongs() {
          displaySongs();
        }
      }

      if (typeof displaySongs !== 'function' && typeof loadSongs === 'function') {
        console.log("Aggiungendo funzione di compatibilit√† displaySongs -> loadSongs");
        function displaySongs() {
          loadSongs();
        }
      }

      // Modifica per impostare il peer locale come default e impedire il refresh
      document.addEventListener('DOMContentLoaded', function() {
        // Aggiungi gli event listener dopo il caricamento della pagina
        
        // Modifica l'event listener per il pulsante "Aggiungi Relay"
        const addRelayBtn = document.getElementById('addRelay');
        if (addRelayBtn) {
          // Rimuovi eventuali listener precedenti
          addRelayBtn.replaceWith(addRelayBtn.cloneNode(true));
          // Aggiungi il nuovo listener
          document.getElementById('addRelay').addEventListener('click', function(e) {
            e.preventDefault(); // Previene il refresh della pagina
            addRelay();
          });
        }
        
        // Definizione della funzione addRelay a livello globale
        window.addRelay = function(e) {
          if (e) e.preventDefault();
          const relayUrl = document.getElementById('relayUrl').value.trim();
          
          if (!relayUrl) {
            alert('Inserisci un URL valido per il relay');
            return;
          }
          
          console.log(`Aggiungendo relay: ${relayUrl}`);
          
          // Aggiungi alla lista UI
          const relayList = document.getElementById('relayList');
          const li = document.createElement('li');
          li.innerHTML = `${relayUrl} <span class="status-disconnected">disconnesso</span>`;
          
          // Pulsante per rimuovere il relay
          const removeBtn = document.createElement('button');
          removeBtn.textContent = 'Rimuovi';
          removeBtn.className = 'remove-relay';
          removeBtn.onclick = function() {
            // Rimuovi dalla UI
            li.remove();
            // Se Gun √® disponibile, disconnetti il peer
            if (window.gun && window.gun._.opt.peers) {
              delete window.gun._.opt.peers[relayUrl];
              console.log(`Relay rimosso: ${relayUrl}`);
            }
          };
          
          li.appendChild(removeBtn);
          relayList.appendChild(li);
          
          // Pulisci il campo input
          document.getElementById('relayUrl').value = '';
          
          // Connetti a Gun se disponibile
          if (window.gun) {
            console.log(`Connessione al relay: ${relayUrl}`);
            window.gun.opt({peers: {[relayUrl]: {}}});
          }
        };
        
        // Inizializza il peer locale come default per l'upload
        const uploadPeerSelect = document.getElementById('uploadPeer');
        if (uploadPeerSelect) {
          // Assicurati che il peer locale sia l'opzione predefinita
          let localPeerFound = false;
          for (let i = 0; i < uploadPeerSelect.options.length; i++) {
            if (uploadPeerSelect.options[i].value === 'http://localhost:3000') {
              uploadPeerSelect.selectedIndex = i;
              localPeerFound = true;
              break;
            }
          }
          
          // Se non √® stato trovato, aggiungi l'opzione del peer locale
          if (!localPeerFound) {
            const localOption = document.createElement('option');
            localOption.value = 'http://localhost:3000';
            localOption.textContent = 'Locale (http://localhost:3000)';
            uploadPeerSelect.insertBefore(localOption, uploadPeerSelect.firstChild);
            uploadPeerSelect.selectedIndex = 0;
          }
          
          // Abilita/disabilita opzioni di peer remoti in base alla configurazione
          const allowRemoteUploads = false; // Imposta a true se vuoi consentire upload su peer remoti
          
          if (!allowRemoteUploads) {
            for (let i = 0; i < uploadPeerSelect.options.length; i++) {
              if (uploadPeerSelect.options[i].value !== 'http://localhost:3000') {
                uploadPeerSelect.options[i].disabled = true;
              }
            }
            
            // Aggiungi un messaggio informativo
            const uploadFormGroup = uploadPeerSelect.closest('.form-group');
            if (uploadFormGroup) {
              const infoMsg = document.createElement('div');
              infoMsg.className = 'file-info';
              infoMsg.textContent = 'Solo upload locali consentiti per sicurezza';
              uploadFormGroup.appendChild(infoMsg);
            }
          }
        }
      });

      // Funzione per aggiornare lo stato di un relay nella UI
      function updateRelayStatus(relayUrl, isConnected) {
        if (!relayUrl) return;
        
        try {
          // Normalizza URL del peer
          let normalizedUrl = relayUrl;
          if (normalizedUrl.endsWith('/gun')) {
            normalizedUrl = normalizedUrl.substring(0, normalizedUrl.length - 4);
          }
          
          // Trova l'elemento relay nella lista
          const relayListItems = document.querySelectorAll('#relayList li');
          for (let i = 0; i < relayListItems.length; i++) {
            const relayText = relayListItems[i].textContent;
            if (relayText.includes(normalizedUrl)) {
              // Sostituisci solo la parte dello stato
              const statusSpan = relayListItems[i].querySelector('span');
              if (statusSpan) {
                if (isConnected) {
                  statusSpan.className = 'status-connected';
                  statusSpan.textContent = 'connesso';
                } else {
                  statusSpan.className = 'status-disconnected';
                  statusSpan.textContent = 'disconnesso';
                }
              } else {
                // Se non c'√® span, aggiorna l'intero HTML
                let statusHTML = isConnected 
                  ? `<span class="status-connected">connesso</span>` 
                  : `<span class="status-disconnected">disconnesso</span>`;
                
                // Assicurati di mantenere il pulsante di rimozione se presente
                const removeBtn = relayListItems[i].querySelector('button.remove-relay');
                const relayTextWithoutStatus = relayText.split(' ')[0];
                
                relayListItems[i].innerHTML = `${relayTextWithoutStatus} ${statusHTML}`;
                if (removeBtn) relayListItems[i].appendChild(removeBtn);
              }
              break;
            }
          }
          
          // Aggiorna anche il contatore nella UI
          updateNetworkStatus(Object.keys(window.gun._.opt.peers || {}).length);
        } catch (error) {
          console.error('Errore durante l\'aggiornamento dello stato del relay:', error);
        }
      }

      // Correggo la funzione upload per renderla async e risolvere il problema con await
      function uploadSong() {
        return new Promise(async (resolve, reject) => {
          try {
            console.log("Iniziando upload della canzone...");
            
            // Raccogli dati dal form
            const title = document.getElementById("title").value;
            const artist = document.getElementById("artist").value;
            const audioFileInput = document.getElementById("audioFile");
            const artworkFileInput = document.getElementById("artworkFile");
            
            if (!audioFileInput.files.length) {
              throw new Error("Seleziona un file audio");
            }
            
            // Verifico il peer selezionato (default: locale)
            const uploadPeerSelect = document.getElementById("uploadPeer");
            let uploadUrl = "http://localhost:3000/api/upload";
            
            if (uploadPeerSelect && uploadPeerSelect.value) {
              // Assicurati che l'URL non contenga /gun prima di aggiungere /api/upload
              const baseUrl = uploadPeerSelect.value.replace(/\/gun$/, "");
              uploadUrl = `${baseUrl}/api/upload`;
            }
            
            const audioFile = audioFileInput.files[0];
            const artworkFile = artworkFileInput.files.length 
              ? artworkFileInput.files[0] 
              : null;
            
            // Verifica la dimensione dei file
            const maxAudioSize = 5 * 1024 * 1024;    // 5MB per audio (ridotto da 20MB)
            const maxArtworkSize = 500 * 1024;       // 500KB per artwork (ridotto da 2MB)
            
            if (audioFile.size > maxAudioSize) {
              throw new Error(`File audio troppo grande. Massimo: ${Math.round(maxAudioSize/1024/1024)}MB`);
            }
            
            // Mostra la barra di progresso
            const progressBar = document.getElementById("progressBar");
            const uploadStatus = document.getElementById("uploadStatus");
            
            progressBar.style.width = "0%";
            progressBar.parentElement.style.display = "block";
            uploadStatus.textContent = "Preparazione upload...";
            uploadStatus.style.color = "#333";
            
            // Prepara i dati
            let artworkBlob = null;
            
            // Comprimi l'audio
            if (audioFile.size > maxAudioSize / 2) {
              uploadStatus.textContent = "Compressione audio...";
              try {
                // In una versione futura, potresti implementare una vera compressione audio
                // Per ora, controlliamo solo la dimensione senza modificare il file
                console.log(`Audio file: ${audioFile.size} bytes - Nessuna compressione disponibile`);
              } catch (e) {
                console.warn("Errore durante la compressione audio:", e);
                // Continuiamo comunque con il file originale
              }
            }
            
            // Comprimi l'artwork se presente e troppo grande
            if (artworkFile && artworkFile.size > maxArtworkSize) {
              uploadStatus.textContent = "Ottimizzazione artwork...";
              try {
                // In una versione futura, potresti implementare un ridimensionamento immagine
                // Per ora, controlliamo solo la dimensione senza modificare il file
                if (artworkFile.size > maxArtworkSize) {
                  throw new Error(`Artwork troppo grande. Massimo: ${Math.round(maxArtworkSize/1024)}KB`);
                }
              } catch (e) {
                console.warn("Errore durante l'ottimizzazione artwork:", e);
                throw new Error(`Artwork troppo grande. Massimo: ${Math.round(maxArtworkSize/1024)}KB`);
              }
            }
            
            // Prepara FormData per l'upload
            const formData = new FormData();
            formData.append("title", title);
            formData.append("artist", artist);
            formData.append("audioFile", audioFile);
            
            if (artworkFile) {
              formData.append("artworkFile", artworkBlob || artworkFile);
            }
            
            // Numero di tentativi massimi
            const maxAttempts = 3;
            let attempts = 0;
            let success = false;
            
            while (attempts < maxAttempts && !success) {
              attempts++;
              
              try {
                uploadStatus.textContent = `Uploading... (${Math.round(
                  (attempts / maxAttempts) * 100
                )}%)`;
                
                // Aggiungi timeout per l'upload
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 secondi
                
                const response = await fetch(uploadUrl, {
                  method: "POST",
                  body: formData,
                  signal: controller.signal,
                  headers: {
                    // Non impostiamo Content-Type perch√© FormData lo fa automaticamente
                  },
                });
                
                clearTimeout(timeoutId);
                
                if (response.ok) {
                  success = true;
                  const result = await response.json();
                  console.log("Upload completato con successo:", result);
                  
                  // Aggiorna la UI
                  progressBar.style.width = "100%";
                  uploadStatus.textContent = "Upload completato con successo!";
                  uploadStatus.style.color = "#4caf50";
                  
                  // Pulizia dei campi
                  document.getElementById("title").value = "";
                  document.getElementById("artist").value = "";
                  document.getElementById("audioFile").value = "";
                  document.getElementById("artworkFile").value = "";
                  document.getElementById("artworkPreview").innerHTML = "";
                  
                  // Aggiorna la lista delle canzoni
                  setTimeout(loadSongs, 1000);
                } else {
                  const errorText = await response.text();
                  throw new Error(`Errore HTTP ${response.status}: ${errorText}`);
                }
              } catch (error) {
                console.error(`Tentativo ${attempts} fallito:`, error);
                progressBar.style.width = "0%";
                uploadStatus.style.color = "#f44336";
                
                if (attempts >= maxAttempts) {
                  uploadStatus.textContent = `Errore: ${error.message}`;
                  throw error;
                } else {
                  uploadStatus.textContent = `Riprova ${attempts}/${maxAttempts}...`;
                  // Attesa esponenziale tra i tentativi
                  await new Promise((resolve) =>
                    setTimeout(resolve, 1000 * attempts)
                  );
                }
              }
            }
            
            resolve("Upload completato con successo");
          } catch (error) {
            console.error("Errore durante l'upload:", error);
            
            // Mostra l'errore nella UI
            const uploadStatus = document.getElementById("uploadStatus");
            uploadStatus.textContent = `Errore: ${error.message}`;
            uploadStatus.style.color = "#f44336";
            
            reject(error);
          }
        });
      }

      // Assegno la funzione upload al pulsante nella UI
      document.addEventListener('DOMContentLoaded', function() {
        const uploadBtn = document.getElementById('uploadBtn');
        if (uploadBtn) {
          uploadBtn.addEventListener('click', function() {
            uploadSong().catch(error => {
              console.error('Errore nell\'upload:', error);
            });
          });
        }
      });

      // Wrapper di sicurezza per la connessione al peer
      function addPeerSafely(relayUrl) {
        if (!relayUrl) return;
        
        try {
          console.log(`Tentativo di aggiungere in modo sicuro il peer: ${relayUrl}`);
          
          // Assicurati che l'URL termini con /gun
          let peerUrl = relayUrl;
          if (!peerUrl.endsWith('/gun')) {
            peerUrl = peerUrl.endsWith('/') ? peerUrl + 'gun' : peerUrl + '/gun';
          }
          
          // Verifica che Gun sia inizializzato
          if (!window.gun || !window.gun._ || !window.gun._.opt) {
            console.error('Gun non √® inizializzato correttamente, impossibile aggiungere peer');
            return;
          }
          
          // Trova l'elemento relay nella lista e aggiorna lo stato
          const relayElement = Array.from(document.querySelectorAll('#relayList li'))
            .find(li => li.textContent.includes(relayUrl));
          
          if (relayElement) {
            relayElement.innerHTML = `${relayUrl} <span class="status-connecting">connessione...</span>`;
          }
          
          // Aggiungi il peer con wrapper di sicurezza per evitare "Message too big"
          window.gun._.opt.peers[peerUrl] = {};
          
          console.log(`Peer ${peerUrl} aggiunto con successo`);
          
          // Aggiorna la lista dei peer per l'upload
          setTimeout(updatePeerList, 500);
          
          return true;
        } catch (error) {
          console.error(`Errore durante l'aggiunta del peer ${relayUrl}:`, error);
          return false;
        }
      }

      // Funzione per la compressione audio (solo una simulazione/stub per ora)
      async function compressAudioFile(file, maxSizeKB) {
        console.log(`Tentativo di compressione audio: ${file.name} (${Math.round(file.size/1024)}KB)`);
        
        // Verifica se il file √® troppo grande
        if (file.size > maxSizeKB * 1024) {
          // Per ora, solo simuliamo la compressione ritornando un errore
          console.warn(`File audio troppo grande: ${Math.round(file.size/1024)}KB. Massimo consentito: ${maxSizeKB}KB`);
          throw new Error(`Il file audio √® troppo grande (${Math.round(file.size/1024)}KB). Riduci la dimensione a meno di ${maxSizeKB}KB.`);
        }
        
        // In futuro, qui potresti implementare una reale compressione audio
        // Per ora restituiamo semplicemente il file originale
        return file;
      }
      
      // Funzione per ridimensionare immagini
      async function resizeImage(file, maxWidth, maxHeight, quality = 0.8) {
        return new Promise((resolve, reject) => {
          try {
            const reader = new FileReader();
            reader.onload = function(e) {
              const img = new Image();
              img.onload = function() {
                // Calcola le nuove dimensioni mantenendo le proporzioni
                let width = img.width;
                let height = img.height;
                
                if (width > maxWidth) {
                  height = (height * maxWidth) / width;
                  width = maxWidth;
                }
                
                if (height > maxHeight) {
                  width = (width * maxHeight) / height;
                  height = maxHeight;
                }
                
                // Crea un canvas per il ridimensionamento
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                
                // Disegna l'immagine ridimensionata sul canvas
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);
                
                // Converti il canvas in un blob con qualit√† specificata
                canvas.toBlob(
                  (blob) => resolve(blob),
                  file.type,
                  quality
                );
              };
              
              img.src = e.target.result;
            };
            
            reader.onerror = reject;
            reader.readAsDataURL(file);
          } catch (err) {
            reject(err);
          }
        });
      }

      // Funzione per riprodurre una canzone
      async function playSong(songId, songData) {
        try {
          console.log(`Riproduzione della traccia ${songId}`);
          
          if (!songId || !songData) {
            throw new Error("Dati della traccia non validi");
          }
          
          // Aggiorna UI - mostra il brano corrente
          const nowPlayingContainer = document.getElementById("nowPlayingContainer");
          const currentTitle = document.getElementById("currentTitle");
          const currentArtist = document.getElementById("currentArtist");
          const currentArtwork = document.getElementById("currentArtwork");
          
          if (nowPlayingContainer && currentTitle && currentArtist) {
            nowPlayingContainer.style.display = "flex";
            currentTitle.textContent = songData.title || "Senza titolo";
            currentArtist.textContent = songData.artist || "Artista sconosciuto";
            
            // Aggiorna artwork se disponibile
            if (currentArtwork) {
              if (songData.artwork_path) {
                let artworkUrl = songData.artwork_path;
                if (!artworkUrl.startsWith("http") && !artworkUrl.startsWith("data:")) {
                  artworkUrl = `http://localhost:3000${artworkUrl}`;
                }
                currentArtwork.innerHTML = `<img src="${artworkUrl}" class="artwork" onerror="this.outerHTML='<div class=\'artwork-placeholder\'>‚ô™</div>'" />`;
              } else {
                currentArtwork.innerHTML = '<div class="artwork-placeholder">‚ô™</div>';
              }
            }
          }
          
          // Ottieni l'URL del file audio
          let audioUrl = songData.audio_path;
          if (!audioUrl) {
            throw new Error("Percorso audio non disponibile");
          }
          
          // Se l'URL non √® assoluto, aggiungi l'URL base del server
          if (!audioUrl.startsWith("http") && !audioUrl.startsWith("data:")) {
            audioUrl = `http://localhost:3000${audioUrl}`;
          }
          
          // Resetta e carica il waveform
          if (typeof WaveSurfer === "undefined") {
            console.error("WaveSurfer non √® disponibile");
            alert("Errore: WaveSurfer non disponibile. Ricarica la pagina.");
            return;
          }
          
          // Mostra controlli di riproduzione
          document.getElementById("playBtn").style.display = "none";
          document.getElementById("pauseBtn").style.display = "inline-block";
          
          // Inizializza o ricrea WaveSurfer
          if (window.wavesurfer) {
            window.wavesurfer.destroy();
          }
          
          window.wavesurfer = WaveSurfer.create({
            container: '#waveform',
            waveColor: '#3498db',
            progressColor: '#2980b9',
            cursorColor: '#27ae60',
            barWidth: 3,
            barRadius: 3,
            responsive: true,
            height: 80,
            backend: 'MediaElement'
          });
          
          // Gestione eventi WaveSurfer
          window.wavesurfer.on('ready', function() {
            console.log("WaveSurfer pronto per la riproduzione");
            window.wavesurfer.play();
            updatePlaybackControls(true);
            updateTimeInfo();
          });
          
          window.wavesurfer.on('error', function(err) {
            console.error("Errore WaveSurfer:", err);
            alert(`Errore durante il caricamento dell'audio: ${err}`);
            updatePlaybackControls(false);
          });
          
          window.wavesurfer.on('finish', function() {
            console.log("Riproduzione terminata");
            updatePlaybackControls(false);
          });
          
          window.wavesurfer.on('audioprocess', function() {
            updateTimeInfo();
          });
          
          // Carica audio
          window.wavesurfer.load(audioUrl);
          currentSongId = songId;
          
          // Aggiorna icone play/pause
          const playBtn = document.getElementById("playBtn");
          const pauseBtn = document.getElementById("pauseBtn");
          
          playBtn.addEventListener("click", function() {
            window.wavesurfer.play();
            updatePlaybackControls(true);
          });
          
          pauseBtn.addEventListener("click", function() {
            window.wavesurfer.pause();
            updatePlaybackControls(false);
          });
          
          console.log(`Traccia ${songId} caricata con successo`);
          
        } catch (error) {
          console.error("Errore durante la riproduzione:", error);
          alert(`Errore durante la riproduzione: ${error.message}`);
        }
      }

      // Funzione di supporto per aggiornare i controlli di riproduzione
      function updatePlaybackControls(isPlaying) {
        const playBtn = document.getElementById("playBtn");
        const pauseBtn = document.getElementById("pauseBtn");
        
        if (isPlaying) {
          playBtn.style.display = "none";
          pauseBtn.style.display = "inline-block";
        } else {
          playBtn.style.display = "inline-block";
          pauseBtn.style.display = "none";
        }
      }

      // Funzione per aggiornare le informazioni sul tempo di riproduzione
      function updateTimeInfo() {
        if (!window.wavesurfer) return;
        
        const timeInfo = document.getElementById("timeInfo");
        if (!timeInfo) return;
        
        const currentTime = window.wavesurfer.getCurrentTime() || 0;
        const duration = window.wavesurfer.getDuration() || 0;
        
        const formatTime = function(time) {
          const minutes = Math.floor(time / 60);
          const seconds = Math.floor(time % 60);
          return `${minutes}:${seconds < 10 ? '0' + seconds : seconds}`;
        };
        
        timeInfo.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`;
      }
    </script>
  </body>
</html>
