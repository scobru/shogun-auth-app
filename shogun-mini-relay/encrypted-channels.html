<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Canali Criptati Condivisi - Shogun Mini Relay</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
      }
      input, select, button, textarea {
        padding: 8px;
        margin: 5px 0;
        border-radius: 4px;
        border: 1px solid #ccc;
      }
      input, select, textarea {
        width: 100%;
      }
      button {
        cursor: pointer;
        background-color: #4CAF50;
        color: white;
        border: none;
      }
      button:hover {
        background-color: #45a049;
      }
      .card {
        border: 1px solid #ddd;
        border-radius: 5px;
        padding: 15px;
        margin-bottom: 20px;
        background-color: #f9f9f9;
      }
      .messages {
        height: 300px;
        overflow-y: auto;
        border: 1px solid #ddd;
        padding: 10px;
        background-color: white;
        margin: 10px 0;
      }
      .message {
        padding: 8px;
        margin: 5px 0;
        border-radius: 4px;
        background-color: #e9e9e9;
      }
      .error {
        color: #f44336;
        background-color: #ffebee;
        padding: 10px;
        border-radius: 4px;
        margin: 10px 0;
        display: none;
      }
      .success {
        color: #4CAF50;
        background-color: #e8f5e9;
        padding: 10px;
        border-radius: 4px;
        margin: 10px 0;
        display: none;
      }
      .user-name {
        font-weight: bold;
        color: #2196F3;
      }
      .tabs {
        display: flex;
        border-bottom: 1px solid #ccc;
        margin-bottom: 20px;
      }
      .tab {
        padding: 10px 20px;
        cursor: pointer;
        border: 1px solid #ccc;
        border-bottom: none;
        border-radius: 4px 4px 0 0;
        margin-right: 5px;
        background-color: #f1f1f1;
      }
      .tab.active {
        background-color: white;
        border-bottom: 1px solid white;
        margin-bottom: -1px;
      }
      .tab-content {
        display: none;
      }
      .tab-content.active {
        display: block;
      }
    </style>
  </head>
  <body>
    <h1>Canali Criptati Condivisi</h1>
    <div class="error" id="errorMsg"></div>
    <div class="success" id="successMsg"></div>

    <div class="tabs">
      <div class="tab active" data-tab="login">Login</div>
      <div class="tab" data-tab="create">Crea Canale</div>
      <div class="tab" data-tab="join">Partecipa a Canale</div>
      <div class="tab" data-tab="chat">Chat Criptata</div>
    </div>

    <div class="tab-content active" id="login-tab">
      <div class="card">
        <h2>Login o Registrazione</h2>
        <div id="loginForm">
          <input type="text" id="username" placeholder="Username" />
          <input type="password" id="password" placeholder="Password" />
          <div>
            <button id="loginBtn">Login</button>
            <button id="registerBtn">Registrati</button>
          </div>
        </div>
        <div id="loggedInStatus" style="display:none">
          Loggato come: <span id="currentUser"></span>
          <button id="logoutBtn">Logout</button>
        </div>
      </div>
    </div>

    <div class="tab-content" id="create-tab">
      <div class="card">
        <h2>Crea Nuovo Canale Criptato</h2>
        <input type="text" id="newChannelName" placeholder="Nome del canale" />
        <input 
          type="password" 
          id="channelSecret" 
          placeholder="Segreto condiviso (password per il canale)" 
        />
        <p><small>Questo segreto sarà usato per criptare tutti i messaggi. Condividilo con le persone che vuoi invitare.</small></p>
        <button id="createChannelBtn">Crea Canale</button>
      </div>
    </div>

    <div class="tab-content" id="join-tab">
      <div class="card">
        <h2>Entra in un Canale Criptato</h2>
        <div id="channelList">
          <button id="refreshChannelsBtn">Aggiorna Lista Canali</button>
          <select id="channelSelect">
            <option value="">-- Seleziona un canale --</option>
          </select>
        </div>
        <input 
          type="password" 
          id="joinSecret" 
          placeholder="Segreto condiviso (fornito dal creatore)" 
        />
        <button id="joinChannelBtn">Entra nel Canale</button>
      </div>
    </div>

    <div class="tab-content" id="chat-tab">
      <div class="card">
        <h2>Chat Criptata - <span id="currentChannel">Nessun canale</span></h2>
        <div class="messages" id="channelMessages">
          <!-- I messaggi verranno mostrati qui -->
        </div>
        <textarea 
          id="messageInput" 
          placeholder="Scrivi un messaggio..." 
          rows="3"
        ></textarea>
        <button id="sendMsgBtn">Invia Messaggio</button>
      </div>
    </div>

    <!-- Carica le librerie di Gun -->
    <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/sea.js"></script>
    
    <script type="module">
      import { init as nodomInit } from "../shogun-nodom/nodom.js";

      // Configurazioni iniziali
      const gun = new Gun({
        peers: ["http://localhost:8765/gun"],
        localStorage: false,
        radisk: false,
      });

      // Inizializza nodom
      nodomInit(gun);
      
      // Recupera SEA dalla finestra
      const SEA = window.SEA;
      
      // Stato dell'applicazione
      const state = {
        user: null,
        currentChannel: null,
        channelKey: null,
        metadata: null,
        messageMap: new Map() // Per evitare duplicati
      };
      
      // Elementi DOM
      const elements = {
        tabs: document.querySelectorAll('.tab'),
        tabContents: document.querySelectorAll('.tab-content'),
        errorMsg: document.getElementById('errorMsg'),
        successMsg: document.getElementById('successMsg'),
        loginForm: document.getElementById('loginForm'),
        loggedInStatus: document.getElementById('loggedInStatus'),
        currentUser: document.getElementById('currentUser'),
        username: document.getElementById('username'),
        password: document.getElementById('password'),
        loginBtn: document.getElementById('loginBtn'),
        registerBtn: document.getElementById('registerBtn'),
        logoutBtn: document.getElementById('logoutBtn'),
        newChannelName: document.getElementById('newChannelName'),
        channelSecret: document.getElementById('channelSecret'),
        createChannelBtn: document.getElementById('createChannelBtn'),
        channelSelect: document.getElementById('channelSelect'),
        refreshChannelsBtn: document.getElementById('refreshChannelsBtn'),
        joinSecret: document.getElementById('joinSecret'),
        joinChannelBtn: document.getElementById('joinChannelBtn'),
        currentChannel: document.getElementById('currentChannel'),
        channelMessages: document.getElementById('channelMessages'),
        messageInput: document.getElementById('messageInput'),
        sendMsgBtn: document.getElementById('sendMsgBtn')
      };
      
      // --- Funzioni di utilità ---
      
      // Mostra errori
      function showError(message) {
        elements.errorMsg.textContent = message;
        elements.errorMsg.style.display = 'block';
        setTimeout(() => {
          elements.errorMsg.style.display = 'none';
        }, 5000);
      }
      
      // Mostra messaggi di successo
      function showSuccess(message) {
        elements.successMsg.textContent = message;
        elements.successMsg.style.display = 'block';
        setTimeout(() => {
          elements.successMsg.style.display = 'none';
        }, 3000);
      }
      
      // Gestione delle tab
      function activateTab(tabName) {
        // Rimuovi classe active da tutte le tab
        elements.tabs.forEach(tab => tab.classList.remove('active'));
        elements.tabContents.forEach(content => content.classList.remove('active'));
        
        // Aggiungi classe active alla tab selezionata
        document.querySelector(`.tab[data-tab="${tabName}"]`).classList.add('active');
        document.getElementById(`${tabName}-tab`).classList.add('active');
      }
      
      // Controlla login
      function checkLoginStatus() {
        try {
          const user = gun.user().recall({ sessionStorage: true });
          if (user && user.is) {
            state.user = user;
            elements.currentUser.textContent = user.is.alias;
            elements.loginForm.style.display = 'none';
            elements.loggedInStatus.style.display = 'block';
            return true;
          } else {
            state.user = null;
            elements.loginForm.style.display = 'block';
            elements.loggedInStatus.style.display = 'none';
            return false;
          }
        } catch (err) {
          console.error("Errore controllo login:", err);
          return false;
        }
      }
      
      // --- Funzioni di crittografia ---
      
      // Cripta dati
      async function encryptData(data, key) {
        try {
          const dataStr = typeof data === 'object' ? JSON.stringify(data) : String(data);
          const encrypted = await SEA.encrypt(dataStr, key);
          return {
            enc: encrypted,
            timestamp: Date.now(),
            type: 'encrypted'
          };
        } catch (err) {
          console.error("Errore crittografia:", err);
          return null;
        }
      }
      
      // Decripta dati
      async function decryptData(encData, key) {
        try {
          if (!encData || !encData.enc) return null;
          
          const decrypted = await SEA.decrypt(encData.enc, key);
          if (!decrypted) return null;
          
          return typeof decrypted === 'string' ? JSON.parse(decrypted) : decrypted;
        } catch (err) {
          console.error("Errore decrittografia:", err);
          return null;
        }
      }
      
      // Crea un canale criptato
      async function createSharedChannel(channelName, sharedSecret) {
        try {
          // Crea un ID univoco per il canale
          const channelId = await SEA.work(channelName, null, null, { name: "SHA-256" });
          const fullChannelName = `encrypted_${channelId.substring(0, 12)}`;
          
          // Genera la chiave di crittografia dal segreto condiviso
          const encryptionKey = await SEA.work(sharedSecret, null, null, { name: "SHA-256" });
          
          // Metadati del canale
          const metadata = {
            name: channelName,
            created: Date.now(),
            createdBy: state.user.is.alias,
            type: "shared_encrypted"
          };
          
          // Cripta i metadati
          const encryptedMetadata = await encryptData(metadata, encryptionKey);
          
          // Salva i metadati
          gun.get('#encrypted_channels').get(fullChannelName).put(encryptedMetadata);
          
          return {
            channelId: fullChannelName,
            encryptionKey,
            metadata
          };
        } catch (err) {
          console.error("Errore creazione canale:", err);
          return null;
        }
      }
      
      // Entra in un canale criptato
      async function joinSharedChannel(channelId, sharedSecret) {
        try {
          // Genera la chiave di crittografia dal segreto condiviso
          const encryptionKey = await SEA.work(sharedSecret, null, null, { name: "SHA-256" });
          
          // Ottieni e verifica i metadati del canale
          const encryptedMetadata = await new Promise(resolve => {
            gun.get('#encrypted_channels').get(channelId).once(data => {
              resolve(data);
            });
          });
          
          if (!encryptedMetadata || !encryptedMetadata.enc) {
            throw new Error("Canale non trovato o non criptato");
          }
          
          // Prova a decriptare i metadati
          const metadata = await decryptData(encryptedMetadata, encryptionKey);
          
          if (!metadata) {
            throw new Error("Impossibile decriptare i metadati. Segreto non valido.");
          }
          
          return {
            channelId,
            encryptionKey,
            metadata
          };
        } catch (err) {
          console.error("Errore partecipazione canale:", err);
          throw err; // Rilancia l'errore per gestirlo nel chiamante
        }
      }
      
      // Invia un messaggio criptato
      async function sendEncryptedMessage(message) {
        if (!state.currentChannel || !state.channelKey) {
          showError("Nessun canale attivo");
          return false;
        }
        
        if (!state.user || !state.user.is) {
          showError("Devi effettuare il login");
          return false;
        }
        
        try {
          const messageData = {
            text: message,
            timestamp: Date.now(),
            user: state.user.is.alias,
            userPub: state.user.is.pub
          };
          
          // Cripta il messaggio
          const encryptedData = await encryptData(messageData, state.channelKey);
          if (!encryptedData) {
            throw new Error("Errore crittografia messaggio");
          }
          
          // ID univoco per il messaggio
          const msgId = `msg_${messageData.timestamp}`;
          
          // Salva il messaggio
          await new Promise(resolve => {
            state.user.get(state.currentChannel).get(msgId).put(encryptedData, ack => {
              resolve(ack);
            });
          });
          
          // Crea il soul per il messaggio
          const soul = `~${state.user.is.pub}/${state.currentChannel}/${msgId}`;
          
          // Crea un hash del soul
          const hash = await SEA.work(soul, null, null, { name: "SHA-256" });
          
          // Crea il riferimento nel canale
          gun.get('#' + state.currentChannel).get(hash).put(soul);
          
          // Aggiungi il messaggio alla UI per feedback immediato
          addMessageToUI(messageData);
          
          return true;
        } catch (err) {
          console.error("Errore invio messaggio:", err);
          showError(`Errore invio messaggio: ${err.message}`);
          return false;
        }
      }
      
      // Ascolta messaggi sul canale
      function listenToEncryptedChannel() {
        if (!state.currentChannel || !state.channelKey) {
          showError("Nessun canale attivo");
          return;
        }
        
        const seenMessages = new Set();
        
        gun.get('#' + state.currentChannel).map().on((soul, key) => {
          if (!soul) return;
          
          // Evita duplicati
          if (seenMessages.has(soul)) return;
          seenMessages.add(soul);
          
          gun.get(soul).on(async encryptedData => {
            try {
              if (!encryptedData || !encryptedData.enc) return;
              
              // Decripta il messaggio
              const decrypted = await decryptData(encryptedData, state.channelKey);
              if (!decrypted) return;
              
              // Aggiungi il messaggio alla UI
              addMessageToUI(decrypted);
            } catch (err) {
              console.error("Errore processamento messaggio:", err);
            }
          });
        });
      }
      
      // Aggiunge un messaggio alla UI
      function addMessageToUI(message) {
        // Crea un ID univoco per evitare duplicati
        const messageId = `${message.userPub || ''}:${message.timestamp}:${message.text}`;
        
        // Se abbiamo già questo messaggio, salta
        if (state.messageMap.has(messageId)) return;
        state.messageMap.set(messageId, true);
        
        // Crea l'elemento del messaggio
        const msgElement = document.createElement('div');
        msgElement.className = 'message';
        
        // Formatta la data
        const date = new Date(message.timestamp).toLocaleString();
        
        // Crea span per il nome utente
        const userSpan = document.createElement('span');
        userSpan.className = 'user-name';
        userSpan.textContent = message.user || 'Anonimo';
        
        // Assembla il messaggio
        msgElement.appendChild(userSpan);
        msgElement.appendChild(document.createTextNode(`: ${message.text} (${date})`));
        
        // Aggiungi il messaggio in cima
        const messagesContainer = elements.channelMessages;
        if (messagesContainer.firstChild) {
          messagesContainer.insertBefore(msgElement, messagesContainer.firstChild);
        } else {
          messagesContainer.appendChild(msgElement);
        }
      }
      
      // Ottieni la lista dei canali
      async function getEncryptedChannels() {
        return new Promise((resolve) => {
          const channels = [];
          
          gun.get('#encrypted_channels').map().on((data, id) => {
            if (data && id) {
              channels.push({id, data});
            }
          });
          
          // Ritorna i canali dopo un breve ritardo
          setTimeout(() => {
            resolve(channels);
          }, 500);
        });
      }
      
      // --- Gestori eventi ---
      
      // Login
      elements.loginBtn.addEventListener('click', () => {
        const username = elements.username.value.trim();
        const password = elements.password.value.trim();
        
        if (!username || !password) {
          showError("Inserisci username e password");
          return;
        }
        
        gun.user().auth(username, password, (ack) => {
          if (ack.err) {
            showError(`Login fallito: ${ack.err}`);
            return;
          }
          
          state.user = gun.user();
          showSuccess("Login effettuato con successo");
          checkLoginStatus();
        });
      });
      
      // Registrazione
      elements.registerBtn.addEventListener('click', () => {
        const username = elements.username.value.trim();
        const password = elements.password.value.trim();
        
        if (!username || !password) {
          showError("Inserisci username e password");
          return;
        }
        
        gun.user().create(username, password, (ack) => {
          if (ack.err) {
            showError(`Registrazione fallita: ${ack.err}`);
            return;
          }
          
          showSuccess("Utente creato! Effettua il login");
          
          // Auto-login
          gun.user().auth(username, password, (authAck) => {
            if (authAck.err) {
              showError(`Login automatico fallito: ${authAck.err}`);
              return;
            }
            
            state.user = gun.user();
            showSuccess("Login effettuato con successo");
            checkLoginStatus();
          });
        });
      });
      
      // Logout
      elements.logoutBtn.addEventListener('click', () => {
        gun.user().leave();
        state.user = null;
        state.currentChannel = null;
        state.channelKey = null;
        state.metadata = null;
        elements.currentChannel.textContent = "Nessun canale";
        elements.channelMessages.innerHTML = "";
        checkLoginStatus();
        showSuccess("Logout effettuato");
        activateTab('login');
      });
      
      // Crea canale
      elements.createChannelBtn.addEventListener('click', async () => {
        if (!checkLoginStatus()) {
          showError("Devi effettuare il login");
          activateTab('login');
          return;
        }
        
        const channelName = elements.newChannelName.value.trim();
        const secret = elements.channelSecret.value.trim();
        
        if (!channelName || !secret) {
          showError("Inserisci nome canale e segreto condiviso");
          return;
        }
        
        try {
          const channelInfo = await createSharedChannel(channelName, secret);
          if (!channelInfo) {
            showError("Errore durante la creazione del canale");
            return;
          }
          
          // Salva informazioni canale e attiva
          state.currentChannel = channelInfo.channelId;
          state.channelKey = channelInfo.encryptionKey;
          state.metadata = channelInfo.metadata;
          
          elements.currentChannel.textContent = channelName;
          elements.channelMessages.innerHTML = "";
          state.messageMap.clear();
          
          // Ascolta i messaggi
          listenToEncryptedChannel();
          
          showSuccess(`Canale "${channelName}" creato con successo!`);
          elements.newChannelName.value = "";
          elements.channelSecret.value = "";
          
          // Vai alla tab chat
          activateTab('chat');
        } catch (err) {
          showError(`Errore creazione canale: ${err.message}`);
        }
      });
      
      // Aggiorna lista canali
      elements.refreshChannelsBtn.addEventListener('click', async () => {
        if (!checkLoginStatus()) {
          showError("Devi effettuare il login");
          activateTab('login');
          return;
        }
        
        try {
          const channels = await getEncryptedChannels();
          
          // Pulisci il select
          elements.channelSelect.innerHTML = "";
          const defaultOption = document.createElement('option');
          defaultOption.value = "";
          defaultOption.textContent = "-- Seleziona un canale --";
          elements.channelSelect.appendChild(defaultOption);
          
          // Aggiungi i canali
          channels.forEach(channel => {
            const option = document.createElement('option');
            option.value = channel.id;
            option.textContent = channel.id;
            elements.channelSelect.appendChild(option);
          });
          
          showSuccess(`Trovati ${channels.length} canali criptati`);
        } catch (err) {
          showError(`Errore caricamento canali: ${err.message}`);
        }
      });
      
      // Entra in canale
      elements.joinChannelBtn.addEventListener('click', async () => {
        if (!checkLoginStatus()) {
          showError("Devi effettuare il login");
          activateTab('login');
          return;
        }
        
        const channelId = elements.channelSelect.value;
        const secret = elements.joinSecret.value.trim();
        
        if (!channelId) {
          showError("Seleziona un canale");
          return;
        }
        
        if (!secret) {
          showError("Inserisci il segreto condiviso");
          return;
        }
        
        try {
          const channelInfo = await joinSharedChannel(channelId, secret);
          
          // Salva informazioni canale e attiva
          state.currentChannel = channelInfo.channelId;
          state.channelKey = channelInfo.encryptionKey;
          state.metadata = channelInfo.metadata;
          
          elements.currentChannel.textContent = channelInfo.metadata.name;
          elements.channelMessages.innerHTML = "";
          state.messageMap.clear();
          
          // Ascolta i messaggi
          listenToEncryptedChannel();
          
          showSuccess(`Entrato nel canale "${channelInfo.metadata.name}" con successo!`);
          elements.joinSecret.value = "";
          
          // Vai alla tab chat
          activateTab('chat');
        } catch (err) {
          showError(`Errore partecipazione canale: ${err.message}`);
        }
      });
      
      // Invia messaggio
      elements.sendMsgBtn.addEventListener('click', async () => {
        if (!checkLoginStatus()) {
          showError("Devi effettuare il login");
          activateTab('login');
          return;
        }
        
        if (!state.currentChannel) {
          showError("Nessun canale attivo");
          activateTab('join');
          return;
        }
        
        const message = elements.messageInput.value.trim();
        if (!message) {
          showError("Inserisci un messaggio");
          return;
        }
        
        const success = await sendEncryptedMessage(message);
        if (success) {
          elements.messageInput.value = "";
        }
      });
      
      // Enter key in messaggio
      elements.messageInput.addEventListener('keydown', async (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          elements.sendMsgBtn.click();
        }
      });
      
      // Tab switching
      elements.tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const tabName = tab.getAttribute('data-tab');
          activateTab(tabName);
        });
      });
      
      // Inizializzazione
      document.addEventListener('DOMContentLoaded', () => {
        checkLoginStatus();
      });
    </script>
  </body>
</html> 