<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <title>PanPot Server</title>
  <!-- Import Bugout dependency -->
  <script src="https://chr15m.github.io/bugout/bugout.min.js"></script>
  <!-- Import SEA for encryption -->
  <script src="https://cdn.jsdelivr.net/npm/gun/sea.js"></script>
  <!-- Import QR Code -->
  <script src="//cdn.jsdelivr.net/npm/qrcode@latest/build/qrcode.min.js"></script>
  <!-- Import Bugoff -->
  <script src="bugoff-browser.js"></script>
</head>
<body><pre id="log"></pre></body>
<script>
  log("*BUGOFF SECURE SERVER*");
  log("\nmessageboard secure server\n");
  log("(view source to see the server code)\n");

  // instantiate our bugoff instance
  var seed = localStorage["bugoff-messageboard-seed"];
  var b = new Bugoff(null, {seed: seed});
  // save the seed for next time
  localStorage["bugoff-messageboard-seed"] = b.bugout.seed;
  
  // Variable to track if we're ready
  var isReady = false;

  // Initialize SEA encryption
  b.SEA().then(pair => {
    log("SEA encryption initialized");
    // log this server's address
    log("address:", b.address);
    log("announcing...");
    
    // Force proceed after some time if we don't get any connection
    setTimeout(function() {
      if (!isReady) {
        log("Nessuna connessione rilevata, proseguimento forzato...");
        forceServerReady();
      }
    }, 10000); // Wait 10 seconds before forcing ready state
  });
  
  // Function to force server into ready state
  function forceServerReady() {
    if (!isReady) {
      isReady = true;
      
      log("ready (forzato)");
      
      // link to the messageboard client URL
      var clientURL = document.location.href.replace("-server", "") + "#" + b.address;
      
      // qrcode for the client URL
      if (window.innerWidth > 600) {
        log(qr(clientURL));
      } else {
        log();
      }
      
      log(clientURL + "\n");
      log("Connect back to this secure server-in-a-tab using the link above.");
      
      // Force announce every minute to improve connectivity
      setInterval(function() {
        b.forceAnnounce();
        log("Annuncio forzato ai tracker...");
      }, 60000);
    }
  }

  // load messages from previous run
  var messages = [];
  if (localStorage["bugoff-messageboard"]) {
    try {
      messages = JSON.parse(localStorage["bugoff-messageboard"]);
    } catch (e) {
      log("Error loading previous messages:", e);
    }
  }
  if (typeof(messages) != "object" || !messages["length"]) {
    messages = [];
  }

  /*** rpc calls ***/

  // simple "ping" rpc call
  b.register("ping", function(address, args, cb) {
    args["pong"] = Math.random();
    cb(args);
  });

  /*** messageboard server API ***/

  b.register("post", function(address, message, cb) {
    if (typeof(message) == "string" && message.length < 280) {
      // Extract nickname if present (format: "Nickname: message")
      let nickname = "";
      let messageContent = message;
      
      const colonIndex = message.indexOf(":");
      if (colonIndex > 0 && colonIndex < 30) { // Assume a reasonable nickname length
        nickname = message.substring(0, colonIndex).trim();
        messageContent = message.substring(colonIndex + 1).trim();
      }
      
      var m = {
        address: address, 
        m: messageContent, 
        t: (new Date()).getTime(),
        nick: nickname
      };
      
      log("messageboard:", m);
      messages.push(m);
      messages = messages.slice(Math.max(0, messages.length - 10));
      localStorage["bugoff-messageboard"] = JSON.stringify(messages);
      cb(true);
      
      // Send refresh notification to all connected clients
      // Use the encrypted broadcast mechanism of Bugoff
      b.send("refresh");
    } else {
      cb(false);
    }
  }, "Post a message to the board");

  b.register("list", function(address, args, cb) {
    cb(messages.slice().reverse());
  }, "List most recent messages");

  /*** logging ***/

  // log when network connectivity changes
  var connected = false;
  b.on("connections", function(c) {
    log("connections:", c);
    
    if (c == 0 && connected == false) {
      connected = true;
      isReady = true;
      log("ready");
      // link to the messageboard client URL
      var clientURL = document.location.href.replace("-server", "") + "#" + b.address;
      // qrcode for the client URL
      if (window.innerWidth > 600) {
        log(qr(clientURL));
      } else {
        log();
      }
      log(clientURL + "\n");
      log("Connect back to this secure server-in-a-tab using the link above.");
    }
  });
  
  // Listen for torrent initialization
  b.bugout.on("torrentinitialized", function() {
    log("Torrent inizializzato!");
    
    // Ensure tracker URLs are correct
    log("Trackers configurati:", b.bugout.trackers);
    
    // Force announce after 5 seconds
    setTimeout(function() {
      b.forceAnnounce();
      log("Annuncio forzato ai tracker...");
    }, 5000);
  });

  // Listen for decrypted messages
  b.bugout.on("decrypted", function(address, pubkeys, msg) { 
    log("decrypted message:", address, msg); 
  });

  // log when a client makes an rpc call
  b.on("rpc", function(address, call, args) { log("rpc:", address, call, args); });

  // log when we see a new client address
  b.on("seen", function(address) { 
    log("seen:", address);
    // If we see a peer but still not ready, force ready state
    if (!isReady) {
      forceServerReady();
    }
  });

  // Event listener for new peer registration
  b.events.on("newPeer", function(peers) {
    log("peers updated:", Object.keys(peers).length, "connected");
  });

  // simple logging function
  function log() {
    var args = Array.prototype.slice.call(arguments);
    console.log.apply(null, args);
    args = args.map(function(a) { if (typeof(a) == "string") return a; else return JSON.stringify(a); });
    document.getElementById("log").textContent += args.join(" ") + "\n";
  }

  // generate a text based qr code
  function qr(txt) {
    var q = QRCode.create(txt);
    var code = "\n\n";
    for (var i=0; i<2; i++) {
      code += "  ████";
      for (var j=0; j<q.modules.size; j++) {
        code += "██";
      }
      code += "████\n";
    }
    for (var i=0; i<q.modules.size; i++) {
      code += "  ████";
      for (var j=0; j<q.modules.size; j++) {
        code += q.modules.data[i * q.modules.size + j] ? "  " : "██";
      }
      code += "████\n";
    }
    for (var i=0; i<2; i++) {
      code += "  ████";
      for (var j=0; j<q.modules.size; j++) {
        code += "██";
      }
      code += "████\n";
    }
    return code + "\n\n";
  }

</script>
<style>
  body { background-color: #333; }
  pre { color: #eee; white-space: pre-wrap; word-wrap: break-word; line-height: 1em; font-family: monospace; }
</style>
</html>
