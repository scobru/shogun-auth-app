<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <title>PanPot Server</title>
  <!-- Import Bugout dependency -->
  <script src="https://chr15m.github.io/bugout/bugout.min.js"></script>
  <!-- Import SEA for encryption -->
  <script src="https://cdn.jsdelivr.net/npm/gun/sea.js"></script>
  <!-- Import QR Code -->
  <script src="//cdn.jsdelivr.net/npm/qrcode@latest/build/qrcode.min.js"></script>
  <!-- Import Bugoff -->
  <script src="bugoff-browser.js"></script>
</head>
<body><pre id="log"></pre></body>
<script>
  // Simple logging function
  function log() {
    var args = Array.prototype.slice.call(arguments);
    console.log.apply(null, args);
    args = args.map(function(a) { if (typeof(a) == "string") return a; else return JSON.stringify(a); });
    document.getElementById("log").textContent += args.join(" ") + "\n";
  }

  log("*PANPOT SECURE SERVER*");
  log("\nMessaggi sicuri P2P\n");
  log("(view source to see the server code)\n");

  // Custom trackers that are more reliable
  var customTrackers = [
    "wss://tracker.openwebtorrent.com",
    "wss://tracker.btorrent.xyz",
    "wss://tracker.files.fm:7073/announce",
    "wss://tracker.webtorrent.dev",
    "wss://tracker.sloppyta.co:443/announce",
    "wss://spacetradersapi-chatbox.herokuapp.com:443/announce"
  ];

  // instantiate our bugout instance directly for better control
  var seed = localStorage["bugout-messageboard-seed"];
  var bugoutOpts = {
    trackers: customTrackers,
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:global.stun.twilio.com:3478' }
    ]
  };
  
  // Add seed if exists
  if (seed) {
    bugoutOpts.seed = seed;
  }
  
  log("Inizializzazione con trackers personalizzati...");
  var b = new Bugout(bugoutOpts);
  var serverAddress = b.address();
  
  // Save seed for next time
  localStorage["bugout-messageboard-seed"] = b.seed;
  log("Seed salvato:", b.seed.substring(0, 10) + "...");
  
  // SEA variables
  var sea = null;
  var peers = {};
  
  // Initialize SEA for encryption
  async function initSEA() {
    try {
      sea = await SEA.pair();
      log("Crittografia SEA inizializzata");
      return sea;
    } catch (e) {
      log("Errore inizializzazione SEA:", e);
      return null;
    }
  }

  // Initialize SEA
  initSEA().then(function(pair) {
    // Log server's address
    log("Indirizzo server:", serverAddress);
    log("Annuncio in corso...");
    
    // Try to force announce after a delay
    setTimeout(function() {
      try {
        if (b.torrent && b.torrent.discovery && typeof b.torrent.discovery.announce === 'function') {
          log("Annuncio forzato ai tracker...");
          b.torrent.discovery.announce();
        }
      } catch (e) {
        log("Annuncio fallito:", e);
      }
      
      // Show server ready message anyway
      log("Server pronto!");
      
      // Link to the client URL
      var clientURL = document.location.href.replace("-server", "") + "#" + serverAddress;
      
      // QR code for the client URL
      if (window.innerWidth > 600) {
        log(qr(clientURL));
      } else {
        log();
      }
      
      log(clientURL + "\n");
      log("Connettiti al server usando il link qui sopra.");
    }, 5000);
  });

  // load messages from previous run
  var messages = [];
  if (localStorage["bugout-messageboard"]) {
    try {
      messages = JSON.parse(localStorage["bugout-messageboard"]);
      log("Messaggi caricati:", messages.length);
    } catch (e) {
      log("Errore caricamento messaggi:", e);
    }
  }
  if (typeof(messages) != "object" || !messages["length"]) {
    messages = [];
  }

  // Register 'peer' RPC for key exchange
  b.register('peer', function(address, remoteSea, cb) {
    if (!remoteSea || !remoteSea.pub || !remoteSea.epub) {
      log("Chiavi peer non valide da:", address);
      if (cb) cb(false);
      return;
    }
    
    peers[address] = {pub: remoteSea.pub, epub: remoteSea.epub};
    log("Chiavi ricevute da:", address);
    
    // Send our keys back if we have them
    if (sea && cb) {
      cb(sea);
    } else {
      if (cb) cb(true);
    }
  });

  // Register standard APIs for the messageboard
  b.register("ping", function(address, args, cb) {
    args["pong"] = Math.random();
    cb(args);
  });

  // Post message API
  b.register("post", function(address, message, cb) {
    if (typeof(message) == "string" && message.length < 280) {
      // Extract nickname if present (format: "Nickname: message")
      let nickname = "";
      let messageContent = message;
      
      const colonIndex = message.indexOf(":");
      if (colonIndex > 0 && colonIndex < 30) { // Assume a reasonable nickname length
        nickname = message.substring(0, colonIndex).trim();
        messageContent = message.substring(colonIndex + 1).trim();
      }
      
      var m = {
        address: address, 
        m: messageContent, 
        t: (new Date()).getTime(),
        nick: nickname
      };
      
      log("Nuovo messaggio:", m);
      messages.push(m);
      messages = messages.slice(Math.max(0, messages.length - 10));
      localStorage["bugout-messageboard"] = JSON.stringify(messages);
      cb(true);
      
      // Send refresh notification to all clients
      b.send("refresh");
    } else {
      cb(false);
    }
  }, "Post a message to the board");

  // List messages API
  b.register("list", function(address, args, cb) {
    cb(messages.slice().reverse());
  }, "List most recent messages");

  // Event handlers
  b.on("seen", function(address) { 
    log("Nuovo peer:", address);
    
    // Send our keys to new peer if available
    if (sea) {
      b.rpc(address, "peer", sea, function(result) {
        if (result && result.pub) {
          log("Scambio chiavi completato con:", address);
          peers[address] = {pub: result.pub, epub: result.epub};
        }
      });
    }
  });

  b.on("connections", function(count) {
    log("Connessioni attive:", count);
  });

  b.on("rpc", function(address, call, args) { 
    log("RPC da", address + ":", call); 
  });

  b.on("message", function(address, message) { 
    log("Messaggio da", address + ":", message); 
  });

  // Periodic announce to improve connections
  setInterval(function() {
    try {
      if (b.torrent && b.torrent.discovery && typeof b.torrent.discovery.announce === 'function') {
        b.torrent.discovery.announce();
        log("Annuncio periodico...");
      }
    } catch (e) {
      // Silent fail
    }
  }, 60000);

  // generate a text based qr code
  function qr(txt) {
    var q = QRCode.create(txt);
    var code = "\n\n";
    for (var i=0; i<2; i++) {
      code += "  ████";
      for (var j=0; j<q.modules.size; j++) {
        code += "██";
      }
      code += "████\n";
    }
    for (var i=0; i<q.modules.size; i++) {
      code += "  ████";
      for (var j=0; j<q.modules.size; j++) {
        code += q.modules.data[i * q.modules.size + j] ? "  " : "██";
      }
      code += "████\n";
    }
    for (var i=0; i<2; i++) {
      code += "  ████";
      for (var j=0; j<q.modules.size; j++) {
        code += "██";
      }
      code += "████\n";
    }
    return code + "\n\n";
  }

</script>
<style>
  body { background-color: #333; }
  pre { color: #eee; white-space: pre-wrap; word-wrap: break-word; line-height: 1em; font-family: monospace; }
</style>
</html>
