import { Model } from '../core/Model';

export class ${ModelName} extends Model {
  static gunInstance: any;
  attrs: any = {};
${attributes}

  constructor(data: any = {}) {
    super(data);
    Object.assign(this.attrs, data);
    Object.keys(data).forEach(key => {
      this[key] = data[key];
    });
  }

  static setGunInstance(gun: any) {
    this.gunInstance = gun;
  }

  static async findAll(): Promise<${ModelName}[]> {
    if (!this.gunInstance) {
      throw new Error('Gun instance not set. Call setGunInstance first.');
    }

    return new Promise((resolve, reject) => {
      const items: ${ModelName}[] = [];
      this.gunInstance.get('${modelNameLower}s').map().once((data, id) => {
        if (data) {
          const item = new ${ModelName}(data);
          item.attrs._soul = id;
          items.push(item);
        }
      });

      // In a real app, you might want to use Gun's .then() or other mechanisms to know when data is loaded
      setTimeout(() => resolve(items), 100);
    });
  }

  static async findById(id: string): Promise<${ModelName} | null> {
    if (!this.gunInstance) {
      throw new Error('Gun instance not set. Call setGunInstance first.');
    }

    return new Promise((resolve, reject) => {
      this.gunInstance.get('${modelNameLower}s').get(id).once((data) => {
        if (data) {
          const item = new ${ModelName}(data);
          item.attrs._soul = id;
          resolve(item);
        } else {
          resolve(null);
        }
      });
    });
  }

  async save(): Promise<this> {
    if (!${ModelName}.gunInstance) {
      throw new Error('Gun instance not set. Call setGunInstance first.');
    }

    return new Promise((resolve, reject) => {
      const node = ${ModelName}.gunInstance.get('${modelNameLower}s');
      const data = { ...this.attrs };
      delete data._soul; // Don't store the soul in the data
      
      if (this.attrs._soul) {
        // Update existing
        node.get(this.attrs._soul).put(data, (ack) => {
          if (ack.err) {
            reject(ack.err);
          } else {
            resolve(this);
          }
        });
      } else {
        // Create new
        node.set(data, (ack) => {
          if (ack.err) {
            reject(ack.err);
          } else {
            this.attrs._soul = ack.ref.toString().split('/').pop();
            resolve(this);
          }
        });
      }
    });
  }

  async delete(): Promise<void> {
    if (!${ModelName}.gunInstance) {
      throw new Error('Gun instance not set. Call setGunInstance first.');
    }

    if (!this.attrs._soul) {
      throw new Error('Cannot delete an item without an ID.');
    }

    return new Promise((resolve, reject) => {
      ${ModelName}.gunInstance.get('${modelNameLower}s').get(this.attrs._soul).put(null, (ack) => {
        if (ack.err) {
          reject(ack.err);
        } else {
          resolve();
        }
      });
    });
  }

  // Relationship methods
  async addRelation(relationName: string, relatedModel: any): Promise<void> {
    if (!${ModelName}.gunInstance) {
      throw new Error('Gun instance not set. Call setGunInstance first.');
    }

    if (!this.attrs._soul) {
      throw new Error('Cannot add relation to an unsaved item. Save the item first.');
    }

    if (!relatedModel.attrs._soul) {
      throw new Error('Cannot add relation to an unsaved item. Save the related model first.');
    }

    return new Promise((resolve, reject) => {
      // Create a relation node if it doesn't exist
      if (!this.attrs[relationName]) {
        this.attrs[relationName] = {};
      }

      // Add the relation by ID
      const relationData = { ...this.attrs[relationName] };
      relationData[relatedModel.attrs._soul] = true;
      this.attrs[relationName] = relationData;

      // Save the updated relations
      ${ModelName}.gunInstance.get('${modelNameLower}s').get(this.attrs._soul).put(this.attrs, (ack) => {
        if (ack.err) {
          reject(ack.err);
        } else {
          resolve();
        }
      });
    });
  }

  async getRelated<T>(relationName: string, RelatedModel: any): Promise<T[]> {
    if (!${ModelName}.gunInstance) {
      throw new Error('Gun instance not set. Call setGunInstance first.');
    }

    if (!this.attrs._soul) {
      throw new Error('Cannot get relations from an unsaved item.');
    }

    if (!this.attrs[relationName]) {
      return [];
    }

    return new Promise((resolve, reject) => {
      const items: T[] = [];
      const relationIds = Object.keys(this.attrs[relationName]);
      
      if (relationIds.length === 0) {
        resolve(items);
        return;
      }

      let loaded = 0;
      relationIds.forEach(id => {
        // Only process valid relation entries
        if (this.attrs[relationName][id] === true) {
          RelatedModel.findById(id).then((item: T | null) => {
            if (item) {
              items.push(item);
            }
            loaded++;
            if (loaded === relationIds.length) {
              resolve(items);
            }
          });
        } else {
          loaded++;
          if (loaded === relationIds.length) {
            resolve(items);
          }
        }
      });
    });
  }

  async removeRelation(relationName: string, relatedModel: any): Promise<void> {
    if (!${ModelName}.gunInstance) {
      throw new Error('Gun instance not set. Call setGunInstance first.');
    }

    if (!this.attrs._soul || !relatedModel.attrs._soul) {
      throw new Error('Cannot remove relation from an unsaved item.');
    }

    if (!this.attrs[relationName]) {
      return;
    }

    return new Promise((resolve, reject) => {
      // Remove the relation by ID
      const relationData = { ...this.attrs[relationName] };
      delete relationData[relatedModel.attrs._soul];
      this.attrs[relationName] = relationData;

      // Save the updated relations
      ${ModelName}.gunInstance.get('${modelNameLower}s').get(this.attrs._soul).put(this.attrs, (ack) => {
        if (ack.err) {
          reject(ack.err);
        } else {
          resolve();
        }
      });
    });
  }

  // Registra il modello al caricamento della classe
  static {
    this.modelName = '${ModelName}';
    this.tableName = '${modelNameLower}s';
    this.register();
  }
}

// Esempio di definizione di relazioni
// Per abilitare le relazioni, decommentare e modificare i seguenti esempi:
/* 
// Relazione uno-a-molti (hasMany)
${ModelName}.hasMany('OtherModel', { as: 'otherModels' });

// Relazione uno-a-uno (hasOne)
${ModelName}.hasOne('OtherModel', { as: 'otherModel' });

// Relazione di appartenenza (belongsTo)
${ModelName}.belongsTo('OtherModel', { as: 'parent' });
*/ 